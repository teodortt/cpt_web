(window["webpackJsonp_N_E"] = window["webpackJsonp_N_E"] || []).push([[1],{

/***/ "./components/CarouselTabs.js":
/*!************************************!*\
  !*** ./components/CarouselTabs.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _splidejs_react_splide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @splidejs/react-splide */ \"./node_modules/@splidejs/react-splide/dist/js/index.js\");\n/* harmony import */ var _splidejs_react_splide__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_splidejs_react_splide__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _splidejs_splide_dist_css_themes_splide_default_min_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @splidejs/splide/dist/css/themes/splide-default.min.css */ \"./node_modules/@splidejs/splide/dist/css/themes/splide-default.min.css\");\n/* harmony import */ var _splidejs_splide_dist_css_themes_splide_default_min_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_splidejs_splide_dist_css_themes_splide_default_min_css__WEBPACK_IMPORTED_MODULE_3__);\n\n\nvar _jsxFileName = \"/Users/enzzure/Downloads/cpt-react/components/CarouselTabs.js\",\n    _this = undefined,\n    _s = $RefreshSig$();\n\n\n\n\n\nvar CarouselTabs = function CarouselTabs() {\n  _s();\n\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])([]),\n      data = _useState[0],\n      setData = _useState[1];\n\n  function lastPosts() {\n    var URL = \"https://www.centralparktours.net/blog/ghost/api/v3/content/posts/?key=d0f43d7dd165f96b5a288cd583&filter=tags:events&limit=5\";\n    fetch(URL).then(function (response) {\n      return response.json();\n    }).then(function (data) {\n      return setData(data.posts);\n    });\n  }\n\n  Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\n    lastPosts();\n  }, []);\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_splidejs_react_splide__WEBPACK_IMPORTED_MODULE_2__[\"Splide\"], {\n    options: {\n      perPage: 2,\n      cover: true,\n      // width: '90%',\n      gap: '2.7rem',\n      height: '18rem',\n      lazyLoad: 'nearby',\n      pagination: false,\n      // arrowPath: 'm15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z',\n      breakpoints: {\n        '640': {\n          perPage: 2,\n          gap: '1rem'\n        },\n        '480': {\n          perPage: 1,\n          gap: '1rem',\n          padding: {\n            right: '2rem',\n            left: '2rem'\n          }\n        }\n      },\n      // type: 'loop',\n      padding: {\n        right: '5rem',\n        left: '5rem'\n      }\n    },\n    children: data.map(function (data, i) {\n      return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(_splidejs_react_splide__WEBPACK_IMPORTED_MODULE_2__[\"SplideSlide\"], {\n        className: \"brd my-5\",\n        children: [/*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"img\", {\n          src: data.feature_image,\n          alt: \"Image 1\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 58,\n          columnNumber: 21\n        }, _this), /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(\"p\", {\n          className: \"post-title\",\n          children: data.title\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 59,\n          columnNumber: 21\n        }, _this)]\n      }, i, true, {\n        fileName: _jsxFileName,\n        lineNumber: 56,\n        columnNumber: 17\n      }, _this);\n    })\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 22,\n    columnNumber: 9\n  }, _this);\n};\n\n_s(CarouselTabs, \"IEMTtLVFIuToo7X/raQbJAxzNQU=\");\n\n_c = CarouselTabs;\n/* harmony default export */ __webpack_exports__[\"default\"] = (CarouselTabs);\n\nvar _c;\n\n$RefreshReg$(_c, \"CarouselTabs\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"./node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9DYXJvdXNlbFRhYnMuanM/ZGVmZSJdLCJuYW1lcyI6WyJDYXJvdXNlbFRhYnMiLCJ1c2VTdGF0ZSIsImRhdGEiLCJzZXREYXRhIiwibGFzdFBvc3RzIiwiVVJMIiwiZmV0Y2giLCJ0aGVuIiwicmVzcG9uc2UiLCJqc29uIiwicG9zdHMiLCJ1c2VFZmZlY3QiLCJwZXJQYWdlIiwiY292ZXIiLCJnYXAiLCJoZWlnaHQiLCJsYXp5TG9hZCIsInBhZ2luYXRpb24iLCJicmVha3BvaW50cyIsInBhZGRpbmciLCJyaWdodCIsImxlZnQiLCJtYXAiLCJpIiwiZmVhdHVyZV9pbWFnZSIsInRpdGxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUVBO0FBQ0E7O0FBRUEsSUFBTUEsWUFBWSxHQUFHLFNBQWZBLFlBQWUsR0FBTTtBQUFBOztBQUFBLGtCQUVDQyxzREFBUSxDQUFDLEVBQUQsQ0FGVDtBQUFBLE1BRWhCQyxJQUZnQjtBQUFBLE1BRVZDLE9BRlU7O0FBSXZCLFdBQVNDLFNBQVQsR0FBcUI7QUFDakIsUUFBSUMsR0FBRyxnSUFBUDtBQUNBQyxTQUFLLENBQUNELEdBQUQsQ0FBTCxDQUNLRSxJQURMLENBQ1UsVUFBQ0MsUUFBRDtBQUFBLGFBQWNBLFFBQVEsQ0FBQ0MsSUFBVCxFQUFkO0FBQUEsS0FEVixFQUVLRixJQUZMLENBRVUsVUFBQUwsSUFBSTtBQUFBLGFBQUlDLE9BQU8sQ0FBQ0QsSUFBSSxDQUFDUSxLQUFOLENBQVg7QUFBQSxLQUZkO0FBR0g7O0FBRURDLHlEQUFTLENBQUMsWUFBTTtBQUNaUCxhQUFTO0FBQ1osR0FGUSxFQUVOLEVBRk0sQ0FBVDtBQUlBLHNCQUNJLHFFQUFDLDZEQUFEO0FBQ0ksV0FBTyxFQUFFO0FBQ0xRLGFBQU8sRUFBRSxDQURKO0FBRUxDLFdBQUssRUFBRSxJQUZGO0FBR0w7QUFDQUMsU0FBRyxFQUFFLFFBSkE7QUFLTEMsWUFBTSxFQUFFLE9BTEg7QUFNTEMsY0FBUSxFQUFFLFFBTkw7QUFPTEMsZ0JBQVUsRUFBRSxLQVBQO0FBUUw7QUFDQUMsaUJBQVcsRUFBRTtBQUNULGVBQU87QUFDSE4saUJBQU8sRUFBRSxDQUROO0FBRUhFLGFBQUcsRUFBRTtBQUZGLFNBREU7QUFLVCxlQUFPO0FBQ0hGLGlCQUFPLEVBQUUsQ0FETjtBQUVIRSxhQUFHLEVBQUUsTUFGRjtBQUdISyxpQkFBTyxFQUFFO0FBQ0xDLGlCQUFLLEVBQUUsTUFERjtBQUVMQyxnQkFBSSxFQUFFO0FBRkQ7QUFITjtBQUxFLE9BVFI7QUF3Qkw7QUFDQUYsYUFBTyxFQUFFO0FBQ0xDLGFBQUssRUFBRSxNQURGO0FBRUxDLFlBQUksRUFBRTtBQUZEO0FBekJKLEtBRGI7QUFBQSxjQWlDS25CLElBQUksQ0FBQ29CLEdBQUwsQ0FBUyxVQUFDcEIsSUFBRCxFQUFPcUIsQ0FBUDtBQUFBLDBCQUNOLHFFQUFDLGtFQUFEO0FBQXFCLGlCQUFTLEVBQUMsVUFBL0I7QUFBQSxnQ0FFSTtBQUFLLGFBQUcsRUFBRXJCLElBQUksQ0FBQ3NCLGFBQWY7QUFBOEIsYUFBRyxFQUFDO0FBQWxDO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBRkosZUFHSTtBQUFHLG1CQUFTLEVBQUMsWUFBYjtBQUFBLG9CQUEyQnRCLElBQUksQ0FBQ3VCO0FBQWhDO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBSEo7QUFBQSxTQUFrQkYsQ0FBbEI7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQURNO0FBQUEsS0FBVDtBQWpDTDtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBREo7QUFnREgsQ0EvREQ7O0dBQU12QixZOztLQUFBQSxZO0FBaUVTQSwyRUFBZiIsImZpbGUiOiIuL2NvbXBvbmVudHMvQ2Fyb3VzZWxUYWJzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xyXG5cclxuaW1wb3J0IHsgU3BsaWRlLCBTcGxpZGVTbGlkZSB9IGZyb20gJ0BzcGxpZGVqcy9yZWFjdC1zcGxpZGUnO1xyXG5pbXBvcnQgJ0BzcGxpZGVqcy9zcGxpZGUvZGlzdC9jc3MvdGhlbWVzL3NwbGlkZS1kZWZhdWx0Lm1pbi5jc3MnO1xyXG5cclxuY29uc3QgQ2Fyb3VzZWxUYWJzID0gKCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IHVzZVN0YXRlKFtdKTtcclxuXHJcbiAgICBmdW5jdGlvbiBsYXN0UG9zdHMoKSB7XHJcbiAgICAgICAgbGV0IFVSTCA9IGBodHRwczovL3d3dy5jZW50cmFscGFya3RvdXJzLm5ldC9ibG9nL2dob3N0L2FwaS92My9jb250ZW50L3Bvc3RzLz9rZXk9ZDBmNDNkN2RkMTY1Zjk2YjVhMjg4Y2Q1ODMmZmlsdGVyPXRhZ3M6ZXZlbnRzJmxpbWl0PTVgO1xyXG4gICAgICAgIGZldGNoKFVSTClcclxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXHJcbiAgICAgICAgICAgIC50aGVuKGRhdGEgPT4gc2V0RGF0YShkYXRhLnBvc3RzKSlcclxuICAgIH1cclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGxhc3RQb3N0cygpO1xyXG4gICAgfSwgW10pXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8U3BsaWRlXHJcbiAgICAgICAgICAgIG9wdGlvbnM9e3tcclxuICAgICAgICAgICAgICAgIHBlclBhZ2U6IDIsXHJcbiAgICAgICAgICAgICAgICBjb3ZlcjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIC8vIHdpZHRoOiAnOTAlJyxcclxuICAgICAgICAgICAgICAgIGdhcDogJzIuN3JlbScsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICcxOHJlbScsXHJcbiAgICAgICAgICAgICAgICBsYXp5TG9hZDogJ25lYXJieScsXHJcbiAgICAgICAgICAgICAgICBwYWdpbmF0aW9uOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIC8vIGFycm93UGF0aDogJ20xNS41IDAuOTMyLTQuMyA0LjM4IDE0LjUgMTQuNi0xNC41IDE0LjUgNC4zIDQuNCAxNC42LTE0LjYgNC40LTQuMy00LjQtNC40LTE0LjYtMTQuNnonLFxyXG4gICAgICAgICAgICAgICAgYnJlYWtwb2ludHM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnNjQwJzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJQYWdlOiAyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXA6ICcxcmVtJyxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICc0ODAnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlclBhZ2U6IDEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcDogJzFyZW0nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogJzJyZW0nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogJzJyZW0nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgICAgIC8vIHR5cGU6ICdsb29wJyxcclxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IHtcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogJzVyZW0nLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICc1cmVtJyxcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH19XHJcbiAgICAgICAgPlxyXG5cclxuICAgICAgICAgICAge2RhdGEubWFwKChkYXRhLCBpKSA9PiAoXHJcbiAgICAgICAgICAgICAgICA8U3BsaWRlU2xpZGUga2V5PXtpfSBjbGFzc05hbWU9XCJicmQgbXktNVwiPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz17ZGF0YS5mZWF0dXJlX2ltYWdlfSBhbHQ9XCJJbWFnZSAxXCIgLz5cclxuICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJwb3N0LXRpdGxlXCI+e2RhdGEudGl0bGV9PC9wPlxyXG5cclxuICAgICAgICAgICAgICAgIDwvU3BsaWRlU2xpZGU+XHJcbiAgICAgICAgICAgICkpfVxyXG5cclxuICAgICAgICAgICAgey8qIDxTcGxpZGVTbGlkZSBjbGFzc05hbWU9XCJicmRcIj5cclxuICAgICAgICAgICAgPC9TcGxpZGVTbGlkZT4gKi99XHJcblxyXG4gICAgICAgIDwvU3BsaWRlPlxyXG4gICAgKVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDYXJvdXNlbFRhYnM7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./components/CarouselTabs.js\n");

/***/ }),

/***/ "./node_modules/@splidejs/react-splide/dist/js/components/Splide.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@splidejs/react-splide/dist/js/components/Splide.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _splide = _interopRequireDefault(__webpack_require__(/*! @splidejs/splide */ \"./node_modules/@splidejs/splide/dist/js/splide.esm.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/@splidejs/react-splide/dist/js/utils/index.js\");\n\nvar _events = __webpack_require__(/*! ../constants/events */ \"./node_modules/@splidejs/react-splide/dist/js/constants/events.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n/**\r\n * The class for the Splide component.\r\n */\nvar Splide = /*#__PURE__*/function (_React$Component) {\n  _inherits(Splide, _React$Component);\n\n  var _super = _createSuper(Splide);\n\n  /**\r\n   * Splide constructor.\r\n   *\r\n   * @param {Object}   props                     - Props.\r\n   * @param {string}   props.id                  - Optional. Id attribute for the root element.\r\n   * @param {string}   props.className           - Optional. Additional class name for the root element.\r\n   * @param {boolean}  props.hasSliderWrapper    - Optional. Whether to wrap a track by a slider element.\r\n   * @param {boolean}  props.hasAutoplayProgress - Optional. Whether to render progress bar for autoplay.\r\n   * @param {boolean}  props.hasAutoplayControls - Optional. Whether to render play/pause button for autoplay.\r\n   * @param {string}   props.playButtonLabel     - Optional. The label for the play button.\r\n   * @param {string}   props.pauseButtonLabel    - Optional. The label for the pause button.\r\n   * @param {function} props.renderControls      - Optional. A function to render custom controls.\r\n   */\n  function Splide(props) {\n    var _this;\n\n    _classCallCheck(this, Splide);\n\n    _this = _super.call(this, props);\n    _this.splideRef = /*#__PURE__*/_react[\"default\"].createRef();\n    return _this;\n  }\n  /**\r\n   * Initialize Splide right after the component is mounted.\r\n   */\n\n\n  _createClass(Splide, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props = this.props,\n          _this$props$options = _this$props.options,\n          options = _this$props$options === void 0 ? {} : _this$props$options,\n          _this$props$Extension = _this$props.Extensions,\n          Extensions = _this$props$Extension === void 0 ? {} : _this$props$Extension,\n          _this$props$Transitio = _this$props.Transition,\n          Transition = _this$props$Transitio === void 0 ? null : _this$props$Transitio;\n      this.splide = new _splide[\"default\"](this.splideRef.current, options);\n      this.splide.mount(Extensions, Transition);\n      this.bind();\n    }\n    /**\r\n     * Destroy the splide instance just before the component is unmounted.\r\n     */\n\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.splide) {\n        this.splide.destroy();\n      }\n    }\n    /**\r\n     * Remount the splide when the component is updated.\r\n     */\n\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.splide.refresh();\n    }\n    /**\r\n     * Register handlers to Splide events.\r\n     * All event names are converted to \"on + camelcase\" without colon.\r\n     * For example, arrows:mounted will be onArrowsMounted.\r\n     */\n\n  }, {\n    key: \"bind\",\n    value: function bind() {\n      var _this2 = this;\n\n      _events.EVENTS.forEach(function (event) {\n        var handler = 'on' + event.split(':').map(function (fragment) {\n          return fragment.charAt(0).toUpperCase() + fragment.slice(1);\n        }).join('');\n\n        if (typeof _this2.props[handler] === 'function') {\n          _this2.splide.on(event, function () {\n            var _this2$props;\n\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            (_this2$props = _this2.props)[handler].apply(_this2$props, [_this2.splide].concat(args));\n          });\n        }\n      });\n    }\n    /**\r\n     * Sync to the given splide.\r\n     *\r\n     * @param {Splide} splide - Splide instance.\r\n     */\n\n  }, {\n    key: \"sync\",\n    value: function sync(splide) {\n      if (this.splide) {\n        this.splide.sync(splide);\n        this.remount();\n      }\n    }\n    /**\r\n     * Remount the splide.\r\n     */\n\n  }, {\n    key: \"remount\",\n    value: function remount() {\n      if (this.splide) {\n        this.splide.destroy();\n        this.splide.mount();\n        this.bind();\n      }\n    }\n    /**\r\n     * Render the track element.\r\n     *\r\n     * @return {ReactNode}\r\n     */\n\n  }, {\n    key: \"renderTrack\",\n    value: function renderTrack() {\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: \"splide__track\"\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"ul\", {\n        className: \"splide__list\"\n      }, this.props.children));\n    }\n    /**\r\n     * Render the component.\r\n     *\r\n     * @return {ReactNode} - React component.\r\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props2 = this.props,\n          id = _this$props2.id,\n          className = _this$props2.className,\n          hasSliderWrapper = _this$props2.hasSliderWrapper,\n          hasAutoplayProgress = _this$props2.hasAutoplayProgress,\n          hasAutoplayControls = _this$props2.hasAutoplayControls,\n          _this$props2$playButt = _this$props2.playButtonLabel,\n          playButtonLabel = _this$props2$playButt === void 0 ? 'Play' : _this$props2$playButt,\n          _this$props2$pauseBut = _this$props2.pauseButtonLabel,\n          pauseButtonLabel = _this$props2$pauseBut === void 0 ? 'Pause' : _this$props2$pauseBut,\n          _this$props2$renderCo = _this$props2.renderControls,\n          renderControls = _this$props2$renderCo === void 0 ? _utils.noop : _this$props2$renderCo;\n      return /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        id: id,\n        className: (0, _utils.classNames)('splide', className),\n        ref: this.splideRef\n      }, hasSliderWrapper && /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: \"splide__slider\"\n      }, this.renderTrack()), !hasSliderWrapper && this.renderTrack(), hasAutoplayProgress && /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: \"splide__progress\"\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: \"splide__progress__bar\"\n      })), hasAutoplayControls && /*#__PURE__*/_react[\"default\"].createElement(\"div\", {\n        className: \"splide__autoplay\"\n      }, /*#__PURE__*/_react[\"default\"].createElement(\"button\", {\n        className: \"splide__play\"\n      }, playButtonLabel), /*#__PURE__*/_react[\"default\"].createElement(\"button\", {\n        className: \"splide__pause\"\n      }, pauseButtonLabel)), renderControls());\n    }\n  }]);\n\n  return Splide;\n}(_react[\"default\"].Component);\n\nexports[\"default\"] = Splide;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzcGxpZGVqcy9yZWFjdC1zcGxpZGUvZGlzdC9qcy9jb21wb25lbnRzL1NwbGlkZS5qcz81MGFkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsb0NBQW9DLG1CQUFPLENBQUMsNENBQU87O0FBRW5ELHFDQUFxQyxtQkFBTyxDQUFDLCtFQUFrQjs7QUFFL0QsYUFBYSxtQkFBTyxDQUFDLDhFQUFVOztBQUUvQixjQUFjLG1CQUFPLENBQUMsOEZBQXFCOztBQUUzQyxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOLDBDQUEwQywrREFBK0QsMkVBQTJFLEVBQUUseUVBQXlFLGVBQWUsc0RBQXNELEVBQUUsRUFBRSx1REFBdUQ7O0FBRS9YLGdDQUFnQyw0RUFBNEUsaUJBQWlCLFVBQVUsR0FBRyw4QkFBOEI7O0FBRXhLLGdDQUFnQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELHlEQUF5RCxFQUFFLE9BQU8sdUNBQXVDLEVBQUUsaURBQWlELEdBQUc7O0FBRXZhLGlEQUFpRCwwRUFBMEUsYUFBYSxFQUFFLHFDQUFxQzs7QUFFL0ssdUNBQXVDLHVCQUF1Qix1RkFBdUYsRUFBRSxhQUFhOztBQUVwSyxzQ0FBc0Msd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSx3RUFBd0UsR0FBRyxhQUFhLEVBQUUsWUFBWSxjQUFjLEVBQUU7O0FBRWxVLDZCQUE2QixnR0FBZ0csZ0RBQWdELEdBQUcsMkJBQTJCOztBQUUzTTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUEsK0VBQStFLGFBQWE7QUFDNUY7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BzcGxpZGVqcy9yZWFjdC1zcGxpZGUvZGlzdC9qcy9jb21wb25lbnRzL1NwbGlkZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfcmVhY3QgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cbnZhciBfc3BsaWRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQHNwbGlkZWpzL3NwbGlkZVwiKSk7XG5cbnZhciBfdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5cbnZhciBfZXZlbnRzID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy9ldmVudHNcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbi8qKlxyXG4gKiBUaGUgY2xhc3MgZm9yIHRoZSBTcGxpZGUgY29tcG9uZW50LlxyXG4gKi9cbnZhciBTcGxpZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFNwbGlkZSwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihTcGxpZGUpO1xuXG4gIC8qKlxyXG4gICAqIFNwbGlkZSBjb25zdHJ1Y3Rvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgIHByb3BzICAgICAgICAgICAgICAgICAgICAgLSBQcm9wcy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBwcm9wcy5pZCAgICAgICAgICAgICAgICAgIC0gT3B0aW9uYWwuIElkIGF0dHJpYnV0ZSBmb3IgdGhlIHJvb3QgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gICBwcm9wcy5jbGFzc05hbWUgICAgICAgICAgIC0gT3B0aW9uYWwuIEFkZGl0aW9uYWwgY2xhc3MgbmFtZSBmb3IgdGhlIHJvb3QgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICBwcm9wcy5oYXNTbGlkZXJXcmFwcGVyICAgIC0gT3B0aW9uYWwuIFdoZXRoZXIgdG8gd3JhcCBhIHRyYWNrIGJ5IGEgc2xpZGVyIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtib29sZWFufSAgcHJvcHMuaGFzQXV0b3BsYXlQcm9ncmVzcyAtIE9wdGlvbmFsLiBXaGV0aGVyIHRvIHJlbmRlciBwcm9ncmVzcyBiYXIgZm9yIGF1dG9wbGF5LlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gIHByb3BzLmhhc0F1dG9wbGF5Q29udHJvbHMgLSBPcHRpb25hbC4gV2hldGhlciB0byByZW5kZXIgcGxheS9wYXVzZSBidXR0b24gZm9yIGF1dG9wbGF5LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIHByb3BzLnBsYXlCdXR0b25MYWJlbCAgICAgLSBPcHRpb25hbC4gVGhlIGxhYmVsIGZvciB0aGUgcGxheSBidXR0b24uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgcHJvcHMucGF1c2VCdXR0b25MYWJlbCAgICAtIE9wdGlvbmFsLiBUaGUgbGFiZWwgZm9yIHRoZSBwYXVzZSBidXR0b24uXHJcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJvcHMucmVuZGVyQ29udHJvbHMgICAgICAtIE9wdGlvbmFsLiBBIGZ1bmN0aW9uIHRvIHJlbmRlciBjdXN0b20gY29udHJvbHMuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFNwbGlkZShwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTcGxpZGUpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgX3RoaXMuc3BsaWRlUmVmID0gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlUmVmKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgU3BsaWRlIHJpZ2h0IGFmdGVyIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhTcGxpZGUsIFt7XG4gICAga2V5OiBcImNvbXBvbmVudERpZE1vdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBfdGhpcyRwcm9wcyRvcHRpb25zID0gX3RoaXMkcHJvcHMub3B0aW9ucyxcbiAgICAgICAgICBvcHRpb25zID0gX3RoaXMkcHJvcHMkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfdGhpcyRwcm9wcyRvcHRpb25zLFxuICAgICAgICAgIF90aGlzJHByb3BzJEV4dGVuc2lvbiA9IF90aGlzJHByb3BzLkV4dGVuc2lvbnMsXG4gICAgICAgICAgRXh0ZW5zaW9ucyA9IF90aGlzJHByb3BzJEV4dGVuc2lvbiA9PT0gdm9pZCAwID8ge30gOiBfdGhpcyRwcm9wcyRFeHRlbnNpb24sXG4gICAgICAgICAgX3RoaXMkcHJvcHMkVHJhbnNpdGlvID0gX3RoaXMkcHJvcHMuVHJhbnNpdGlvbixcbiAgICAgICAgICBUcmFuc2l0aW9uID0gX3RoaXMkcHJvcHMkVHJhbnNpdGlvID09PSB2b2lkIDAgPyBudWxsIDogX3RoaXMkcHJvcHMkVHJhbnNpdGlvO1xuICAgICAgdGhpcy5zcGxpZGUgPSBuZXcgX3NwbGlkZVtcImRlZmF1bHRcIl0odGhpcy5zcGxpZGVSZWYuY3VycmVudCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLnNwbGlkZS5tb3VudChFeHRlbnNpb25zLCBUcmFuc2l0aW9uKTtcbiAgICAgIHRoaXMuYmluZCgpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kgdGhlIHNwbGlkZSBpbnN0YW5jZSBqdXN0IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFVubW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5zcGxpZGUpIHtcbiAgICAgICAgdGhpcy5zcGxpZGUuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlbW91bnQgdGhlIHNwbGlkZSB3aGVuIHRoZSBjb21wb25lbnQgaXMgdXBkYXRlZC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuc3BsaWRlLnJlZnJlc2goKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBoYW5kbGVycyB0byBTcGxpZGUgZXZlbnRzLlxyXG4gICAgICogQWxsIGV2ZW50IG5hbWVzIGFyZSBjb252ZXJ0ZWQgdG8gXCJvbiArIGNhbWVsY2FzZVwiIHdpdGhvdXQgY29sb24uXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgYXJyb3dzOm1vdW50ZWQgd2lsbCBiZSBvbkFycm93c01vdW50ZWQuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImJpbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBfZXZlbnRzLkVWRU5UUy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgaGFuZGxlciA9ICdvbicgKyBldmVudC5zcGxpdCgnOicpLm1hcChmdW5jdGlvbiAoZnJhZ21lbnQpIHtcbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBmcmFnbWVudC5zbGljZSgxKTtcbiAgICAgICAgfSkuam9pbignJyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfdGhpczIucHJvcHNbaGFuZGxlcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBfdGhpczIuc3BsaWRlLm9uKGV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyJHByb3BzO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgKF90aGlzMiRwcm9wcyA9IF90aGlzMi5wcm9wcylbaGFuZGxlcl0uYXBwbHkoX3RoaXMyJHByb3BzLCBbX3RoaXMyLnNwbGlkZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU3luYyB0byB0aGUgZ2l2ZW4gc3BsaWRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3BsaWRlfSBzcGxpZGUgLSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN5bmNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3luYyhzcGxpZGUpIHtcbiAgICAgIGlmICh0aGlzLnNwbGlkZSkge1xuICAgICAgICB0aGlzLnNwbGlkZS5zeW5jKHNwbGlkZSk7XG4gICAgICAgIHRoaXMucmVtb3VudCgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlbW91bnQgdGhlIHNwbGlkZS5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdW50KCkge1xuICAgICAgaWYgKHRoaXMuc3BsaWRlKSB7XG4gICAgICAgIHRoaXMuc3BsaWRlLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zcGxpZGUubW91bnQoKTtcbiAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmVuZGVyIHRoZSB0cmFjayBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1JlYWN0Tm9kZX1cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyVHJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyVHJhY2soKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJzcGxpZGVfX3RyYWNrXCJcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJzcGxpZGVfX2xpc3RcIlxuICAgICAgfSwgdGhpcy5wcm9wcy5jaGlsZHJlbikpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlbmRlciB0aGUgY29tcG9uZW50LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1JlYWN0Tm9kZX0gLSBSZWFjdCBjb21wb25lbnQuXHJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBpZCA9IF90aGlzJHByb3BzMi5pZCxcbiAgICAgICAgICBjbGFzc05hbWUgPSBfdGhpcyRwcm9wczIuY2xhc3NOYW1lLFxuICAgICAgICAgIGhhc1NsaWRlcldyYXBwZXIgPSBfdGhpcyRwcm9wczIuaGFzU2xpZGVyV3JhcHBlcixcbiAgICAgICAgICBoYXNBdXRvcGxheVByb2dyZXNzID0gX3RoaXMkcHJvcHMyLmhhc0F1dG9wbGF5UHJvZ3Jlc3MsXG4gICAgICAgICAgaGFzQXV0b3BsYXlDb250cm9scyA9IF90aGlzJHByb3BzMi5oYXNBdXRvcGxheUNvbnRyb2xzLFxuICAgICAgICAgIF90aGlzJHByb3BzMiRwbGF5QnV0dCA9IF90aGlzJHByb3BzMi5wbGF5QnV0dG9uTGFiZWwsXG4gICAgICAgICAgcGxheUJ1dHRvbkxhYmVsID0gX3RoaXMkcHJvcHMyJHBsYXlCdXR0ID09PSB2b2lkIDAgPyAnUGxheScgOiBfdGhpcyRwcm9wczIkcGxheUJ1dHQsXG4gICAgICAgICAgX3RoaXMkcHJvcHMyJHBhdXNlQnV0ID0gX3RoaXMkcHJvcHMyLnBhdXNlQnV0dG9uTGFiZWwsXG4gICAgICAgICAgcGF1c2VCdXR0b25MYWJlbCA9IF90aGlzJHByb3BzMiRwYXVzZUJ1dCA9PT0gdm9pZCAwID8gJ1BhdXNlJyA6IF90aGlzJHByb3BzMiRwYXVzZUJ1dCxcbiAgICAgICAgICBfdGhpcyRwcm9wczIkcmVuZGVyQ28gPSBfdGhpcyRwcm9wczIucmVuZGVyQ29udHJvbHMsXG4gICAgICAgICAgcmVuZGVyQ29udHJvbHMgPSBfdGhpcyRwcm9wczIkcmVuZGVyQ28gPT09IHZvaWQgMCA/IF91dGlscy5ub29wIDogX3RoaXMkcHJvcHMyJHJlbmRlckNvO1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGNsYXNzTmFtZTogKDAsIF91dGlscy5jbGFzc05hbWVzKSgnc3BsaWRlJywgY2xhc3NOYW1lKSxcbiAgICAgICAgcmVmOiB0aGlzLnNwbGlkZVJlZlxuICAgICAgfSwgaGFzU2xpZGVyV3JhcHBlciAmJiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInNwbGlkZV9fc2xpZGVyXCJcbiAgICAgIH0sIHRoaXMucmVuZGVyVHJhY2soKSksICFoYXNTbGlkZXJXcmFwcGVyICYmIHRoaXMucmVuZGVyVHJhY2soKSwgaGFzQXV0b3BsYXlQcm9ncmVzcyAmJiAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInNwbGlkZV9fcHJvZ3Jlc3NcIlxuICAgICAgfSwgLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogXCJzcGxpZGVfX3Byb2dyZXNzX19iYXJcIlxuICAgICAgfSkpLCBoYXNBdXRvcGxheUNvbnRyb2xzICYmIC8qI19fUFVSRV9fKi9fcmVhY3RbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBjbGFzc05hbWU6IFwic3BsaWRlX19hdXRvcGxheVwiXG4gICAgICB9LCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInNwbGlkZV9fcGxheVwiXG4gICAgICB9LCBwbGF5QnV0dG9uTGFiZWwpLCAvKiNfX1BVUkVfXyovX3JlYWN0W1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInNwbGlkZV9fcGF1c2VcIlxuICAgICAgfSwgcGF1c2VCdXR0b25MYWJlbCkpLCByZW5kZXJDb250cm9scygpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3BsaWRlO1xufShfcmVhY3RbXCJkZWZhdWx0XCJdLkNvbXBvbmVudCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU3BsaWRlOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@splidejs/react-splide/dist/js/components/Splide.js\n");

/***/ }),

/***/ "./node_modules/@splidejs/react-splide/dist/js/components/SplideSlide.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@splidejs/react-splide/dist/js/components/SplideSlide.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _react = _interopRequireDefault(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\n\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/@splidejs/react-splide/dist/js/utils/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/**\r\n * The component for each slide.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The component for each slide.\r\n *\r\n * @param {Object} props - Props.\r\n */\nvar _default = function _default(_ref) {\n  var children = _ref.children,\n      className = _ref.className;\n  return /*#__PURE__*/_react[\"default\"].createElement(\"li\", {\n    className: (0, _utils.classNames)('splide__slide', className)\n  }, children);\n};\n\nexports[\"default\"] = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzcGxpZGVqcy9yZWFjdC1zcGxpZGUvZGlzdC9qcy9jb21wb25lbnRzL1NwbGlkZVNsaWRlLmpzPzhmYTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxvQ0FBb0MsbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFbkQsYUFBYSxtQkFBTyxDQUFDLDhFQUFVOztBQUUvQixzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNwbGlkZWpzL3JlYWN0LXNwbGlkZS9kaXN0L2pzL2NvbXBvbmVudHMvU3BsaWRlU2xpZGUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwicmVhY3RcIikpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGVhY2ggc2xpZGUuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGVhY2ggc2xpZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIFByb3BzLlxyXG4gKi9cbnZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIF9kZWZhdWx0KF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lO1xuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdFtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImxpXCIsIHtcbiAgICBjbGFzc05hbWU6ICgwLCBfdXRpbHMuY2xhc3NOYW1lcykoJ3NwbGlkZV9fc2xpZGUnLCBjbGFzc05hbWUpXG4gIH0sIGNoaWxkcmVuKTtcbn07XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@splidejs/react-splide/dist/js/components/SplideSlide.js\n");

/***/ }),

/***/ "./node_modules/@splidejs/react-splide/dist/js/constants/events.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@splidejs/react-splide/dist/js/constants/events.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EVENTS = void 0;\n\n/**\r\n * Export event list.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\nvar EVENTS = ['mounted', 'updated', 'move', 'moved', 'drag', 'dragged', 'visible', 'hidden', 'active', 'inactive', 'click', 'arrows:mounted', 'arrows:updated', 'pagination:mounted', 'pagination:updated', 'navigation:mounted', 'autoplay:play', 'autoplay:pause', 'autoplay:playing', 'lazyload:loaded'];\nexports.EVENTS = EVENTS;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzcGxpZGVqcy9yZWFjdC1zcGxpZGUvZGlzdC9qcy9jb25zdGFudHMvZXZlbnRzLmpzP2U0MTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BzcGxpZGVqcy9yZWFjdC1zcGxpZGUvZGlzdC9qcy9jb25zdGFudHMvZXZlbnRzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkVWRU5UUyA9IHZvaWQgMDtcblxuLyoqXHJcbiAqIEV4cG9ydCBldmVudCBsaXN0LlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG52YXIgRVZFTlRTID0gWydtb3VudGVkJywgJ3VwZGF0ZWQnLCAnbW92ZScsICdtb3ZlZCcsICdkcmFnJywgJ2RyYWdnZWQnLCAndmlzaWJsZScsICdoaWRkZW4nLCAnYWN0aXZlJywgJ2luYWN0aXZlJywgJ2NsaWNrJywgJ2Fycm93czptb3VudGVkJywgJ2Fycm93czp1cGRhdGVkJywgJ3BhZ2luYXRpb246bW91bnRlZCcsICdwYWdpbmF0aW9uOnVwZGF0ZWQnLCAnbmF2aWdhdGlvbjptb3VudGVkJywgJ2F1dG9wbGF5OnBsYXknLCAnYXV0b3BsYXk6cGF1c2UnLCAnYXV0b3BsYXk6cGxheWluZycsICdsYXp5bG9hZDpsb2FkZWQnXTtcbmV4cG9ydHMuRVZFTlRTID0gRVZFTlRTOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@splidejs/react-splide/dist/js/constants/events.js\n");

/***/ }),

/***/ "./node_modules/@splidejs/react-splide/dist/js/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@splidejs/react-splide/dist/js/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Splide\", {\n  enumerable: true,\n  get: function get() {\n    return _Splide[\"default\"];\n  }\n});\nObject.defineProperty(exports, \"SplideSlide\", {\n  enumerable: true,\n  get: function get() {\n    return _SplideSlide[\"default\"];\n  }\n});\n\nvar _Splide = _interopRequireDefault(__webpack_require__(/*! ./components/Splide */ \"./node_modules/@splidejs/react-splide/dist/js/components/Splide.js\"));\n\nvar _SplideSlide = _interopRequireDefault(__webpack_require__(/*! ./components/SplideSlide */ \"./node_modules/@splidejs/react-splide/dist/js/components/SplideSlide.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzcGxpZGVqcy9yZWFjdC1zcGxpZGUvZGlzdC9qcy9pbmRleC5qcz8wNjUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxxQ0FBcUMsbUJBQU8sQ0FBQywrRkFBcUI7O0FBRWxFLDBDQUEwQyxtQkFBTyxDQUFDLHlHQUEwQjs7QUFFNUUsc0NBQXNDLHVDQUF1QyxrQkFBa0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNwbGlkZWpzL3JlYWN0LXNwbGlkZS9kaXN0L2pzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTcGxpZGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1NwbGlkZVtcImRlZmF1bHRcIl07XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU3BsaWRlU2xpZGVcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1NwbGlkZVNsaWRlW1wiZGVmYXVsdFwiXTtcbiAgfVxufSk7XG5cbnZhciBfU3BsaWRlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9jb21wb25lbnRzL1NwbGlkZVwiKSk7XG5cbnZhciBfU3BsaWRlU2xpZGUgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvU3BsaWRlU2xpZGVcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@splidejs/react-splide/dist/js/index.js\n");

/***/ }),

/***/ "./node_modules/@splidejs/react-splide/dist/js/utils/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@splidejs/react-splide/dist/js/utils/index.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.noop = noop;\nexports.classNames = classNames;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\r\n * Utility functions.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * No operation.\r\n */\nfunction noop() {}\n/**\r\n * Join class names with/without condition.\r\n *\r\n * @param {string|Object} args - A class name itself or { className: condition } object.\r\n */\n\n\nfunction classNames() {\n  var names = [];\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  args.forEach(function (className) {\n    if (!className) {\n      return;\n    }\n\n    if (typeof className === 'string') {\n      names.push(className);\n    } else if (_typeof(className) === 'object') {\n      Object.keys(className).forEach(function (key) {\n        if (className[key]) {\n          names.push(key);\n        }\n      });\n    }\n  });\n  return names.join(' ');\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzcGxpZGVqcy9yZWFjdC1zcGxpZGUvZGlzdC9qcy91dGlscy9pbmRleC5qcz9mZjgwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSx1QkFBdUIsMkJBQTJCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFeFg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjLGdDQUFnQyx1QkFBdUI7QUFDaEY7OztBQUdBO0FBQ0E7O0FBRUEscUVBQXFFLGFBQWE7QUFDbEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNwbGlkZWpzL3JlYWN0LXNwbGlkZS9kaXN0L2pzL3V0aWxzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm5vb3AgPSBub29wO1xuZXhwb3J0cy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4vKipcclxuICogVXRpbGl0eSBmdW5jdGlvbnMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIE5vIG9wZXJhdGlvbi5cclxuICovXG5mdW5jdGlvbiBub29wKCkge31cbi8qKlxyXG4gKiBKb2luIGNsYXNzIG5hbWVzIHdpdGgvd2l0aG91dCBjb25kaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gYXJncyAtIEEgY2xhc3MgbmFtZSBpdHNlbGYgb3IgeyBjbGFzc05hbWU6IGNvbmRpdGlvbiB9IG9iamVjdC5cclxuICovXG5cblxuZnVuY3Rpb24gY2xhc3NOYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW107XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGFyZ3MuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzLnB1c2goY2xhc3NOYW1lKTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2YoY2xhc3NOYW1lKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIE9iamVjdC5rZXlzKGNsYXNzTmFtZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChjbGFzc05hbWVba2V5XSkge1xuICAgICAgICAgIG5hbWVzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5hbWVzLmpvaW4oJyAnKTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@splidejs/react-splide/dist/js/utils/index.js\n");

/***/ }),

/***/ "./node_modules/@splidejs/splide/dist/css/themes/splide-default.min.css":
/*!******************************************************************************!*\
  !*** ./node_modules/@splidejs/splide/dist/css/themes/splide-default.min.css ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var api = __webpack_require__(/*! ../../../../../next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !../../../../../next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-5-1!../../../../../next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-5-2!./splide-default.min.css */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/@splidejs/splide/dist/css/themes/splide-default.min.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.i, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element){// These elements should always exist. If they do not,\n// this code should fail.\nvar anchorElement=document.querySelector('#__next_css__DO_NOT_USE__');var parentNode=anchorElement.parentNode;// Normally <head>\n// Each style tag should be placed right before our\n// anchor. By inserting before and not after, we do not\n// need to track the last inserted element.\nparentNode.insertBefore(element,anchorElement);};\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a,b,isNamedExport){if(!a&&b||a&&!b){return false;}let p;for(p in a){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue\ncontinue;}if(a[p]!==b[p]){return false;}}for(p in b){if(isNamedExport&&p==='default'){// eslint-disable-next-line no-continue\ncontinue;}if(!a[p]){return false;}}return true;};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !../../../../../next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-5-1!../../../../../next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-5-2!./splide-default.min.css */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/@splidejs/splide/dist/css/themes/splide-default.min.css\",\n      function () {\n        content = __webpack_require__(/*! !../../../../../next/dist/compiled/css-loader/cjs.js??ref--5-oneOf-5-1!../../../../../next/dist/compiled/postcss-loader/cjs.js??ref--5-oneOf-5-2!./splide-default.min.css */ \"./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/@splidejs/splide/dist/css/themes/splide-default.min.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.i, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzcGxpZGVqcy9zcGxpZGUvZGlzdC9jc3MvdGhlbWVzL3NwbGlkZS1kZWZhdWx0Lm1pbi5jc3M/MDIxYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsa05BQXVHO0FBQ3pILDBCQUEwQixtQkFBTyxDQUFDLHVXQUE0Szs7QUFFOU07O0FBRUE7QUFDQSwwQkFBMEIsUUFBUztBQUNuQzs7QUFFQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQSxzRUFBc0Usd0NBQXdDO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLElBQUksSUFBVTtBQUNkO0FBQ0Esa0VBQWtFLGlCQUFpQixjQUFjLE1BQU0sWUFBWSxpQ0FBaUM7QUFDcEosVUFBVSxnQkFBZ0IsZUFBZSxZQUFZLGlDQUFpQztBQUN0RixVQUFVLFVBQVUsZUFBZTtBQUNuQzs7QUFFQTtBQUNBLE1BQU0sdVdBQTRLO0FBQ2xMO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsdVdBQTRLOztBQUV0TTs7QUFFQTtBQUNBLDRCQUE0QixRQUFTO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL0BzcGxpZGVqcy9zcGxpZGUvZGlzdC9jc3MvdGhlbWVzL3NwbGlkZS1kZWZhdWx0Lm1pbi5jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi8uLi9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi01LTEhLi4vLi4vLi4vLi4vLi4vbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTUtMiEuL3NwbGlkZS1kZWZhdWx0Lm1pbi5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KXsvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbi8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbnZhciBhbmNob3JFbGVtZW50PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTt2YXIgcGFyZW50Tm9kZT1hbmNob3JFbGVtZW50LnBhcmVudE5vZGU7Ly8gTm9ybWFsbHkgPGhlYWQ+XG4vLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbi8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3Rcbi8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsYW5jaG9yRWxlbWVudCk7fTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSxiLGlzTmFtZWRFeHBvcnQpe2lmKCFhJiZifHxhJiYhYil7cmV0dXJuIGZhbHNlO31sZXQgcDtmb3IocCBpbiBhKXtpZihpc05hbWVkRXhwb3J0JiZwPT09J2RlZmF1bHQnKXsvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbmNvbnRpbnVlO31pZihhW3BdIT09YltwXSl7cmV0dXJuIGZhbHNlO319Zm9yKHAgaW4gYil7aWYoaXNOYW1lZEV4cG9ydCYmcD09PSdkZWZhdWx0Jyl7Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG5jb250aW51ZTt9aWYoIWFbcF0pe3JldHVybiBmYWxzZTt9fXJldHVybiB0cnVlO307XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vLi4vLi4vLi4vbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9yZWYtLTUtb25lT2YtNS0xIS4uLy4uLy4uLy4uLy4uL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi01LTIhLi9zcGxpZGUtZGVmYXVsdC5taW4uY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3JlZi0tNS1vbmVPZi01LTEhLi4vLi4vLi4vLi4vLi4vbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cmVmLS01LW9uZU9mLTUtMiEuL3NwbGlkZS1kZWZhdWx0Lm1pbi5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@splidejs/splide/dist/css/themes/splide-default.min.css\n");

/***/ }),

/***/ "./node_modules/@splidejs/splide/dist/js/splide.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/@splidejs/splide/dist/js/splide.esm.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Splide.js\n * Version  : 2.4.20\n * License  : MIT\n * Copyright: 2020 Naotoshi Fujita\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(self, function() {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 311:\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": () => /* binding */ module_Splide\n});\n\n// NAMESPACE OBJECT: ./src/js/constants/states.js\nvar states_namespaceObject = {};\n__webpack_require__.r(states_namespaceObject);\n__webpack_require__.d(states_namespaceObject, {\n  \"CREATED\": () => CREATED,\n  \"DESTROYED\": () => DESTROYED,\n  \"IDLE\": () => IDLE,\n  \"MOUNTED\": () => MOUNTED,\n  \"MOVING\": () => MOVING\n});\n\n;// CONCATENATED MODULE: ./src/js/core/event.js\n/**\r\n * The function for providing an Event object simply managing events.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The function for providing an Event object simply managing events.\r\n */\n/* harmony default export */ const core_event = (function () {\n  /**\r\n   * Store all event data.\r\n   *\r\n   * @type {Array}\r\n   */\n  var data = [];\n  var Event = {\n    /**\r\n     * Subscribe the given event(s).\r\n     *\r\n     * @param {string}   events  - An event name. Use space to separate multiple events.\r\n     *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n     * @param {function} handler - A callback function.\r\n     * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n     * @param {Object}   options - Optional. Options for addEventListener.\r\n     */\n    on: function on(events, handler, elm, options) {\n      if (elm === void 0) {\n        elm = null;\n      }\n\n      if (options === void 0) {\n        options = {};\n      }\n\n      events.split(' ').forEach(function (event) {\n        if (elm) {\n          elm.addEventListener(event, handler, options);\n        }\n\n        data.push({\n          event: event,\n          handler: handler,\n          elm: elm,\n          options: options\n        });\n      });\n    },\n\n    /**\r\n     * Unsubscribe the given event(s).\r\n     *\r\n     * @param {string}  events - A event name or names split by space.\r\n     * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n     */\n    off: function off(events, elm) {\n      if (elm === void 0) {\n        elm = null;\n      }\n\n      events.split(' ').forEach(function (event) {\n        data = data.filter(function (item) {\n          if (item && item.event === event && item.elm === elm) {\n            unsubscribe(item);\n            return false;\n          }\n\n          return true;\n        });\n      });\n    },\n\n    /**\r\n     * Emit an event.\r\n     * This method is only for custom events.\r\n     *\r\n     * @param {string}  event - An event name.\r\n     * @param {*}       args  - Any number of arguments passed to handlers.\r\n     */\n    emit: function emit(event) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      data.forEach(function (item) {\n        if (!item.elm && item.event.split('.')[0] === event) {\n          item.handler.apply(item, args);\n        }\n      });\n    },\n\n    /**\r\n     * Clear event data.\r\n     */\n    destroy: function destroy() {\n      data.forEach(unsubscribe);\n      data = [];\n    }\n  };\n  /**\r\n   * Remove the registered event listener.\r\n   *\r\n   * @param {Object} item - An object containing event data.\r\n   */\n\n  function unsubscribe(item) {\n    if (item.elm) {\n      item.elm.removeEventListener(item.event, item.handler, item.options);\n    }\n  }\n\n  return Event;\n});\n;// CONCATENATED MODULE: ./src/js/core/state.js\n/**\r\n * The function providing a super simple state system.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The function providing a super simple state system.\r\n *\r\n * @param {string|number} initialState - Provide the initial state value.\r\n */\n/* harmony default export */ const state = (function (initialState) {\n  /**\r\n   * Store the current state.\r\n   *\r\n   * @type {string|number}\r\n   */\n  var curr = initialState;\n  return {\n    /**\r\n     * Change state.\r\n     *\r\n     * @param {string|number} state - A new state.\r\n     */\n    set: function set(state) {\n      curr = state;\n    },\n\n    /**\r\n     * Verify if the current state is given one or not.\r\n     *\r\n     * @param {string|number} state - A state name to be verified.\r\n     *\r\n     * @return {boolean} - True if the current state is the given one.\r\n     */\n    is: function is(state) {\n      return state === curr;\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/utils/object.js\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n/**\r\n * Some utility functions related with Object, supporting IE.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\nvar keys = Object.keys;\n/**\r\n * Iterate an object like Array.forEach.\r\n * IE doesn't support forEach of HTMLCollection.\r\n *\r\n * @param {Object}    obj       - An object.\r\n * @param {function}  callback  - A function handling each value. Arguments are value, property and index.\r\n */\n\nfunction each(obj, callback) {\n  keys(obj).some(function (key, index) {\n    return callback(obj[key], key, index);\n  });\n}\n/**\r\n * Return values of the given object as an array.\r\n * IE doesn't support Object.values.\r\n *\r\n * @param {Object} obj - An object.\r\n *\r\n * @return {Array} - An array containing all values of the given object.\r\n */\n\nfunction values(obj) {\n  return keys(obj).map(function (key) {\n    return obj[key];\n  });\n}\n/**\r\n * Check if the given subject is object or not.\r\n *\r\n * @param {*} subject - A subject to be verified.\r\n *\r\n * @return {boolean} - True if object, false otherwise.\r\n */\n\nfunction isObject(subject) {\n  return typeof subject === 'object';\n}\n/**\r\n * Merge two objects deeply.\r\n *\r\n * @param {Object} to   - An object where \"from\" is merged.\r\n * @param {Object} from - An object merged to \"to\".\r\n *\r\n * @return {Object} - A merged object.\r\n */\n\nfunction merge(_ref, from) {\n  var to = _extends({}, _ref);\n\n  each(from, function (value, key) {\n    if (isObject(value)) {\n      if (!isObject(to[key])) {\n        to[key] = {};\n      }\n\n      to[key] = merge(to[key], value);\n    } else {\n      to[key] = value;\n    }\n  });\n  return to;\n}\n/**\r\n * Assign all properties \"from\" to \"to\" object.\r\n *\r\n * @param {Object} to   - An object where properties are assigned.\r\n * @param {Object} from - An object whose properties are assigned to \"to\".\r\n *\r\n * @return {Object} - An assigned object.\r\n */\n\nfunction object_assign(to, from) {\n  keys(from).forEach(function (key) {\n    if (!to[key]) {\n      Object.defineProperty(to, key, Object.getOwnPropertyDescriptor(from, key));\n    }\n  });\n  return to;\n}\n;// CONCATENATED MODULE: ./src/js/utils/utils.js\n/**\r\n * A package of some miscellaneous utility functions.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Convert the given value to array.\r\n *\r\n * @param {*} value - Any value.\r\n *\r\n * @return {*[]} - Array containing the given value.\r\n */\n\nfunction toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n/**\r\n * Check if the given value is between min and max.\r\n * Min will be returned when the value is less than min or max will do when greater than max.\r\n *\r\n * @param {number} value - A number to be checked.\r\n * @param {number} m1    - Minimum or maximum number.\r\n * @param {number} m2    - Maximum or minimum number.\r\n *\r\n * @return {number} - A value itself, min or max.\r\n */\n\nfunction between(value, m1, m2) {\n  return Math.min(Math.max(value, m1 > m2 ? m2 : m1), m1 > m2 ? m1 : m2);\n}\n/**\r\n * The sprintf method with minimum functionality.\r\n *\r\n * @param {string}       format       - The string format.\r\n * @param {string|Array} replacements - Replacements accepting multiple arguments.\r\n *\r\n * @returns {string} - Converted string.\r\n */\n\nfunction sprintf(format, replacements) {\n  var i = 0;\n  return format.replace(/%s/g, function () {\n    return toArray(replacements)[i++];\n  });\n}\n/**\r\n * Append px unit to the given subject if necessary.\r\n *\r\n * @param {number|string} value - A value that may not include an unit.\r\n *\r\n * @return {string} - If the value is string, return itself.\r\n *                    If number, do value + \"px\". An empty string, otherwise.\r\n */\n\nfunction unit(value) {\n  var type = typeof value;\n\n  if (type === 'number' && value > 0) {\n    return parseFloat(value) + 'px';\n  }\n\n  return type === 'string' ? value : '';\n}\n/**\r\n * Pad start with 0.\r\n *\r\n * @param {number} number - A number to be filled with 0.\r\n *\r\n * @return {string|number} - Padded number.\r\n */\n\nfunction pad(number) {\n  return number < 10 ? '0' + number : number;\n}\n/**\r\n * Convert the given value to pixel.\r\n *\r\n * @param {Element}       root  - Root element where a dummy div is appended.\r\n * @param {string|number} value - CSS value to be converted, such as 10rem.\r\n *\r\n * @return {number} - Pixel.\r\n */\n\nfunction toPixel(root, value) {\n  if (typeof value === 'string') {\n    var div = create('div', {});\n    applyStyle(div, {\n      position: 'absolute',\n      width: value\n    });\n    append(root, div);\n    value = div.clientWidth;\n    dom_remove(div);\n  }\n\n  return +value || 0;\n}\n;// CONCATENATED MODULE: ./src/js/utils/dom.js\n/**\r\n * Some utility functions related with DOM.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Find the first element matching the given selector.\r\n * Be aware that all selectors after a space are ignored.\r\n *\r\n * @param {Element|Node}  elm       - An ancestor element.\r\n * @param {string}        selector  - DOMString.\r\n *\r\n * @return {Element|null} - A found element or null.\r\n */\n\nfunction find(elm, selector) {\n  return elm ? elm.querySelector(selector.split(' ')[0]) : null;\n}\n/**\r\n * Find a first child having the given tag or class name.\r\n *\r\n * @param {Element} parent         - A parent element.\r\n * @param {string}  tagOrClassName - A tag or class name.\r\n *\r\n * @return {Element|undefined} - A found element on success or undefined on failure.\r\n */\n\nfunction child(parent, tagOrClassName) {\n  return children(parent, tagOrClassName)[0];\n}\n/**\r\n * Return chile elements that matches the provided tag or class name.\r\n *\r\n * @param {Element} parent         - A parent element.\r\n * @param {string}  tagOrClassName - A tag or class name.\r\n *\r\n * @return {Element[]} - Found elements.\r\n */\n\nfunction children(parent, tagOrClassName) {\n  if (parent) {\n    return values(parent.children).filter(function (child) {\n      return hasClass(child, tagOrClassName.split(' ')[0]) || child.tagName === tagOrClassName;\n    });\n  }\n\n  return [];\n}\n/**\r\n * Create an element with some optional attributes.\r\n *\r\n * @param {string} tag   - A tag name.\r\n * @param {Object} attrs - An object any attribute pairs of name and value.\r\n *\r\n * @return {Element} - A created element.\r\n */\n\nfunction create(tag, attrs) {\n  var elm = document.createElement(tag);\n  each(attrs, function (value, key) {\n    return setAttribute(elm, key, value);\n  });\n  return elm;\n}\n/**\r\n * Convert HTML string to DOM node.\r\n *\r\n * @param {string} html - HTML string.\r\n *\r\n * @return {Node} - A created node.\r\n */\n\nfunction domify(html) {\n  var div = create('div', {});\n  div.innerHTML = html;\n  return div.firstChild;\n}\n/**\r\n * Remove a given element from a DOM tree.\r\n *\r\n * @param {Element|Element[]} elms - Element(s) to be removed.\r\n */\n\nfunction dom_remove(elms) {\n  toArray(elms).forEach(function (elm) {\n    if (elm) {\n      var parent = elm.parentElement;\n      parent && parent.removeChild(elm);\n    }\n  });\n}\n/**\r\n * Append a child to a given element.\r\n *\r\n * @param {Element} parent - A parent element.\r\n * @param {Element} child  - An element to be appended.\r\n */\n\nfunction append(parent, child) {\n  if (parent) {\n    parent.appendChild(child);\n  }\n}\n/**\r\n * Insert an element before the reference element.\r\n *\r\n * @param {Element|Node} ref - A reference element.\r\n * @param {Element}      elm - An element to be inserted.\r\n */\n\nfunction before(elm, ref) {\n  if (elm && ref) {\n    var parent = ref.parentElement;\n    parent && parent.insertBefore(elm, ref);\n  }\n}\n/**\r\n * Apply styles to the given element.\r\n *\r\n * @param {Element} elm     - An element where styles are applied.\r\n * @param {Object}  styles  - Object containing styles.\r\n */\n\nfunction applyStyle(elm, styles) {\n  if (elm) {\n    each(styles, function (value, prop) {\n      if (value !== null) {\n        elm.style[prop] = value;\n      }\n    });\n  }\n}\n/**\r\n * Add or remove classes to/from the element.\r\n * This function is for internal usage.\r\n *\r\n * @param {Element}         elm     - An element where classes are added.\r\n * @param {string|string[]} classes - Class names being added.\r\n * @param {boolean}         remove  - Whether to remove or add classes.\r\n */\n\nfunction addOrRemoveClasses(elm, classes, remove) {\n  if (elm) {\n    toArray(classes).forEach(function (name) {\n      if (name) {\n        elm.classList[remove ? 'remove' : 'add'](name);\n      }\n    });\n  }\n}\n/**\r\n * Add classes to the element.\r\n *\r\n * @param {Element}          elm     - An element where classes are added.\r\n * @param {string|string[]}  classes - Class names being added.\r\n */\n\n\nfunction addClass(elm, classes) {\n  addOrRemoveClasses(elm, classes, false);\n}\n/**\r\n * Remove a class from the element.\r\n *\r\n * @param {Element}         elm     - An element where classes are removed.\r\n * @param {string|string[]} classes - A class name being removed.\r\n */\n\nfunction removeClass(elm, classes) {\n  addOrRemoveClasses(elm, classes, true);\n}\n/**\r\n * Verify if the provided element has the class or not.\r\n *\r\n * @param {Element} elm       - An element.\r\n * @param {string}  className - A class name.\r\n *\r\n * @return {boolean} - True if the element has the class or false if not.\r\n */\n\nfunction hasClass(elm, className) {\n  return !!elm && elm.classList.contains(className);\n}\n/**\r\n * Set attribute to the given element.\r\n *\r\n * @param {Element}                 elm   - An element where an attribute is assigned.\r\n * @param {string}                  name  - Attribute name.\r\n * @param {string|number|boolean}   value - Attribute value.\r\n */\n\nfunction setAttribute(elm, name, value) {\n  if (elm) {\n    elm.setAttribute(name, value);\n  }\n}\n/**\r\n * Get attribute from the given element.\r\n *\r\n * @param {Element} elm  - An element where an attribute is assigned.\r\n * @param {string}  name - Attribute name.\r\n *\r\n * @return {string} - The value of the given attribute if available. An empty string if not.\r\n */\n\nfunction getAttribute(elm, name) {\n  return elm ? elm.getAttribute(name) : '';\n}\n/**\r\n * Remove attribute from the given element.\r\n *\r\n * @param {Element|Element[]} elms  - An element where an attribute is removed.\r\n * @param {string|string[]}      names - Attribute name.\r\n */\n\nfunction removeAttribute(elms, names) {\n  toArray(names).forEach(function (name) {\n    toArray(elms).forEach(function (elm) {\n      return elm && elm.removeAttribute(name);\n    });\n  });\n}\n/**\r\n * Return the Rect object of the provided object.\r\n *\r\n * @param {Element} elm - An element.\r\n *\r\n * @return {ClientRect|DOMRect} - A rect object.\r\n */\n\nfunction getRect(elm) {\n  return elm.getBoundingClientRect();\n}\n/**\r\n * Trigger the given callback after all images contained by the element are loaded.\r\n *\r\n * @param {Element}  elm      - Element that may contain images.\r\n * @param {Function} callback - Callback function fired right after all images are loaded.\r\n */\n\nfunction loaded(elm, callback) {\n  var images = elm.querySelectorAll('img');\n  var length = images.length;\n\n  if (length) {\n    var count = 0;\n    each(images, function (img) {\n      img.onload = img.onerror = function () {\n        if (++count === length) {\n          callback();\n        }\n      };\n    });\n  } else {\n    // Trigger the callback immediately if there is no image.\n    callback();\n  }\n}\n;// CONCATENATED MODULE: ./src/js/constants/types.js\n/**\r\n * Export slider types.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Normal slider.\r\n *\r\n * @type {string}\r\n */\nvar SLIDE = 'slide';\n/**\r\n * Loop after the last slide and before the first one.\r\n *\r\n * @type {string}\r\n */\n\nvar LOOP = 'loop';\n/**\r\n * The track doesn't move.\r\n *\r\n * @type {string}\r\n */\n\nvar FADE = 'fade';\n;// CONCATENATED MODULE: ./src/js/transitions/slide/index.js\n/**\r\n * The component for general slide effect transition.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The component for general slide effect transition.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const slide = (function (Splide, Components) {\n  /**\r\n   * Hold the list element.\r\n   *\r\n   * @type {Element}\r\n   */\n  var list;\n  /**\r\n   * Hold the onEnd callback function.\r\n   *\r\n   * @type {function}\r\n   */\n\n  var endCallback;\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      list = Components.Elements.list;\n      Splide.on('transitionend', function (e) {\n        if (e.target === list && endCallback) {\n          endCallback();\n        }\n      }, list);\n    },\n\n    /**\r\n     * Start transition.\r\n     *\r\n     * @param {number}   destIndex - Destination slide index that might be clone's.\r\n     * @param {number}   newIndex  - New index.\r\n     * @param {number}   prevIndex - Previous index.\r\n     * @param {Object}   coord     - Destination coordinates.\r\n     * @param {function} done      - Callback function must be invoked when transition is completed.\r\n     */\n    start: function start(destIndex, newIndex, prevIndex, coord, done) {\n      var options = Splide.options;\n      var edgeIndex = Components.Controller.edgeIndex;\n      var speed = options.speed;\n      endCallback = done;\n\n      if (Splide.is(SLIDE)) {\n        if (prevIndex === 0 && newIndex >= edgeIndex || prevIndex >= edgeIndex && newIndex === 0) {\n          speed = options.rewindSpeed || speed;\n        }\n      }\n\n      applyStyle(list, {\n        transition: \"transform \" + speed + \"ms \" + options.easing,\n        transform: \"translate(\" + coord.x + \"px,\" + coord.y + \"px)\"\n      });\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/transitions/fade/index.js\n/**\r\n * The component for fade transition.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The component for fade transition.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const fade = (function (Splide, Components) {\n  var Fade = {\n    /**\r\n     * Called when the component is mounted.\r\n     * Apply transition style to the first slide.\r\n     */\n    mount: function mount() {\n      apply(Splide.index);\n    },\n\n    /**\r\n     * Start transition.\r\n     *\r\n     * @param {number}    destIndex - Destination slide index that might be clone's.\r\n     * @param {number}    newIndex  - New index.\r\n     * @param {number}    prevIndex - Previous index.\r\n     * @param {Object}    coord     - Destination coordinates.\r\n     * @param {function}  done      - Callback function must be invoked when transition is completed.\r\n     */\n    start: function start(destIndex, newIndex, prevIndex, coord, done) {\n      var track = Components.Elements.track;\n      applyStyle(track, {\n        height: unit(track.clientHeight)\n      });\n      apply(newIndex);\n      setTimeout(function () {\n        done();\n        applyStyle(track, {\n          height: ''\n        });\n      });\n    }\n  };\n  /**\r\n   * Apply transition style to the slide specified by the given index.\r\n   *\r\n   * @param {number} index - A slide index.\r\n   */\n\n  function apply(index) {\n    var options = Splide.options;\n    applyStyle(Components.Elements.slides[index], {\n      transition: \"opacity \" + options.speed + \"ms \" + options.easing\n    });\n  }\n\n  return Fade;\n});\n;// CONCATENATED MODULE: ./src/js/transitions/index.js\n/**\r\n * Export transition components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n;// CONCATENATED MODULE: ./src/js/core/composer.js\n/**\r\n * Provide a function for composing components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * Compose components.\r\n *\r\n * @param {Splide}   Splide     - Splide instance.\r\n * @param {Object}   Components - Additional components.\r\n * @param {function} Transition - Change component for transition.\r\n *\r\n * @return {Object} - An object containing all components.\r\n */\n\nfunction compose(Splide, Components, Transition) {\n  var components = {};\n  each(Components, function (Component, name) {\n    components[name] = Component(Splide, components, name.toLowerCase());\n  });\n\n  if (!Transition) {\n    Transition = Splide.is(FADE) ? fade : slide;\n  }\n\n  components.Transition = Transition(Splide, components);\n  return components;\n}\n;// CONCATENATED MODULE: ./src/js/utils/error.js\n/**\r\n * Utility functions for outputting logs.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Prefix of an error massage.\r\n *\r\n * @type {string}\r\n */\nvar MESSAGE_PREFIX = '[SPLIDE]';\n/**\r\n * Display an error message on the browser console.\r\n *\r\n * @param {string} message - An error message.\r\n */\n\nfunction error(message) {\n  console.error(MESSAGE_PREFIX + \" \" + message);\n}\n/**\r\n * Check existence of the given object and throw an error if it doesn't.\r\n *\r\n * @throws {Error}\r\n *\r\n * @param {*}      subject - A subject to be confirmed.\r\n * @param {string} message - An error message.\r\n */\n\nfunction exist(subject, message) {\n  if (!subject) {\n    throw new Error(message);\n  }\n}\n;// CONCATENATED MODULE: ./src/js/constants/classes.js\n/**\r\n * Export class names.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * A root class name.\r\n *\r\n * @type {string}\r\n */\nvar ROOT = 'splide';\n/**\r\n * The definition table of all classes for elements.\r\n * They might be modified by options.\r\n *\r\n * @type {Object}\r\n */\n\nvar ELEMENT_CLASSES = {\n  root: ROOT,\n  slider: ROOT + \"__slider\",\n  track: ROOT + \"__track\",\n  list: ROOT + \"__list\",\n  slide: ROOT + \"__slide\",\n  container: ROOT + \"__slide__container\",\n  arrows: ROOT + \"__arrows\",\n  arrow: ROOT + \"__arrow\",\n  prev: ROOT + \"__arrow--prev\",\n  next: ROOT + \"__arrow--next\",\n  pagination: ROOT + \"__pagination\",\n  page: ROOT + \"__pagination__page\",\n  clone: ROOT + \"__slide--clone\",\n  progress: ROOT + \"__progress\",\n  bar: ROOT + \"__progress__bar\",\n  autoplay: ROOT + \"__autoplay\",\n  play: ROOT + \"__play\",\n  pause: ROOT + \"__pause\",\n  spinner: ROOT + \"__spinner\",\n  sr: ROOT + \"__sr\"\n};\n/**\r\n * Definitions of status classes.\r\n *\r\n * @type {Object}\r\n */\n\nvar STATUS_CLASSES = {\n  active: 'is-active',\n  visible: 'is-visible',\n  loading: 'is-loading'\n};\n;// CONCATENATED MODULE: ./src/js/constants/i18n.js\n/**\r\n * Export i18n texts as object.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Texts for i18n.\r\n *\r\n * @type {Object}\r\n */\nvar I18N = {\n  prev: 'Previous slide',\n  next: 'Next slide',\n  first: 'Go to first slide',\n  last: 'Go to last slide',\n  slideX: 'Go to slide %s',\n  pageX: 'Go to page %s',\n  play: 'Start autoplay',\n  pause: 'Pause autoplay'\n};\n;// CONCATENATED MODULE: ./src/js/constants/defaults.js\n/**\r\n * Export default options.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\nvar DEFAULTS = {\n  /**\r\n   * Determine a slider type.\r\n   * - 'slide': Regular slider.\r\n   * - 'loop' : Carousel slider.\r\n   * - 'fade' : Change slides with fade transition. perPage, drag options are ignored.\r\n   *\r\n   * @type {string}\r\n   */\n  type: 'slide',\n\n  /**\r\n   * Whether to rewind a slider before the first slide or after the last one.\r\n   * In \"loop\" mode, this option is ignored.\r\n   *\r\n   * @type {boolean}\r\n   */\n  rewind: false,\n\n  /**\r\n   * Transition speed in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  speed: 400,\n\n  /**\r\n   * Transition speed on rewind in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  rewindSpeed: 0,\n\n  /**\r\n   * Whether to prevent any actions while a slider is transitioning.\r\n   * If false, navigation, drag and swipe work while the slider is running.\r\n   * Even so, it will be forced to wait for transition in some cases in the loop mode to shift a slider.\r\n   *\r\n   * @type {boolean}\r\n   */\n  waitForTransition: true,\n\n  /**\r\n   * Define slider max width.\r\n   *\r\n   * @type {number}\r\n   */\n  width: 0,\n\n  /**\r\n   * Define slider height.\r\n   *\r\n   * @type {number}\r\n   */\n  height: 0,\n\n  /**\r\n   * Fix width of slides. CSS format is allowed such as 10em, 80% or 80vw.\r\n   * perPage number will be ignored when this option is falsy.\r\n   *\r\n   * @type {number|string}\r\n   */\n  fixedWidth: 0,\n\n  /**\r\n   * Fix height of slides. CSS format is allowed such as 10em, 80vh but % unit is not accepted.\r\n   * heightRatio option will be ignored when this option is falsy.\r\n   *\r\n   * @type {number|string}\r\n   */\n  fixedHeight: 0,\n\n  /**\r\n   * Determine height of slides by ratio to a slider width.\r\n   * This will be ignored when the fixedHeight is provided.\r\n   *\r\n   * @type {number}\r\n   */\n  heightRatio: 0,\n\n  /**\r\n   * If true, slide width will be determined by the element width itself.\r\n   * - perPage/perMove should be 1.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoWidth: false,\n\n  /**\r\n   * If true, slide height will be determined by the element width itself.\r\n   * - perPage/perMove should be 1.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoHeight: false,\n\n  /**\r\n   * Determine how many slides should be displayed per page.\r\n   *\r\n   * @type {number}\r\n   */\n  perPage: 1,\n\n  /**\r\n   * Determine how many slides should be moved when a slider goes to next or perv.\r\n   *\r\n   * @type {number}\r\n   */\n  perMove: 0,\n\n  /**\r\n   * Determine manually how many clones should be generated on the left and right side.\r\n   * The total number of clones will be twice of this number.\r\n   *\r\n   * @type {number}\r\n   */\n  clones: 0,\n\n  /**\r\n   * Start index.\r\n   *\r\n   * @type {number}\r\n   */\n  start: 0,\n\n  /**\r\n   * Determine which slide should be focused if there are multiple slides in a page.\r\n   * A string \"center\" is acceptable for centering slides.\r\n   *\r\n   * @type {boolean|number|string}\r\n   */\n  focus: false,\n\n  /**\r\n   * Gap between slides. CSS format is allowed such as 1em.\r\n   *\r\n   * @type {number|string}\r\n   */\n  gap: 0,\n\n  /**\r\n   * Set padding-left/right in horizontal mode or padding-top/bottom in vertical one.\r\n   * Give a single value to set a same size for both sides or\r\n   * do an object for different sizes.\r\n   * Also, CSS format is allowed such as 1em.\r\n   *\r\n   * @example\r\n   * - 10: Number\r\n   * - '1em': CSS format.\r\n   * - { left: 0, right: 20 }: Object for different sizes in horizontal mode.\r\n   * - { top: 0, bottom: 20 }: Object for different sizes in vertical mode.\r\n   *\r\n   * @type {number|string|Object}\r\n   */\n  padding: 0,\n\n  /**\r\n   * Whether to append arrows.\r\n   *\r\n   * @type {boolean}\r\n   */\n  arrows: true,\n\n  /**\r\n   * Change the arrow SVG path like 'm7.61 0.807-2.12...'.\r\n   *\r\n   * @type {string}\r\n   */\n  arrowPath: '',\n\n  /**\r\n   * Whether to append pagination(indicator dots) or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pagination: true,\n\n  /**\r\n   * Activate autoplay.\r\n   *\r\n   * @type {boolean}\r\n   */\n  autoplay: false,\n\n  /**\r\n   * Autoplay interval in milliseconds.\r\n   *\r\n   * @type {number}\r\n   */\n  interval: 5000,\n\n  /**\r\n   * Whether to stop autoplay when a slider is hovered.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pauseOnHover: true,\n\n  /**\r\n   * Whether to stop autoplay when a slider elements are focused.\r\n   * True is recommended for accessibility.\r\n   *\r\n   * @type {boolean}\r\n   */\n  pauseOnFocus: true,\n\n  /**\r\n   * Whether to reset progress of the autoplay timer when resumed.\r\n   *\r\n   * @type {boolean}\r\n   */\n  resetProgress: true,\n\n  /**\r\n   * Loading images lazily.\r\n   * Image src must be provided by a data-splide-lazy attribute.\r\n   *\r\n   * - false: Do nothing.\r\n   * - 'nearby': Only images around an active slide will be loaded.\r\n   * - 'sequential': All images will be sequentially loaded.\r\n   *\r\n   * @type {boolean|string}\r\n   */\n  lazyLoad: false,\n\n  /**\r\n   * This option works only when a lazyLoad option is \"nearby\".\r\n   * Determine how many pages(not slides) around an active slide should be loaded beforehand.\r\n   *\r\n   * @type {number}\r\n   */\n  preloadPages: 1,\n\n  /**\r\n   * Easing for CSS transition. For example, linear, ease or cubic-bezier().\r\n   *\r\n   * @type {string}\r\n   */\n  easing: 'cubic-bezier(.42,.65,.27,.99)',\n\n  /**\r\n   * Whether to enable keyboard shortcuts\r\n   * - true or 'global': Listen to keydown event of the document.\r\n   * - 'focused': Listen to the keydown event of the slider root element. tabindex=\"0\" will be added to the element.\r\n   * - false: Disable keyboard shortcuts.\r\n   *\r\n   * @type {boolean|string}\r\n   */\n  keyboard: 'global',\n\n  /**\r\n   * Whether to allow mouse drag and touch swipe.\r\n   *\r\n   * @type {boolean}\r\n   */\n  drag: true,\n\n  /**\r\n   * The angle threshold for drag.\r\n   * The slider starts moving only when the drag angle is less than this threshold.\r\n   *\r\n   * @type {number}\r\n   */\n  dragAngleThreshold: 30,\n\n  /**\r\n   * Distance threshold for determining if the action is \"flick\" or \"swipe\".\r\n   * When a drag distance is over this value, the action will be treated as \"swipe\", not \"flick\".\r\n   *\r\n   * @type {number}\r\n   */\n  swipeDistanceThreshold: 150,\n\n  /**\r\n   * Velocity threshold for determining if the action is \"flick\" or \"swipe\".\r\n   * Around 0.5 is recommended.\r\n   *\r\n   * @type {number}\r\n   */\n  flickVelocityThreshold: .6,\n\n  /**\r\n   * Determine power of flick. The larger number this is, the farther a slider runs by flick.\r\n   * Around 500 is recommended.\r\n   *\r\n   * @type {number}\r\n   */\n  flickPower: 600,\n\n  /**\r\n   * Limit a number of pages to move by flick.\r\n   *\r\n   * @type {number}\r\n   */\n  flickMaxPages: 1,\n\n  /**\r\n   * Slider direction.\r\n   * - 'ltr': Left to right.\r\n   * - 'rtl': Right to left.\r\n   * - 'ttb': Top to bottom.\r\n   *\r\n   * @type {string}\r\n   */\n  direction: 'ltr',\n\n  /**\r\n   * Set img src to background-image of its parent element.\r\n   * Images with various sizes can be displayed as same dimension without cropping work.\r\n   * fixedHeight or heightRatio is required.\r\n   *\r\n   * @type {boolean}\r\n   */\n  cover: false,\n\n  /**\r\n   * Whether to enable accessibility(aria and screen reader texts) or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  accessibility: true,\n\n  /**\r\n   * Whether to add tabindex=\"0\" to visible slides or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  slideFocus: true,\n\n  /**\r\n   * Determine if a slider is navigation for another.\r\n   * Use \"sync\" API to synchronize two sliders.\r\n   *\r\n   * @type {boolean}\r\n   */\n  isNavigation: false,\n\n  /**\r\n   * Whether to trim spaces before the fist slide or after the last one when \"focus\" is not 0.\r\n   *\r\n   * @type {boolean}\r\n   */\n  trimSpace: true,\n\n  /**\r\n   * The \"is-active\" class is added after transition as default.\r\n   * If true, it will be added before move.\r\n   *\r\n   * @type {boolean}\r\n   */\n  updateOnMove: false,\n\n  /**\r\n   * Throttle duration in milliseconds for the resize event.\r\n   *\r\n   * @type {number}\r\n   */\n  throttle: 100,\n\n  /**\r\n   * Whether to destroy a slider or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  destroy: false,\n\n  /**\r\n   * Options for specific breakpoints.\r\n   *\r\n   * @example\r\n   * {\r\n   *   1000: {\r\n   *     perPage: 3,\r\n   *     gap: 20\r\n   *   },\r\n   *   600: {\r\n   *     perPage: 1,\r\n   *     gap: 5,\r\n   *   }\r\n   * }\r\n   *\r\n   * @type {boolean|Object}\r\n   */\n  breakpoints: false,\n\n  /**\r\n   * Collection of class names.\r\n   *\r\n   * @see ./classes.js\r\n   *\r\n   * @type {Object}\r\n   */\n  classes: ELEMENT_CLASSES,\n\n  /**\r\n   * Collection of i18n texts.\r\n   *\r\n   * @see ./i18n.js\r\n   *\r\n   * @type {Object}\r\n   */\n  i18n: I18N\n};\n;// CONCATENATED MODULE: ./src/js/constants/states.js\n/**\r\n * Export state constants.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Splide has been just created.\r\n *\r\n * @type {number}\r\n */\nvar CREATED = 1;\n/**\r\n * All components have been mounted and initialized.\r\n *\r\n * @type {number}\r\n */\n\nvar MOUNTED = 2;\n/**\r\n * Splide is ready for transition.\r\n *\r\n * @type {number}\r\n */\n\nvar IDLE = 3;\n/**\r\n * Splide is moving.\r\n *\r\n * @type {number}\r\n */\n\nvar MOVING = 4;\n/**\r\n * Splide is moving.\r\n *\r\n * @type {number}\r\n */\n\nvar DESTROYED = 5;\n;// CONCATENATED MODULE: ./src/js/splide.js\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/**\r\n * The main class for applying Splide to an element.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n\n/**\r\n * The main class for applying Splide to an element,\r\n * providing some APIs to control the behavior.\r\n */\n\nvar Splide = /*#__PURE__*/function () {\n  /**\r\n   * Splide constructor.\r\n   *\r\n   * @throws {Error} When the given root element or selector is invalid.\r\n   *\r\n   * @param {Element|string}  root       - A selector for a root element or an element itself.\r\n   * @param {Object}          options    - Optional. Options to change default behaviour.\r\n   * @param {Object}          Components - Optional. Components.\r\n   */\n  function Splide(root, options, Components) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (Components === void 0) {\n      Components = {};\n    }\n\n    this.root = root instanceof Element ? root : document.querySelector(root);\n    exist(this.root, 'An invalid element/selector was given.');\n    this.Components = null;\n    this.Event = core_event();\n    this.State = state(CREATED);\n    this.STATES = states_namespaceObject;\n    this._o = merge(DEFAULTS, options);\n    this._i = 0;\n    this._c = Components;\n    this._e = {}; // Extensions\n\n    this._t = null; // Transition\n  }\n  /**\r\n   * Compose and mount components.\r\n   *\r\n   * @param {Object}   Extensions - Optional. Additional components.\r\n   * @param {function} Transition - Optional. Set a custom transition component.\r\n   *\r\n   * @return {Splide|undefined} - This instance or undefined if an exception occurred.\r\n   */\n\n\n  var _proto = Splide.prototype;\n\n  _proto.mount = function mount(Extensions, Transition) {\n    var _this = this;\n\n    if (Extensions === void 0) {\n      Extensions = this._e;\n    }\n\n    if (Transition === void 0) {\n      Transition = this._t;\n    }\n\n    // Reset the state.\n    this.State.set(CREATED);\n    this._e = Extensions;\n    this._t = Transition;\n    this.Components = compose(this, merge(this._c, Extensions), Transition);\n\n    try {\n      each(this.Components, function (component, key) {\n        var required = component.required;\n\n        if (required === undefined || required) {\n          component.mount && component.mount();\n        } else {\n          delete _this.Components[key];\n        }\n      });\n    } catch (e) {\n      error(e.message);\n      return;\n    }\n\n    var State = this.State;\n    State.set(MOUNTED);\n    each(this.Components, function (component) {\n      component.mounted && component.mounted();\n    });\n    this.emit('mounted');\n    State.set(IDLE);\n    this.emit('ready');\n    applyStyle(this.root, {\n      visibility: 'visible'\n    });\n    this.on('move drag', function () {\n      return State.set(MOVING);\n    }).on('moved dragged', function () {\n      return State.set(IDLE);\n    });\n    return this;\n  }\n  /**\r\n   * Set sync target.\r\n   *\r\n   * @param {Splide} splide - A Splide instance.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.sync = function sync(splide) {\n    this.sibling = splide;\n    return this;\n  }\n  /**\r\n   * Register callback fired on the given event(s).\r\n   *\r\n   * @param {string}   events  - An event name. Use space to separate multiple events.\r\n   *                             Also, namespace is accepted by dot, such as 'resize.{namespace}'.\r\n   * @param {function} handler - A callback function.\r\n   * @param {Element}  elm     - Optional. Native event will be listened to when this arg is provided.\r\n   * @param {Object}   options - Optional. Options for addEventListener.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.on = function on(events, handler, elm, options) {\n    if (elm === void 0) {\n      elm = null;\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.Event.on(events, handler, elm, options);\n    return this;\n  }\n  /**\r\n   * Unsubscribe the given event.\r\n   *\r\n   * @param {string}  events - A event name.\r\n   * @param {Element} elm    - Optional. removeEventListener() will be called when this arg is provided.\r\n   *\r\n   * @return {Splide} - This instance.\r\n   */\n  ;\n\n  _proto.off = function off(events, elm) {\n    if (elm === void 0) {\n      elm = null;\n    }\n\n    this.Event.off(events, elm);\n    return this;\n  }\n  /**\r\n   * Emit an event.\r\n   *\r\n   * @param {string} event - An event name.\r\n   * @param {*}      args  - Any number of arguments passed to handlers.\r\n   */\n  ;\n\n  _proto.emit = function emit(event) {\n    var _this$Event;\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_this$Event = this.Event).emit.apply(_this$Event, [event].concat(args));\n\n    return this;\n  }\n  /**\r\n   * Go to the slide specified by the given control.\r\n   *\r\n   * @param {string|number} control - A control pattern.\r\n   * @param {boolean}       wait    - Optional. Whether to wait for transition.\r\n   */\n  ;\n\n  _proto.go = function go(control, wait) {\n    if (wait === void 0) {\n      wait = this.options.waitForTransition;\n    }\n\n    if (this.State.is(IDLE) || this.State.is(MOVING) && !wait) {\n      this.Components.Controller.go(control, false);\n    }\n\n    return this;\n  }\n  /**\r\n   * Verify whether the slider type is the given one or not.\r\n   *\r\n   * @param {string} type - A slider type.\r\n   *\r\n   * @return {boolean} - True if the slider type is the provided type or false if not.\r\n   */\n  ;\n\n  _proto.is = function is(type) {\n    return type === this._o.type;\n  }\n  /**\r\n   * Insert a slide.\r\n   *\r\n   * @param {Element|string} slide - A slide element to be added.\r\n   * @param {number}         index - A slide will be added at the position.\r\n   */\n  ;\n\n  _proto.add = function add(slide, index) {\n    if (index === void 0) {\n      index = -1;\n    }\n\n    this.Components.Elements.add(slide, index, this.refresh.bind(this));\n    return this;\n  }\n  /**\r\n   * Remove the slide designated by the index.\r\n   *\r\n   * @param {number} index - A slide index.\r\n   */\n  ;\n\n  _proto.remove = function remove(index) {\n    this.Components.Elements.remove(index);\n    this.refresh();\n    return this;\n  }\n  /**\r\n   * Destroy all Slide objects and clones and recreate them again.\r\n   */\n  ;\n\n  _proto.refresh = function refresh() {\n    this.emit('refresh:before').emit('refresh').emit('resize');\n    return this;\n  }\n  /**\r\n   * Destroy the Splide.\r\n   * \"Completely\" boolean is mainly for breakpoints.\r\n   *\r\n   * @param {boolean} completely - Destroy completely.\r\n   */\n  ;\n\n  _proto.destroy = function destroy(completely) {\n    var _this2 = this;\n\n    if (completely === void 0) {\n      completely = true;\n    }\n\n    // Postpone destroy because it should be done after mount.\n    if (this.State.is(CREATED)) {\n      this.on('ready', function () {\n        return _this2.destroy(completely);\n      });\n      return;\n    }\n\n    values(this.Components).reverse().forEach(function (component) {\n      component.destroy && component.destroy(completely);\n    });\n    this.emit('destroy', completely); // Destroy all event handlers, including ones for native events.\n\n    this.Event.destroy();\n    this.State.set(DESTROYED);\n    return this;\n  }\n  /**\r\n   * Return the current slide index.\r\n   *\r\n   * @return {number} - The current slide index.\r\n   // */\n  ;\n\n  _createClass(Splide, [{\n    key: \"index\",\n    get: function get() {\n      return this._i;\n    }\n    /**\r\n     * Set the current slide index.\r\n     *\r\n     * @param {number|string} index - A new index.\r\n     */\n    ,\n    set: function set(index) {\n      this._i = parseInt(index);\n    }\n    /**\r\n     * Return length of slides.\r\n     * This is an alias of Elements.length.\r\n     *\r\n     * @return {number} - A number of slides.\r\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.Components.Elements.length;\n    }\n    /**\r\n     * Return options.\r\n     *\r\n     * @return {Object} - Options object.\r\n     */\n\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this._o;\n    }\n    /**\r\n     * Set options with merging the given object to the current one.\r\n     *\r\n     * @param {Object} options - New options.\r\n     */\n    ,\n    set: function set(options) {\n      var created = this.State.is(CREATED);\n\n      if (!created) {\n        this.emit('update');\n      }\n\n      this._o = merge(this._o, options);\n\n      if (!created) {\n        this.emit('updated', this._o);\n      }\n    }\n    /**\r\n     * Return the class list.\r\n     * This is an alias of Splide.options.classList.\r\n     *\r\n     * @return {Object} - An object containing all class list.\r\n     */\n\n  }, {\n    key: \"classes\",\n    get: function get() {\n      return this._o.classes;\n    }\n    /**\r\n     * Return the i18n strings.\r\n     * This is an alias of Splide.options.i18n.\r\n     *\r\n     * @return {Object} - An object containing all i18n strings.\r\n     */\n\n  }, {\n    key: \"i18n\",\n    get: function get() {\n      return this._o.i18n;\n    }\n  }]);\n\n  return Splide;\n}();\n\n\n;// CONCATENATED MODULE: ./src/js/components/options/index.js\n/**\r\n * The component for initializing options.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for initializing options.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const options = (function (Splide) {\n  /**\r\n   * Retrieve options from the data attribute.\r\n   * Note that IE10 doesn't support dataset property.\r\n   *\r\n   * @type {string}\r\n   */\n  var options = getAttribute(Splide.root, 'data-splide');\n\n  if (options) {\n    try {\n      Splide.options = JSON.parse(options);\n    } catch (e) {\n      error(e.message);\n    }\n  }\n\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      if (Splide.State.is(CREATED)) {\n        Splide.index = Splide.options.start;\n      }\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/constants/directions.js\n/**\r\n * Export layout modes.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Enumerate slides from left to right.\r\n *\r\n * @type {string}\r\n */\nvar LTR = 'ltr';\n/**\r\n * Enumerate slides from right to left.\r\n *\r\n * @type {string}\r\n */\n\nvar RTL = 'rtl';\n/**\r\n * Enumerate slides in a col.\r\n *\r\n * @type {string}\r\n */\n\nvar TTB = 'ttb';\n;// CONCATENATED MODULE: ./src/js/components/elements/slide.js\n/**\r\n * The sub component for handling each slide.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n/**\r\n * Events for restoring original styles.\r\n *\r\n * @type {string}\r\n */\n\nvar STYLE_RESTORE_EVENTS = 'update.slide';\n/**\r\n * The sub component for handling each slide.\r\n *\r\n * @param {Splide}  Splide    - A Splide instance.\r\n * @param {number}  index     - An unique slide index.\r\n * @param {number}  realIndex - Clones should pass a real slide index.\r\n * @param {Element} slide     - A slide element.\r\n *\r\n * @return {Object} - The sub component object.\r\n */\n\n/* harmony default export */ const elements_slide = (function (Splide, index, realIndex, slide) {\n  /**\r\n   * Whether to update \"is-active\" class before or after transition.\r\n   *\r\n   * @type {boolean}\r\n   */\n  var updateOnMove = Splide.options.updateOnMove;\n  /**\r\n   * Events when the slide status is updated.\r\n   * Append a namespace to remove listeners later.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var STATUS_UPDATE_EVENTS = 'ready.slide updated.slide resized.slide moved.slide' + (updateOnMove ? ' move.slide' : '');\n  /**\r\n   * Slide sub component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Slide = {\n    /**\r\n     * Slide element.\r\n     *\r\n     * @type {Element}\r\n     */\n    slide: slide,\n\n    /**\r\n     * Slide index.\r\n     *\r\n     * @type {number}\r\n     */\n    index: index,\n\n    /**\r\n     * Real index for clones.\r\n     *\r\n     * @type {number}\r\n     */\n    realIndex: realIndex,\n\n    /**\r\n     * Container element if available.\r\n     *\r\n     * @type {Element|undefined}\r\n     */\n    container: child(slide, Splide.classes.container),\n\n    /**\r\n     * Whether this is a cloned slide or not.\r\n     *\r\n     * @type {boolean}\r\n     */\n    isClone: realIndex > -1,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      if (!this.isClone) {\n        slide.id = Splide.root.id + \"-slide\" + pad(index + 1);\n      }\n\n      Splide.on(STATUS_UPDATE_EVENTS, function () {\n        return _this.update();\n      }).on(STYLE_RESTORE_EVENTS, restoreStyles).on('click', function () {\n        return Splide.emit('click', _this);\n      }, slide);\n      /*\r\n       * Add \"is-active\" class to a clone element temporarily\r\n       * and it will be removed on \"moved\" event.\r\n       */\n\n      if (updateOnMove) {\n        Splide.on('move.slide', function (newIndex) {\n          if (newIndex === realIndex) {\n            _update(true, false);\n          }\n        });\n      } // Make sure the slide is shown.\n\n\n      applyStyle(slide, {\n        display: ''\n      }); // Hold the original styles.\n\n      this.styles = getAttribute(slide, 'style') || '';\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      Splide.off(STATUS_UPDATE_EVENTS).off(STYLE_RESTORE_EVENTS).off('click', slide);\n      removeClass(slide, values(STATUS_CLASSES));\n      restoreStyles();\n      removeAttribute(this.container, 'style');\n    },\n\n    /**\r\n     * Update active and visible status.\r\n     */\n    update: function update() {\n      _update(this.isActive(), false);\n\n      _update(this.isVisible(), true);\n    },\n\n    /**\r\n     * Check whether this slide is active or not.\r\n     *\r\n     * @return {boolean} - True if the slide is active or false if not.\r\n     */\n    isActive: function isActive() {\n      return Splide.index === index;\n    },\n\n    /**\r\n     * Check whether this slide is visible in the viewport or not.\r\n     *\r\n     * @return {boolean} - True if the slide is visible or false if not.\r\n     */\n    isVisible: function isVisible() {\n      var active = this.isActive();\n\n      if (Splide.is(FADE) || active) {\n        return active;\n      }\n\n      var ceil = Math.ceil;\n      var trackRect = getRect(Splide.Components.Elements.track);\n      var slideRect = getRect(slide);\n\n      if (Splide.options.direction === TTB) {\n        return trackRect.top <= slideRect.top && slideRect.bottom <= ceil(trackRect.bottom);\n      }\n\n      return trackRect.left <= slideRect.left && slideRect.right <= ceil(trackRect.right);\n    },\n\n    /**\r\n     * Calculate how far this slide is from another slide and\r\n     * return true if the distance is within the given number.\r\n     *\r\n     * @param {number} from   - Index of a target slide.\r\n     * @param {number} within - True if the slide is within this number.\r\n     *\r\n     * @return {boolean} - True if the slide is within the number or false otherwise.\r\n     */\n    isWithin: function isWithin(from, within) {\n      var diff = Math.abs(from - index);\n\n      if (!Splide.is(SLIDE) && !this.isClone) {\n        diff = Math.min(diff, Splide.length - diff);\n      }\n\n      return diff < within;\n    }\n  };\n  /**\r\n   * Update classes for activity or visibility.\r\n   *\r\n   * @param {boolean} active        - Is active/visible or not.\r\n   * @param {boolean} forVisibility - Toggle classes for activity or visibility.\r\n   */\n\n  function _update(active, forVisibility) {\n    var type = forVisibility ? 'visible' : 'active';\n    var className = STATUS_CLASSES[type];\n\n    if (active) {\n      addClass(slide, className);\n      Splide.emit(\"\" + type, Slide);\n    } else {\n      if (hasClass(slide, className)) {\n        removeClass(slide, className);\n        Splide.emit(\"\" + (forVisibility ? 'hidden' : 'inactive'), Slide);\n      }\n    }\n  }\n  /**\r\n   * Restore the original styles.\r\n   */\n\n\n  function restoreStyles() {\n    setAttribute(slide, 'style', Slide.styles);\n  }\n\n  return Slide;\n});\n;// CONCATENATED MODULE: ./src/js/components/elements/index.js\n/**\r\n * The component for main elements.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n/**\r\n * The property name for UID stored in a window object.\r\n *\r\n * @type {string}\r\n */\n\nvar UID_NAME = 'uid';\n/**\r\n * The component for main elements.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const components_elements = (function (Splide, Components) {\n  /**\r\n   * Hold the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n  var root = Splide.root;\n  /**\r\n   * Hold the class list.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var classes = Splide.classes;\n  /**\r\n   * Store Slide objects.\r\n   *\r\n   * @type {Array}\r\n   */\n\n  var Slides = [];\n  /*\r\n   * Assign unique ID to the root element if it doesn't have the one.\r\n   * Note that IE doesn't support padStart() to fill the uid by 0.\r\n   */\n\n  if (!root.id) {\n    window.splide = window.splide || {};\n    var uid = window.splide[UID_NAME] || 0;\n    window.splide[UID_NAME] = ++uid;\n    root.id = \"splide\" + pad(uid);\n  }\n  /**\r\n   * Elements component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n\n  var Elements = {\n    /**\r\n     * Called when the component is mounted.\r\n     * Collect main elements and store them as member properties.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      this.init();\n      Splide.on('refresh', function () {\n        _this.destroy();\n\n        _this.init();\n      }).on('updated', function () {\n        removeClass(root, getClasses());\n        addClass(root, getClasses());\n      });\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      Slides.forEach(function (Slide) {\n        Slide.destroy();\n      });\n      Slides = [];\n      removeClass(root, getClasses());\n    },\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      var _this2 = this;\n\n      collect();\n      addClass(root, getClasses());\n      this.slides.forEach(function (slide, index) {\n        _this2.register(slide, index, -1);\n      });\n    },\n\n    /**\r\n     * Register a slide to create a Slide object and handle its behavior.\r\n     *\r\n     * @param {Element} slide     - A slide element.\r\n     * @param {number}  index     - A unique index. This can be negative.\r\n     * @param {number}  realIndex - A real index for clones. Set -1 for real slides.\r\n     */\n    register: function register(slide, index, realIndex) {\n      var SlideObject = elements_slide(Splide, index, realIndex, slide);\n      SlideObject.mount();\n      Slides.push(SlideObject);\n    },\n\n    /**\r\n     * Return the Slide object designated by the index.\r\n     * Note that \"find\" is not supported by IE.\r\n     *\r\n     * @return {Object|undefined} - A Slide object if available. Undefined if not.\r\n     */\n    getSlide: function getSlide(index) {\n      return Slides.filter(function (Slide) {\n        return Slide.index === index;\n      })[0];\n    },\n\n    /**\r\n     * Return all Slide objects.\r\n     *\r\n     * @param {boolean} includeClones - Whether to include cloned slides or not.\r\n     *\r\n     * @return {Object[]} - Slide objects.\r\n     */\n    getSlides: function getSlides(includeClones) {\n      return includeClones ? Slides : Slides.filter(function (Slide) {\n        return !Slide.isClone;\n      });\n    },\n\n    /**\r\n     * Return Slide objects belonging to the given page.\r\n     *\r\n     * @param {number} page - A page number.\r\n     *\r\n     * @return {Object[]} - An array containing Slide objects.\r\n     */\n    getSlidesByPage: function getSlidesByPage(page) {\n      var idx = Components.Controller.toIndex(page);\n      var options = Splide.options;\n      var max = options.focus !== false ? 1 : options.perPage;\n      return Slides.filter(function (_ref) {\n        var index = _ref.index;\n        return idx <= index && index < idx + max;\n      });\n    },\n\n    /**\r\n     * Insert a slide to a slider.\r\n     * Need to refresh Splide after adding a slide.\r\n     *\r\n     * @param {Node|string} slide    - A slide element to be added.\r\n     * @param {number}      index    - A slide will be added at the position.\r\n     * @param {Function}    callback - Called right after the slide is added to the DOM tree.\r\n     */\n    add: function add(slide, index, callback) {\n      if (typeof slide === 'string') {\n        slide = domify(slide);\n      }\n\n      if (slide instanceof Element) {\n        var ref = this.slides[index]; // This will be removed in mount() of a Slide component.\n\n        applyStyle(slide, {\n          display: 'none'\n        });\n\n        if (ref) {\n          before(slide, ref);\n          this.slides.splice(index, 0, slide);\n        } else {\n          append(this.list, slide);\n          this.slides.push(slide);\n        }\n\n        loaded(slide, function () {\n          callback && callback(slide);\n        });\n      }\n    },\n\n    /**\r\n     * Remove a slide from a slider.\r\n     * Need to refresh Splide after removing a slide.\r\n     *\r\n     * @param index - Slide index.\r\n     */\n    remove: function remove(index) {\n      dom_remove(this.slides.splice(index, 1)[0]);\n    },\n\n    /**\r\n     * Trigger the provided callback for each Slide object.\r\n     *\r\n     * @param {Function} callback - A callback function. The first argument will be the Slide object.\r\n     */\n    each: function each(callback) {\n      Slides.forEach(callback);\n    },\n\n    /**\r\n     * Return slides length without clones.\r\n     *\r\n     * @return {number} - Slide length.\r\n     */\n    get length() {\n      return this.slides.length;\n    },\n\n    /**\r\n     * Return \"SlideObjects\" length including clones.\r\n     *\r\n     * @return {number} - Slide length including clones.\r\n     */\n    get total() {\n      return Slides.length;\n    }\n\n  };\n  /**\r\n   * Collect elements.\r\n   */\n\n  function collect() {\n    Elements.slider = child(root, classes.slider);\n    Elements.track = find(root, \".\" + classes.track);\n    Elements.list = child(Elements.track, classes.list);\n    exist(Elements.track && Elements.list, 'Track or list was not found.');\n    Elements.slides = children(Elements.list, classes.slide);\n    var arrows = findParts(classes.arrows);\n    Elements.arrows = {\n      prev: find(arrows, \".\" + classes.prev),\n      next: find(arrows, \".\" + classes.next)\n    };\n    var autoplay = findParts(classes.autoplay);\n    Elements.bar = find(findParts(classes.progress), \".\" + classes.bar);\n    Elements.play = find(autoplay, \".\" + classes.play);\n    Elements.pause = find(autoplay, \".\" + classes.pause);\n    Elements.track.id = Elements.track.id || root.id + \"-track\";\n    Elements.list.id = Elements.list.id || root.id + \"-list\";\n  }\n  /**\r\n   * Return class names for the root element.\r\n   */\n\n\n  function getClasses() {\n    var rootClass = classes.root;\n    var options = Splide.options;\n    return [rootClass + \"--\" + options.type, rootClass + \"--\" + options.direction, options.drag ? rootClass + \"--draggable\" : '', options.isNavigation ? rootClass + \"--nav\" : '', STATUS_CLASSES.active];\n  }\n  /**\r\n   * Find parts only from children of the root or track.\r\n   *\r\n   * @return {Element} - A found element or undefined.\r\n   */\n\n\n  function findParts(className) {\n    return child(root, className) || child(Elements.slider, className);\n  }\n\n  return Elements;\n});\n;// CONCATENATED MODULE: ./src/js/components/controller/index.js\n/**\r\n * The component for controlling the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\nvar floor = Math.floor;\n/**\r\n * The component for controlling the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const controller = (function (Splide, Components) {\n  /**\r\n   * Store current options.\r\n   *\r\n   * @type {Object}\r\n   */\n  var options;\n  /**\r\n   * True if the slide is LOOP mode.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isLoop;\n  /**\r\n   * Controller component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Controller = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      options = Splide.options;\n      isLoop = Splide.is(LOOP);\n      bind();\n    },\n\n    /**\r\n     * Make track run by the given control.\r\n     * - \"+{i}\" : Increment the slide index by i.\r\n     * - \"-{i}\" : Decrement the slide index by i.\r\n     * - \"{i}\"  : Go to the slide whose index is i.\r\n     * - \">\"    : Go to next page.\r\n     * - \"<\"    : Go to prev page.\r\n     * - \">{i}\" : Go to page i.\r\n     *\r\n     * @param {string|number} control  - A control pattern.\r\n     * @param {boolean}       silently - Go to the destination without event emission.\r\n     */\n    go: function go(control, silently) {\n      var destIndex = this.trim(this.parse(control));\n      Components.Track.go(destIndex, this.rewind(destIndex), silently);\n    },\n\n    /**\r\n     * Parse the given control and return the destination index for the track.\r\n     *\r\n     * @param {string} control - A control target pattern.\r\n     *\r\n     * @return {number} - A parsed target.\r\n     */\n    parse: function parse(control) {\n      var index = Splide.index;\n      var matches = String(control).match(/([+\\-<>]+)(\\d+)?/);\n      var indicator = matches ? matches[1] : '';\n      var number = matches ? parseInt(matches[2]) : 0;\n\n      switch (indicator) {\n        case '+':\n          index += number || 1;\n          break;\n\n        case '-':\n          index -= number || 1;\n          break;\n\n        case '>':\n        case '<':\n          index = parsePage(number, index, indicator === '<');\n          break;\n\n        default:\n          index = parseInt(control);\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Compute index from the given page number.\r\n     *\r\n     * @param {number} page - Page number.\r\n     *\r\n     * @return {number} - A computed page number.\r\n     */\n    toIndex: function toIndex(page) {\n      if (hasFocus()) {\n        return page;\n      }\n\n      var length = Splide.length;\n      var perPage = options.perPage;\n      var index = page * perPage;\n      index = index - (this.pageLength * perPage - length) * floor(index / length); // Adjustment for the last page.\n\n      if (length - perPage <= index && index < length) {\n        index = length - perPage;\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Compute page number from the given slide index.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - A computed page number.\r\n     */\n    toPage: function toPage(index) {\n      if (hasFocus()) {\n        return index;\n      }\n\n      var length = Splide.length;\n      var perPage = options.perPage; // Make the last \"perPage\" number of slides belong to the last page.\n\n      if (length - perPage <= index && index < length) {\n        return floor((length - 1) / perPage);\n      }\n\n      return floor(index / perPage);\n    },\n\n    /**\r\n     * Trim the given index according to the current mode.\r\n     * Index being returned could be less than 0 or greater than the length in Loop mode.\r\n     *\r\n     * @param {number} index - An index being trimmed.\r\n     *\r\n     * @return {number} - A trimmed index.\r\n     */\n    trim: function trim(index) {\n      if (!isLoop) {\n        index = options.rewind ? this.rewind(index) : between(index, 0, this.edgeIndex);\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Rewind the given index if it's out of range.\r\n     *\r\n     * @param {number} index - An index.\r\n     *\r\n     * @return {number} - A rewound index.\r\n     */\n    rewind: function rewind(index) {\n      var edge = this.edgeIndex;\n\n      if (isLoop) {\n        while (index > edge) {\n          index -= edge + 1;\n        }\n\n        while (index < 0) {\n          index += edge + 1;\n        }\n      } else {\n        if (index > edge) {\n          index = 0;\n        } else if (index < 0) {\n          index = edge;\n        }\n      }\n\n      return index;\n    },\n\n    /**\r\n     * Check if the direction is \"rtl\" or not.\r\n     *\r\n     * @return {boolean} - True if \"rtl\" or false if not.\r\n     */\n    isRtl: function isRtl() {\n      return options.direction === RTL;\n    },\n\n    /**\r\n     * Return the page length.\r\n     *\r\n     * @return {number} - Max page number.\r\n     */\n    get pageLength() {\n      var length = Splide.length;\n      return hasFocus() ? length : Math.ceil(length / options.perPage);\n    },\n\n    /**\r\n     * Return the edge index.\r\n     *\r\n     * @return {number} - Edge index.\r\n     */\n    get edgeIndex() {\n      var length = Splide.length;\n\n      if (!length) {\n        return 0;\n      }\n\n      if (hasFocus() || options.isNavigation || isLoop) {\n        return length - 1;\n      }\n\n      return length - options.perPage;\n    },\n\n    /**\r\n     * Return the index of the previous slide.\r\n     *\r\n     * @return {number} - The index of the previous slide if available. -1 otherwise.\r\n     */\n    get prevIndex() {\n      var prev = Splide.index - 1;\n\n      if (isLoop || options.rewind) {\n        prev = this.rewind(prev);\n      }\n\n      return prev > -1 ? prev : -1;\n    },\n\n    /**\r\n     * Return the index of the next slide.\r\n     *\r\n     * @return {number} - The index of the next slide if available. -1 otherwise.\r\n     */\n    get nextIndex() {\n      var next = Splide.index + 1;\n\n      if (isLoop || options.rewind) {\n        next = this.rewind(next);\n      }\n\n      return Splide.index < next && next <= this.edgeIndex || next === 0 ? next : -1;\n    }\n\n  };\n  /**\r\n   * Listen to some events.\r\n   */\n\n  function bind() {\n    Splide.on('move', function (newIndex) {\n      Splide.index = newIndex;\n    }).on('updated refresh', function (newOptions) {\n      options = newOptions || options;\n      Splide.index = between(Splide.index, 0, Controller.edgeIndex);\n    });\n  }\n  /**\r\n   * Verify if the focus option is available or not.\r\n   *\r\n   * @return {boolean} - True if a slider has the focus option.\r\n   */\n\n\n  function hasFocus() {\n    return options.focus !== false;\n  }\n  /**\r\n   * Return the next or previous page index computed by the page number and current index.\r\n   *\r\n   * @param {number}  number - Specify the page number.\r\n   * @param {number}  index  - Current index.\r\n   * @param {boolean} prev   - Prev or next.\r\n   *\r\n   * @return {number} - Slide index.\r\n   */\n\n\n  function parsePage(number, index, prev) {\n    if (number > -1) {\n      return Controller.toIndex(number);\n    }\n\n    var perMove = options.perMove;\n    var sign = prev ? -1 : 1;\n\n    if (perMove) {\n      return index + perMove * sign;\n    }\n\n    return Controller.toIndex(Controller.toPage(index) + sign);\n  }\n\n  return Controller;\n});\n;// CONCATENATED MODULE: ./src/js/components/track/index.js\n/**\r\n * The component for moving list in the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\nvar abs = Math.abs;\n/**\r\n * The component for moving list in the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const track = (function (Splide, Components) {\n  /**\r\n   * Hold the Layout component.\r\n   *\r\n   * @type {Object}\r\n   */\n  var Layout;\n  /**\r\n   * Hold the Layout component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements;\n  /**\r\n   * Store the list element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var list;\n  /**\r\n   * Whether the current direction is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Whether the slider type is FADE or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isFade = Splide.is(FADE);\n  /**\r\n   * Whether the slider direction is RTL or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isRTL = Splide.options.direction === RTL;\n  /**\r\n   * This will be true while transitioning from the last index to the first one.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isLoopPending = false;\n  /**\r\n   * Sign for the direction. Only RTL mode uses the positive sign.\r\n   *\r\n   * @type {number}\r\n   */\n\n  var sign = isRTL ? 1 : -1;\n  /**\r\n   * Track component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Track = {\n    /**\r\n     * Make public the sign defined locally.\r\n     *\r\n     * @type {number}\r\n     */\n    sign: sign,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Elements = Components.Elements;\n      Layout = Components.Layout;\n      list = Elements.list;\n    },\n\n    /**\r\n     * Called after the component is mounted.\r\n     * The resize event must be registered after the Layout's one is done.\r\n     */\n    mounted: function mounted() {\n      var _this = this;\n\n      if (!isFade) {\n        this.jump(0);\n        Splide.on('mounted resize updated', function () {\n          _this.jump(Splide.index);\n        });\n      }\n    },\n\n    /**\r\n     * Go to the given destination index.\r\n     * After arriving there, the track is jump to the new index without animation, mainly for loop mode.\r\n     *\r\n     * @param {number}  destIndex - A destination index.\r\n     *                              This can be negative or greater than slides length for reaching clones.\r\n     * @param {number}  newIndex  - An actual new index. They are always same in Slide and Rewind mode.\r\n     * @param {boolean} silently  - If true, suppress emitting events.\r\n     */\n    go: function go(destIndex, newIndex, silently) {\n      var newPosition = getTrimmedPosition(destIndex);\n      var prevIndex = Splide.index; // Prevent any actions while transitioning from the last index to the first one for jump.\n\n      if (Splide.State.is(MOVING) && isLoopPending) {\n        return;\n      }\n\n      isLoopPending = destIndex !== newIndex;\n\n      if (!silently) {\n        Splide.emit('move', newIndex, prevIndex, destIndex);\n      }\n\n      if (Math.abs(newPosition - this.position) >= 1 || isFade) {\n        Components.Transition.start(destIndex, newIndex, prevIndex, this.toCoord(newPosition), function () {\n          onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n        });\n      } else {\n        if (destIndex !== prevIndex && Splide.options.trimSpace === 'move') {\n          Components.Controller.go(destIndex + destIndex - prevIndex, silently);\n        } else {\n          onTransitionEnd(destIndex, newIndex, prevIndex, silently);\n        }\n      }\n    },\n\n    /**\r\n     * Move the track to the specified index.\r\n     *\r\n     * @param {number} index - A destination index where the track jumps.\r\n     */\n    jump: function jump(index) {\n      this.translate(getTrimmedPosition(index));\n    },\n\n    /**\r\n     * Set the list position by CSS translate property.\r\n     *\r\n     * @param {number} position - A new position value.\r\n     */\n    translate: function translate(position) {\n      applyStyle(list, {\n        transform: \"translate\" + (isVertical ? 'Y' : 'X') + \"(\" + position + \"px)\"\n      });\n    },\n\n    /**\r\n     * Cancel the transition and set the list position.\r\n     * Also, loop the slider if necessary.\r\n     */\n    cancel: function cancel() {\n      if (Splide.is(LOOP)) {\n        this.shift();\n      } else {\n        // Ensure the current position.\n        this.translate(this.position);\n      }\n\n      applyStyle(list, {\n        transition: ''\n      });\n    },\n\n    /**\r\n     * Shift the slider if it exceeds borders on the edge.\r\n     */\n    shift: function shift() {\n      var position = abs(this.position);\n      var left = abs(this.toPosition(0));\n      var right = abs(this.toPosition(Splide.length));\n      var innerSize = right - left;\n\n      if (position < left) {\n        position += innerSize;\n      } else if (position > right) {\n        position -= innerSize;\n      }\n\n      this.translate(sign * position);\n    },\n\n    /**\r\n     * Trim redundant spaces on the left or right edge if necessary.\r\n     *\r\n     * @param {number} position - Position value to be trimmed.\r\n     *\r\n     * @return {number} - Trimmed position.\r\n     */\n    trim: function trim(position) {\n      if (!Splide.options.trimSpace || Splide.is(LOOP)) {\n        return position;\n      }\n\n      var edge = sign * (Layout.totalSize() - Layout.size - Layout.gap);\n      return between(position, edge, 0);\n    },\n\n    /**\r\n     * Calculate the closest slide index from the given position.\r\n     *\r\n     * @param {number} position - A position converted to an slide index.\r\n     *\r\n     * @return {number} - The closest slide index.\r\n     */\n    toIndex: function toIndex(position) {\n      var _this2 = this;\n\n      var index = 0;\n      var minDistance = Infinity;\n      Elements.getSlides(true).forEach(function (Slide) {\n        var slideIndex = Slide.index;\n        var distance = abs(_this2.toPosition(slideIndex) - position);\n\n        if (distance < minDistance) {\n          minDistance = distance;\n          index = slideIndex;\n        }\n      });\n      return index;\n    },\n\n    /**\r\n     * Return coordinates object by the given position.\r\n     *\r\n     * @param {number} position - A position value.\r\n     *\r\n     * @return {Object} - A coordinates object.\r\n     */\n    toCoord: function toCoord(position) {\n      return {\n        x: isVertical ? 0 : position,\n        y: isVertical ? position : 0\n      };\n    },\n\n    /**\r\n     * Calculate the track position by a slide index.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {Object} - Calculated position.\r\n     */\n    toPosition: function toPosition(index) {\n      var position = Layout.totalSize(index) - Layout.slideSize(index) - Layout.gap;\n      return sign * (position + this.offset(index));\n    },\n\n    /**\r\n     * Return the current offset value, considering direction.\r\n     *\r\n     * @return {number} - Offset amount.\r\n     */\n    offset: function offset(index) {\n      var focus = Splide.options.focus;\n      var slideSize = Layout.slideSize(index);\n\n      if (focus === 'center') {\n        return -(Layout.size - slideSize) / 2;\n      }\n\n      return -(parseInt(focus) || 0) * (slideSize + Layout.gap);\n    },\n\n    /**\r\n     * Return the current position.\r\n     * This returns the correct position even while transitioning by CSS.\r\n     *\r\n     * @return {number} - Current position.\r\n     */\n    get position() {\n      var prop = isVertical ? 'top' : isRTL ? 'right' : 'left';\n      return getRect(list)[prop] - (getRect(Elements.track)[prop] - Layout.padding[prop] * sign);\n    }\n\n  };\n  /**\r\n   * Called whenever slides arrive at a destination.\r\n   *\r\n   * @param {number}  destIndex - A destination index.\r\n   * @param {number}  newIndex  - A new index.\r\n   * @param {number}  prevIndex - A previous index.\r\n   * @param {boolean} silently  - If true, suppress emitting events.\r\n   */\n\n  function onTransitionEnd(destIndex, newIndex, prevIndex, silently) {\n    applyStyle(list, {\n      transition: ''\n    });\n    isLoopPending = false;\n\n    if (!isFade) {\n      Track.jump(newIndex);\n    }\n\n    if (!silently) {\n      Splide.emit('moved', newIndex, prevIndex, destIndex);\n    }\n  }\n  /**\r\n   * Convert index to the trimmed position.\r\n   *\r\n   * @return {number} - Trimmed position.\r\n   */\n\n\n  function getTrimmedPosition(index) {\n    return Track.trim(Track.toPosition(index));\n  }\n\n  return Track;\n});\n;// CONCATENATED MODULE: ./src/js/components/clones/index.js\n/**\r\n * The component for cloning some slides for \"loop\" mode of the track.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n/**\r\n * The component for cloning some slides for \"loop\" mode of the track.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const clones = (function (Splide, Components) {\n  /**\r\n   * Store information of all clones.\r\n   *\r\n   * @type {Array}\r\n   */\n  var clones = [];\n  /**\r\n   * Store the current clone count on one side.\r\n   *\r\n   * @type {number}\r\n   */\n\n  var cloneCount = 0;\n  /**\r\n   * Keep Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Clones component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Clones = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      if (Splide.is(LOOP)) {\n        init();\n        Splide.on('refresh:before', function () {\n          _this.destroy();\n        }).on('refresh', init).on('resize', function () {\n          if (cloneCount !== getCloneCount()) {\n            // Destroy before refresh not to collect clones by the Elements component.\n            _this.destroy();\n\n            Splide.refresh();\n          }\n        });\n      }\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      dom_remove(clones);\n      clones = [];\n    },\n\n    /**\r\n     * Return all clones.\r\n     *\r\n     * @return {Element[]} - Cloned elements.\r\n     */\n    get clones() {\n      return clones;\n    },\n\n    /**\r\n     * Return clone length.\r\n     *\r\n     * @return {number} - A length of clones.\r\n     */\n    get length() {\n      return clones.length;\n    }\n\n  };\n  /**\r\n   * Initialization.\r\n   */\n\n  function init() {\n    Clones.destroy();\n    cloneCount = getCloneCount();\n    generateClones(cloneCount);\n  }\n  /**\r\n   * Generate and append/prepend clones.\r\n   *\r\n   * @param {number} count - The half number of clones.\r\n   */\n\n\n  function generateClones(count) {\n    var length = Elements.length,\n        register = Elements.register;\n\n    if (length) {\n      var slides = Elements.slides;\n\n      while (slides.length < count) {\n        slides = slides.concat(slides);\n      } // Clones after the last element.\n\n\n      slides.slice(0, count).forEach(function (elm, index) {\n        var clone = cloneDeeply(elm);\n        append(Elements.list, clone);\n        clones.push(clone);\n        register(clone, index + length, index % length);\n      }); // Clones before the first element.\n\n      slides.slice(-count).forEach(function (elm, index) {\n        var clone = cloneDeeply(elm);\n        before(clone, slides[0]);\n        clones.push(clone);\n        register(clone, index - count, (length + index - count % length) % length);\n      });\n    }\n  }\n  /**\r\n   * Return half count of clones to be generated.\r\n   * Clone count is determined by:\r\n   * - \"clones\" value in the options.\r\n   * - Number of slides that can be placed in a view in \"fixed\" mode.\r\n   * - Max pages a flick action can move.\r\n   * - Whether the slide length is enough for perPage.\r\n   *\r\n   * @return {number} - Count for clones.\r\n   */\n\n\n  function getCloneCount() {\n    var options = Splide.options;\n\n    if (options.clones) {\n      return options.clones;\n    } // Use the slide length in autoWidth mode because the number cannot be calculated.\n\n\n    var baseCount = options.autoWidth || options.autoHeight ? Elements.length : options.perPage;\n    var dimension = options.direction === TTB ? 'Height' : 'Width';\n    var fixedSize = toPixel(Splide.root, options[\"fixed\" + dimension]);\n\n    if (fixedSize) {\n      // Roughly calculate the count. This needs not to be strict.\n      baseCount = Math.ceil(Elements.track[\"client\" + dimension] / fixedSize);\n    }\n\n    return baseCount * (options.drag ? options.flickMaxPages + 1 : 1);\n  }\n  /**\r\n   * Clone deeply the given element.\r\n   *\r\n   * @param {Element} elm - An element being duplicated.\r\n   *\r\n   * @return {Node} - A cloned node(element).\r\n   */\n\n\n  function cloneDeeply(elm) {\n    var clone = elm.cloneNode(true);\n    addClass(clone, Splide.classes.clone); // ID should not be duplicated.\n\n    removeAttribute(clone, 'id');\n    return clone;\n  }\n\n  return Clones;\n});\n;// CONCATENATED MODULE: ./src/js/components/layout/directions/horizontal.js\n/**\r\n * The resolver component for horizontal layout.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The resolver component for horizontal layout.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The resolver object.\r\n */\n\n/* harmony default export */ const horizontal = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Keep the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Keep the track element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var track;\n  /**\r\n   * Keep the latest options.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var options = Splide.options;\n  return {\n    /**\r\n     * Margin property name.\r\n     *\r\n     * @type {string}\r\n     */\n    margin: 'margin' + (options.direction === RTL ? 'Left' : 'Right'),\n\n    /**\r\n     * Always 0 because the height will be determined by inner contents.\r\n     *\r\n     * @type {number}\r\n     */\n    height: 0,\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      this.resize();\n    },\n\n    /**\r\n     * Resize gap and padding.\r\n     * This must be called on init.\r\n     */\n    resize: function resize() {\n      options = Splide.options;\n      track = Elements.track;\n      this.gap = toPixel(root, options.gap);\n      var padding = options.padding;\n      var left = toPixel(root, padding.left || padding);\n      var right = toPixel(root, padding.right || padding);\n      this.padding = {\n        left: left,\n        right: right\n      };\n      applyStyle(track, {\n        paddingLeft: unit(left),\n        paddingRight: unit(right)\n      });\n    },\n\n    /**\r\n     * Return total width from the left of the list to the right of the slide specified by the provided index.\r\n     *\r\n     * @param {number} index - Optional. A slide index. If undefined, total width of the slider will be returned.\r\n     *\r\n     * @return {number} - Total width to the right side of the specified slide, or 0 for an invalid index.\r\n     */\n    totalWidth: function totalWidth(index) {\n      if (index === void 0) {\n        index = Splide.length - 1;\n      }\n\n      var Slide = Elements.getSlide(index);\n      var width = 0;\n\n      if (Slide) {\n        var slideRect = getRect(Slide.slide);\n        var listRect = getRect(Elements.list);\n\n        if (options.direction === RTL) {\n          width = listRect.right - slideRect.left;\n        } else {\n          width = slideRect.right - listRect.left;\n        }\n\n        width += this.gap;\n      }\n\n      return width;\n    },\n\n    /**\r\n     * Return the slide width in px.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - The slide width.\r\n     */\n    slideWidth: function slideWidth(index) {\n      if (options.autoWidth) {\n        var Slide = Elements.getSlide(index);\n        return Slide ? Slide.slide.offsetWidth : 0;\n      }\n\n      var width = options.fixedWidth || (this.width + this.gap) / options.perPage - this.gap;\n      return toPixel(root, width);\n    },\n\n    /**\r\n     * Return the slide height in px.\r\n     *\r\n     * @return {number} - The slide height.\r\n     */\n    slideHeight: function slideHeight() {\n      var height = options.height || options.fixedHeight || this.width * options.heightRatio;\n      return toPixel(root, height);\n    },\n\n    /**\r\n     * Return slider width without padding.\r\n     *\r\n     * @return {number} - Current slider width.\r\n     */\n    get width() {\n      return track.clientWidth - this.padding.left - this.padding.right;\n    }\n\n  };\n});\n;// CONCATENATED MODULE: ./src/js/components/layout/directions/vertical.js\n/**\r\n * The resolver component for vertical layout.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The resolver component for vertical layout.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The resolver object.\r\n */\n\n/* harmony default export */ const vertical = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Keep the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Keep the track element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var track;\n  /**\r\n   * Keep the latest options.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var options;\n  return {\n    /**\r\n     * Margin property name.\r\n     *\r\n     * @type {string}\r\n     */\n    margin: 'marginBottom',\n\n    /**\r\n     * Initialization.\r\n     */\n    init: function init() {\n      this.resize();\n    },\n\n    /**\r\n     * Resize gap and padding.\r\n     * This must be called on init.\r\n     */\n    resize: function resize() {\n      options = Splide.options;\n      track = Elements.track;\n      this.gap = toPixel(root, options.gap);\n      var padding = options.padding;\n      var top = toPixel(root, padding.top || padding);\n      var bottom = toPixel(root, padding.bottom || padding);\n      this.padding = {\n        top: top,\n        bottom: bottom\n      };\n      applyStyle(track, {\n        paddingTop: unit(top),\n        paddingBottom: unit(bottom)\n      });\n    },\n\n    /**\r\n     * Return total height from the top of the list to the bottom of the slide specified by the provided index.\r\n     *\r\n     * @param {number} index - Optional. A slide index. If undefined, total height of the slider will be returned.\r\n     *\r\n     * @return {number} - Total height to the bottom of the specified slide, or 0 for an invalid index.\r\n     */\n    totalHeight: function totalHeight(index) {\n      if (index === void 0) {\n        index = Splide.length - 1;\n      }\n\n      var Slide = Elements.getSlide(index);\n\n      if (Slide) {\n        return getRect(Slide.slide).bottom - getRect(Elements.list).top + this.gap;\n      }\n\n      return 0;\n    },\n\n    /**\r\n     * Return the slide width in px.\r\n     *\r\n     * @return {number} - The slide width.\r\n     */\n    slideWidth: function slideWidth() {\n      return toPixel(root, options.fixedWidth || this.width);\n    },\n\n    /**\r\n     * Return the slide height in px.\r\n     *\r\n     * @param {number} index - Slide index.\r\n     *\r\n     * @return {number} - The slide height.\r\n     */\n    slideHeight: function slideHeight(index) {\n      if (options.autoHeight) {\n        var Slide = Elements.getSlide(index);\n        return Slide ? Slide.slide.offsetHeight : 0;\n      }\n\n      var height = options.fixedHeight || (this.height + this.gap) / options.perPage - this.gap;\n      return toPixel(root, height);\n    },\n\n    /**\r\n     * Return slider width without padding.\r\n     *\r\n     * @return {number} - Current slider width.\r\n     */\n    get width() {\n      return track.clientWidth;\n    },\n\n    /**\r\n     * Return slide height without padding.\r\n     *\r\n     * @return {number} - Slider height.\r\n     */\n    get height() {\n      var height = options.height || this.width * options.heightRatio;\n      exist(height, '\"height\" or \"heightRatio\" is missing.');\n      return toPixel(root, height) - this.padding.top - this.padding.bottom;\n    }\n\n  };\n});\n;// CONCATENATED MODULE: ./src/js/utils/time.js\n/**\r\n * A package of utility functions related with time.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Simple throttle function that controls how often the given function is executed.\r\n *\r\n * @param {function} func - A function to be throttled.\r\n * @param {number}   wait - Time in millisecond for interval of execution.\r\n *\r\n * @return {Function} - A debounced function.\r\n */\nfunction throttle(func, wait) {\n  var timeout; // Declare function by the \"function\" keyword to prevent \"this\" from being inherited.\n\n  return function () {\n    if (!timeout) {\n      timeout = setTimeout(function () {\n        func();\n        timeout = null;\n      }, wait);\n    }\n  };\n}\n/**\r\n * Custom setInterval function that provides progress rate as callback.\r\n *\r\n * @param {function} callback - A callback function fired every time the interval time passes.\r\n * @param {number}   interval - Interval duration in milliseconds.\r\n * @param {function} progress - A callback function fired whenever the progress goes.\r\n *\r\n * @return {Object} - An object containing play() and pause() functions.\r\n */\n\nfunction createInterval(callback, interval, progress) {\n  var _window = window,\n      requestAnimationFrame = _window.requestAnimationFrame;\n  var start,\n      elapse,\n      rate,\n      _pause = true;\n\n  var step = function step(timestamp) {\n    if (!_pause) {\n      if (!start) {\n        start = timestamp;\n\n        if (rate && rate < 1) {\n          start -= rate * interval;\n        }\n      }\n\n      elapse = timestamp - start;\n      rate = elapse / interval;\n\n      if (elapse >= interval) {\n        start = 0;\n        rate = 1;\n        callback();\n      }\n\n      if (progress) {\n        progress(rate);\n      }\n\n      requestAnimationFrame(step);\n    }\n  };\n\n  return {\n    pause: function pause() {\n      _pause = true;\n      start = 0;\n    },\n    play: function play(reset) {\n      start = 0;\n\n      if (reset) {\n        rate = 0;\n      }\n\n      if (_pause) {\n        _pause = false;\n        requestAnimationFrame(step);\n      }\n    }\n  };\n}\n;// CONCATENATED MODULE: ./src/js/components/layout/index.js\n/**\r\n * The component for handing slide layouts and their sizes.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n/**\r\n * The component for handing slide layouts and their sizes.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const layout = (function (Splide, Components) {\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n  var Elements = Components.Elements;\n  /**\r\n   * Whether the slider is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Layout component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Layout = object_assign({\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      bind();\n      init(); // The word \"size\" means width for a horizontal slider and height for a vertical slider.\n\n      this.totalSize = isVertical ? this.totalHeight : this.totalWidth;\n      this.slideSize = isVertical ? this.slideHeight : this.slideWidth;\n    },\n\n    /**\r\n     * Destroy the component.\r\n     */\n    destroy: function destroy() {\n      removeAttribute([Elements.list, Elements.track], 'style');\n    },\n\n    /**\r\n     * Return the slider height on the vertical mode or width on the horizontal mode.\r\n     *\r\n     * @return {number}\r\n     */\n    get size() {\n      return isVertical ? this.height : this.width;\n    }\n\n  }, isVertical ? vertical(Splide, Components) : horizontal(Splide, Components));\n  /**\r\n   * Init slider styles according to options.\r\n   */\n\n  function init() {\n    Layout.init();\n    applyStyle(Splide.root, {\n      maxWidth: unit(Splide.options.width)\n    });\n    Elements.each(function (Slide) {\n      Slide.slide.style[Layout.margin] = unit(Layout.gap);\n    });\n    resize();\n  }\n  /**\r\n   * Listen the resize native event with throttle.\r\n   * Initialize when the component is mounted or options are updated.\r\n   */\n\n\n  function bind() {\n    Splide.on('resize load', throttle(function () {\n      Splide.emit('resize');\n    }, Splide.options.throttle), window).on('resize', resize).on('updated refresh', init);\n  }\n  /**\r\n   * Resize the track and slide elements.\r\n   */\n\n\n  function resize() {\n    var options = Splide.options;\n    Layout.resize();\n    applyStyle(Elements.track, {\n      height: unit(Layout.height)\n    });\n    var slideHeight = options.autoHeight ? null : unit(Layout.slideHeight());\n    Elements.each(function (Slide) {\n      applyStyle(Slide.container, {\n        height: slideHeight\n      });\n      applyStyle(Slide.slide, {\n        width: options.autoWidth ? null : unit(Layout.slideWidth(Slide.index)),\n        height: Slide.container ? null : slideHeight\n      });\n    });\n    Splide.emit('resized');\n  }\n\n  return Layout;\n});\n;// CONCATENATED MODULE: ./src/js/components/drag/index.js\n/**\r\n * The component for supporting mouse drag and swipe.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\nvar drag_abs = Math.abs;\n/**\r\n * If the absolute velocity is greater thant this value,\r\n * a slider always goes to a different slide after drag, not allowed to stay on a current slide.\r\n */\n\nvar MIN_VELOCITY = 0.1;\n/**\r\n * Adjust how much the track can be pulled on the first or last page.\r\n * The larger number this is, the farther the track moves.\r\n * This should be around 5 - 9.\r\n *\r\n * @type {number}\r\n */\n\nvar FRICTION_REDUCER = 7;\n/**\r\n * The component supporting mouse drag and swipe.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const drag = (function (Splide, Components) {\n  /**\r\n   * Store the Move component.\r\n   *\r\n   * @type {Object}\r\n   */\n  var Track = Components.Track;\n  /**\r\n   * Store the Controller component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Controller = Components.Controller;\n  /**\r\n   * Coordinate of the track on starting drag.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var startCoord;\n  /**\r\n   * Analyzed info on starting drag.\r\n   *\r\n   * @type {Object|null}\r\n   */\n\n  var startInfo;\n  /**\r\n   * Analyzed info being updated while dragging/swiping.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var currentInfo;\n  /**\r\n   * Determine whether slides are being dragged or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isDragging;\n  /**\r\n   * Whether the slider direction is vertical or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isVertical = Splide.options.direction === TTB;\n  /**\r\n   * Axis for the direction.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var axis = isVertical ? 'y' : 'x';\n  /**\r\n   * Drag component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Drag = {\n    /**\r\n     * Whether dragging is disabled or not.\r\n     *\r\n     * @type {boolean}\r\n     */\n    disabled: false,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var _this = this;\n\n      var Elements = Components.Elements;\n      var track = Elements.track;\n      Splide.on('touchstart mousedown', start, track).on('touchmove mousemove', move, track, {\n        passive: false\n      }).on('touchend touchcancel mouseleave mouseup dragend', end, track).on('mounted refresh', function () {\n        // Prevent dragging an image or anchor itself.\n        each(Elements.list.querySelectorAll('img, a'), function (elm) {\n          Splide.off('dragstart', elm).on('dragstart', function (e) {\n            e.preventDefault();\n          }, elm, {\n            passive: false\n          });\n        });\n      }).on('mounted updated', function () {\n        _this.disabled = !Splide.options.drag;\n      });\n    }\n  };\n  /**\r\n   * Called when the track starts to be dragged.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n  function start(e) {\n    if (!Drag.disabled && !isDragging) {\n      // These prams are used to evaluate whether the slider should start moving.\n      init(e);\n    }\n  }\n  /**\r\n   * Initialize parameters.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n\n  function init(e) {\n    startCoord = Track.toCoord(Track.position);\n    startInfo = analyze(e, {});\n    currentInfo = startInfo;\n  }\n  /**\r\n   * Called while the track being dragged.\r\n   *\r\n   * @param {TouchEvent|MouseEvent} e - TouchEvent or MouseEvent object.\r\n   */\n\n\n  function move(e) {\n    if (startInfo) {\n      currentInfo = analyze(e, startInfo);\n\n      if (isDragging) {\n        if (e.cancelable) {\n          e.preventDefault();\n        }\n\n        if (!Splide.is(FADE)) {\n          var position = startCoord[axis] + currentInfo.offset[axis];\n          Track.translate(resist(position));\n        }\n      } else {\n        if (shouldMove(currentInfo)) {\n          Splide.emit('drag', startInfo);\n          isDragging = true;\n          Track.cancel(); // These params are actual drag data.\n\n          init(e);\n        }\n      }\n    }\n  }\n  /**\r\n   * Determine whether to start moving the track or not by drag angle.\r\n   *\r\n   * @param {Object} info - An information object.\r\n   *\r\n   * @return {boolean} - True if the track should be moved or false if not.\r\n   */\n\n\n  function shouldMove(_ref) {\n    var offset = _ref.offset;\n\n    if (Splide.State.is(MOVING) && Splide.options.waitForTransition) {\n      return false;\n    }\n\n    var angle = Math.atan(drag_abs(offset.y) / drag_abs(offset.x)) * 180 / Math.PI;\n\n    if (isVertical) {\n      angle = 90 - angle;\n    }\n\n    return angle < Splide.options.dragAngleThreshold;\n  }\n  /**\r\n   * Resist dragging the track on the first/last page because there is no more.\r\n   *\r\n   * @param {number} position - A position being applied to the track.\r\n   *\r\n   * @return {Object} - Adjusted position.\r\n   */\n\n\n  function resist(position) {\n    if (Splide.is(SLIDE)) {\n      var sign = Track.sign;\n\n      var _start = sign * Track.trim(Track.toPosition(0));\n\n      var _end = sign * Track.trim(Track.toPosition(Controller.edgeIndex));\n\n      position *= sign;\n\n      if (position < _start) {\n        position = _start - FRICTION_REDUCER * Math.log(_start - position);\n      } else if (position > _end) {\n        position = _end + FRICTION_REDUCER * Math.log(position - _end);\n      }\n\n      position *= sign;\n    }\n\n    return position;\n  }\n  /**\r\n   * Called when dragging ends.\r\n   */\n\n\n  function end() {\n    startInfo = null;\n\n    if (isDragging) {\n      Splide.emit('dragged', currentInfo);\n      go(currentInfo);\n      isDragging = false;\n    }\n  }\n  /**\r\n   * Go to the slide determined by the analyzed data.\r\n   *\r\n   * @param {Object} info - An info object.\r\n   */\n\n\n  function go(info) {\n    var velocity = info.velocity[axis];\n    var absV = drag_abs(velocity);\n\n    if (absV > 0) {\n      var options = Splide.options;\n      var index = Splide.index;\n      var sign = velocity < 0 ? -1 : 1;\n      var destIndex = index;\n\n      if (!Splide.is(FADE)) {\n        var destination = Track.position;\n\n        if (absV > options.flickVelocityThreshold && drag_abs(info.offset[axis]) < options.swipeDistanceThreshold) {\n          destination += sign * Math.min(absV * options.flickPower, Components.Layout.size * (options.flickMaxPages || 1));\n        }\n\n        destIndex = Track.toIndex(destination);\n      }\n      /*\r\n       * Do not allow the track to go to a previous position if there is enough velocity.\r\n       * Always use the adjacent index for the fade mode.\r\n       */\n\n\n      if (destIndex === index && absV > MIN_VELOCITY) {\n        destIndex = index + sign * Track.sign;\n      }\n\n      if (Splide.is(SLIDE)) {\n        destIndex = between(destIndex, 0, Controller.edgeIndex);\n      }\n\n      Controller.go(destIndex, options.isNavigation);\n    }\n  }\n  /**\r\n   * Analyze the given event object and return important information for handling swipe behavior.\r\n   *\r\n   * @param {Event}   e          - Touch or Mouse event object.\r\n   * @param {Object}  startInfo  - Information analyzed on start for calculating difference from the current one.\r\n   *\r\n   * @return {Object} - An object containing analyzed information, such as offset, velocity, etc.\r\n   */\n\n\n  function analyze(e, startInfo) {\n    var timeStamp = e.timeStamp,\n        touches = e.touches;\n\n    var _ref2 = touches ? touches[0] : e,\n        clientX = _ref2.clientX,\n        clientY = _ref2.clientY;\n\n    var _ref3 = startInfo.to || {},\n        _ref3$x = _ref3.x,\n        fromX = _ref3$x === void 0 ? clientX : _ref3$x,\n        _ref3$y = _ref3.y,\n        fromY = _ref3$y === void 0 ? clientY : _ref3$y;\n\n    var startTime = startInfo.time || 0;\n    var offset = {\n      x: clientX - fromX,\n      y: clientY - fromY\n    };\n    var duration = timeStamp - startTime;\n    var velocity = {\n      x: offset.x / duration,\n      y: offset.y / duration\n    };\n    return {\n      to: {\n        x: clientX,\n        y: clientY\n      },\n      offset: offset,\n      time: timeStamp,\n      velocity: velocity\n    };\n  }\n\n  return Drag;\n});\n;// CONCATENATED MODULE: ./src/js/components/click/index.js\n/**\r\n * The component for handling a click event.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The component for handling a click event.\r\n * Click should be disabled during drag/swipe.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n/* harmony default export */ const click = (function (Splide, Components) {\n  /**\r\n   * Whether click is disabled or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n  var disabled = false;\n  /**\r\n   * Click component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Click = {\n    /**\r\n     * Mount only when the drag is activated and the slide type is not \"fade\".\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.drag,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('click', onClick, Components.Elements.track, {\n        capture: true\n      }).on('drag', function () {\n        disabled = true;\n      }).on('dragged', function () {\n        // Make sure the flag is released after the click event is fired.\n        setTimeout(function () {\n          disabled = false;\n        });\n      });\n    }\n  };\n  /**\r\n   * Called when a track element is clicked.\r\n   *\r\n   * @param {Event} e - A click event.\r\n   */\n\n  function onClick(e) {\n    if (disabled) {\n      e.preventDefault();\n      e.stopPropagation();\n      e.stopImmediatePropagation();\n    }\n  }\n\n  return Click;\n});\n;// CONCATENATED MODULE: ./src/js/components/autoplay/index.js\n/**\r\n * The component for playing slides automatically.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Set of pause flags.\r\n */\n\nvar PAUSE_FLAGS = {\n  HOVER: 1,\n  FOCUS: 2,\n  MANUAL: 3\n};\n/**\r\n * The component for playing slides automatically.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const autoplay = (function (Splide, Components, name) {\n  /**\r\n   * Store pause flags.\r\n   *\r\n   * @type {Array}\r\n   */\n  var flags = [];\n  /**\r\n   * Store an interval object.\r\n   *\r\n   * @type {Object};\r\n   */\n\n  var interval;\n  /**\r\n   * Keep the Elements component.\r\n   *\r\n   * @type {string}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Autoplay component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Autoplay = {\n    /**\r\n     * Required only when the autoplay option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.autoplay,\n\n    /**\r\n     * Called when the component is mounted.\r\n     * Note that autoplay starts only if there are slides over perPage number.\r\n     */\n    mount: function mount() {\n      var options = Splide.options;\n\n      if (Elements.slides.length > options.perPage) {\n        interval = createInterval(function () {\n          Splide.go('>');\n        }, options.interval, function (rate) {\n          Splide.emit(name + \":playing\", rate);\n\n          if (Elements.bar) {\n            applyStyle(Elements.bar, {\n              width: rate * 100 + \"%\"\n            });\n          }\n        });\n        bind();\n        this.play();\n      }\n    },\n\n    /**\r\n     * Start autoplay.\r\n     *\r\n     * @param {number} flag - A pause flag to be removed.\r\n     */\n    play: function play(flag) {\n      if (flag === void 0) {\n        flag = 0;\n      }\n\n      flags = flags.filter(function (f) {\n        return f !== flag;\n      });\n\n      if (!flags.length) {\n        Splide.emit(name + \":play\");\n        interval.play(Splide.options.resetProgress);\n      }\n    },\n\n    /**\r\n     * Pause autoplay.\r\n     * Note that Array.includes is not supported by IE.\r\n     *\r\n     * @param {number} flag - A pause flag to be added.\r\n     */\n    pause: function pause(flag) {\n      if (flag === void 0) {\n        flag = 0;\n      }\n\n      interval.pause();\n\n      if (flags.indexOf(flag) === -1) {\n        flags.push(flag);\n      }\n\n      if (flags.length === 1) {\n        Splide.emit(name + \":pause\");\n      }\n    }\n  };\n  /**\r\n   * Listen some events.\r\n   */\n\n  function bind() {\n    var options = Splide.options;\n    var sibling = Splide.sibling;\n    var elms = [Splide.root, sibling ? sibling.root : null];\n\n    if (options.pauseOnHover) {\n      switchOn(elms, 'mouseleave', PAUSE_FLAGS.HOVER, true);\n      switchOn(elms, 'mouseenter', PAUSE_FLAGS.HOVER, false);\n    }\n\n    if (options.pauseOnFocus) {\n      switchOn(elms, 'focusout', PAUSE_FLAGS.FOCUS, true);\n      switchOn(elms, 'focusin', PAUSE_FLAGS.FOCUS, false);\n    }\n\n    if (Elements.play) {\n      Splide.on('click', function () {\n        // Need to be removed a focus flag at first.\n        Autoplay.play(PAUSE_FLAGS.FOCUS);\n        Autoplay.play(PAUSE_FLAGS.MANUAL);\n      }, Elements.play);\n    }\n\n    if (Elements.pause) {\n      switchOn([Elements.pause], 'click', PAUSE_FLAGS.MANUAL, false);\n    }\n\n    Splide.on('move refresh', function () {\n      Autoplay.play();\n    }) // Rewind the timer.\n    .on('destroy', function () {\n      Autoplay.pause();\n    });\n  }\n  /**\r\n   * Play or pause on the given event.\r\n   *\r\n   * @param {Element[]} elms  - Elements.\r\n   * @param {string}    event - An event name or names.\r\n   * @param {number}    flag  - A pause flag defined on the top.\r\n   * @param {boolean}   play  - Determine whether to play or pause.\r\n   */\n\n\n  function switchOn(elms, event, flag, play) {\n    elms.forEach(function (elm) {\n      Splide.on(event, function () {\n        Autoplay[play ? 'play' : 'pause'](flag);\n      }, elm);\n    });\n  }\n\n  return Autoplay;\n});\n;// CONCATENATED MODULE: ./src/js/components/cover/index.js\n/**\r\n * The component for change an img element to background image of its wrapper.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * The component for change an img element to background image of its wrapper.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const cover = (function (Splide, Components) {\n  /**\r\n   * Hold options.\r\n   *\r\n   * @type {Object}\r\n   */\n  var options = Splide.options;\n  /**\r\n   * Cover component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Cover = {\n    /**\r\n     * Required only when \"cover\" option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: options.cover,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('lazyload:loaded', function (img) {\n        cover(img, false);\n      });\n      Splide.on('mounted updated refresh', function () {\n        return apply(false);\n      });\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      apply(true);\n    }\n  };\n  /**\r\n   * Apply \"cover\" to all slides.\r\n   *\r\n   * @param {boolean} uncover - If true, \"cover\" will be clear.\r\n   */\n\n  function apply(uncover) {\n    Components.Elements.each(function (Slide) {\n      var img = child(Slide.slide, 'IMG') || child(Slide.container, 'IMG');\n\n      if (img && img.src) {\n        cover(img, uncover);\n      }\n    });\n  }\n  /**\r\n   * Set background image of the parent element, using source of the given image element.\r\n   *\r\n   * @param {Element} img     - An image element.\r\n   * @param {boolean} uncover - Reset \"cover\".\r\n   */\n\n\n  function cover(img, uncover) {\n    applyStyle(img.parentElement, {\n      background: uncover ? '' : \"center/cover no-repeat url(\\\"\" + img.src + \"\\\")\"\n    });\n    applyStyle(img, {\n      display: uncover ? '' : 'none'\n    });\n  }\n\n  return Cover;\n});\n;// CONCATENATED MODULE: ./src/js/components/arrows/path.js\n/**\r\n * Export vector path for an arrow.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Namespace definition for SVG element.\r\n *\r\n * @type {string}\r\n */\nvar XML_NAME_SPACE = 'http://www.w3.org/2000/svg';\n/**\r\n * The arrow vector path.\r\n *\r\n * @type {number}\r\n */\n\nvar PATH = 'm15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z';\n/**\r\n * SVG width and height.\r\n *\r\n * @type {number}\r\n */\n\nvar SIZE = 40;\n;// CONCATENATED MODULE: ./src/js/components/arrows/index.js\n/**\r\n * The component for appending prev/next arrows.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for appending prev/next arrows.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const arrows = (function (Splide, Components, name) {\n  /**\r\n   * Previous arrow element.\r\n   *\r\n   * @type {Element|undefined}\r\n   */\n  var prev;\n  /**\r\n   * Next arrow element.\r\n   *\r\n   * @type {Element|undefined}\r\n   */\n\n  var next;\n  /**\r\n   * Store the class list.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var classes = Splide.classes;\n  /**\r\n   * Hold the root element.\r\n   *\r\n   * @type {Element}\r\n   */\n\n  var root = Splide.root;\n  /**\r\n   * Whether arrows are created programmatically or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var created;\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Arrows component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Arrows = {\n    /**\r\n     * Required when the arrows option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.arrows,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      // Attempt to get arrows from HTML source.\n      prev = Elements.arrows.prev;\n      next = Elements.arrows.next; // If arrows were not found in HTML, let's generate them.\n\n      if ((!prev || !next) && Splide.options.arrows) {\n        prev = createArrow(true);\n        next = createArrow(false);\n        created = true;\n        appendArrows();\n      }\n\n      if (prev && next) {\n        bind();\n      }\n\n      this.arrows = {\n        prev: prev,\n        next: next\n      };\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      Splide.emit(name + \":mounted\", prev, next);\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      removeAttribute([prev, next], 'disabled');\n\n      if (created) {\n        dom_remove(prev.parentElement);\n      }\n    }\n  };\n  /**\r\n   * Listen to native and custom events.\r\n   */\n\n  function bind() {\n    Splide.on('click', function () {\n      Splide.go('<');\n    }, prev).on('click', function () {\n      Splide.go('>');\n    }, next).on('mounted move updated refresh', updateDisabled);\n  }\n  /**\r\n   * Update a disabled attribute.\r\n   */\n\n\n  function updateDisabled() {\n    var _Components$Controlle = Components.Controller,\n        prevIndex = _Components$Controlle.prevIndex,\n        nextIndex = _Components$Controlle.nextIndex;\n    var isEnough = Splide.length > Splide.options.perPage || Splide.is(LOOP);\n    prev.disabled = prevIndex < 0 || !isEnough;\n    next.disabled = nextIndex < 0 || !isEnough;\n    Splide.emit(name + \":updated\", prev, next, prevIndex, nextIndex);\n  }\n  /**\r\n   * Create a wrapper element and append arrows.\r\n   */\n\n\n  function appendArrows() {\n    var wrapper = create('div', {\n      \"class\": classes.arrows\n    });\n    append(wrapper, prev);\n    append(wrapper, next);\n    var slider = Elements.slider;\n    var parent = Splide.options.arrows === 'slider' && slider ? slider : root;\n    before(wrapper, parent.firstElementChild);\n  }\n  /**\r\n   * Create an arrow element.\r\n   *\r\n   * @param {boolean} prev - Determine to create a prev arrow or next arrow.\r\n   *\r\n   * @return {Element} - A created arrow element.\r\n   */\n\n\n  function createArrow(prev) {\n    var arrow = \"<button class=\\\"\" + classes.arrow + \" \" + (prev ? classes.prev : classes.next) + \"\\\" type=\\\"button\\\">\" + (\"<svg xmlns=\\\"\" + XML_NAME_SPACE + \"\\\"\\tviewBox=\\\"0 0 \" + SIZE + \" \" + SIZE + \"\\\"\\twidth=\\\"\" + SIZE + \"\\\"\\theight=\\\"\" + SIZE + \"\\\">\") + (\"<path d=\\\"\" + (Splide.options.arrowPath || PATH) + \"\\\" />\");\n    return domify(arrow);\n  }\n\n  return Arrows;\n});\n;// CONCATENATED MODULE: ./src/js/components/pagination/index.js\n/**\r\n * The component for handling pagination\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The event name for updating some attributes of pagination nodes.\r\n *\r\n * @type {string}\r\n */\n\nvar ATTRIBUTES_UPDATE_EVENT = 'move.page';\n/**\r\n * The event name for recreating pagination.\r\n *\r\n * @type {string}\r\n */\n\nvar UPDATE_EVENT = 'updated.page refresh.page';\n/**\r\n * The component for handling pagination\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const pagination = (function (Splide, Components, name) {\n  /**\r\n   * Store all data for pagination.\r\n   * - list: A list element.\r\n   * - items: An array that contains objects(li, button, index, page).\r\n   *\r\n   * @type {Object}\r\n   */\n  var data = {};\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * Pagination component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Pagination = {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      var pagination = Splide.options.pagination;\n\n      if (pagination) {\n        data = createPagination();\n        var slider = Elements.slider;\n        var parent = pagination === 'slider' && slider ? slider : Splide.root;\n        append(parent, data.list);\n        Splide.on(ATTRIBUTES_UPDATE_EVENT, updateAttributes);\n      }\n\n      Splide.off(UPDATE_EVENT).on(UPDATE_EVENT, function () {\n        Pagination.destroy();\n\n        if (Splide.options.pagination) {\n          Pagination.mount();\n          Pagination.mounted();\n        }\n      });\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      if (Splide.options.pagination) {\n        var index = Splide.index;\n        Splide.emit(name + \":mounted\", data, this.getItem(index));\n        updateAttributes(index, -1);\n      }\n    },\n\n    /**\r\n     * Destroy the pagination.\r\n     * Be aware that node.remove() is not supported by IE.\r\n     */\n    destroy: function destroy() {\n      dom_remove(data.list);\n\n      if (data.items) {\n        data.items.forEach(function (item) {\n          Splide.off('click', item.button);\n        });\n      } // Do not remove UPDATE_EVENT to recreate pagination if needed.\n\n\n      Splide.off(ATTRIBUTES_UPDATE_EVENT);\n      data = {};\n    },\n\n    /**\r\n     * Return an item by index.\r\n     *\r\n     * @param {number} index - A slide index.\r\n     *\r\n     * @return {Object|undefined} - An item object on success or undefined on failure.\r\n     */\n    getItem: function getItem(index) {\n      return data.items[Components.Controller.toPage(index)];\n    },\n\n    /**\r\n     * Return object containing pagination data.\r\n     *\r\n     * @return {Object} - Pagination data including list and items.\r\n     */\n    get data() {\n      return data;\n    }\n\n  };\n  /**\r\n   * Update attributes.\r\n   *\r\n   * @param {number} index     - Active index.\r\n   * @param {number} prevIndex - Prev index.\r\n   */\n\n  function updateAttributes(index, prevIndex) {\n    var prev = Pagination.getItem(prevIndex);\n    var curr = Pagination.getItem(index);\n    var active = STATUS_CLASSES.active;\n\n    if (prev) {\n      removeClass(prev.button, active);\n    }\n\n    if (curr) {\n      addClass(curr.button, active);\n    }\n\n    Splide.emit(name + \":updated\", data, prev, curr);\n  }\n  /**\r\n   * Create a wrapper and button elements.\r\n   *\r\n   * @return {Object} - An object contains all data.\r\n   */\n\n\n  function createPagination() {\n    var options = Splide.options;\n    var classes = Splide.classes;\n    var list = create('ul', {\n      \"class\": classes.pagination\n    });\n    var items = Elements.getSlides(false).filter(function (Slide) {\n      return options.focus !== false || Slide.index % options.perPage === 0;\n    }).map(function (Slide, page) {\n      var li = create('li', {});\n      var button = create('button', {\n        \"class\": classes.page,\n        type: 'button'\n      });\n      append(li, button);\n      append(list, li);\n      Splide.on('click', function () {\n        Splide.go(\">\" + page);\n      }, button);\n      return {\n        li: li,\n        button: button,\n        page: page,\n        Slides: Elements.getSlidesByPage(page)\n      };\n    });\n    return {\n      list: list,\n      items: items\n    };\n  }\n\n  return Pagination;\n});\n;// CONCATENATED MODULE: ./src/js/components/lazyload/index.js\n/**\r\n * The component for loading slider images lazily.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The name for a data attribute of src.\r\n *\r\n * @type {string}\r\n */\n\nvar SRC_DATA_NAME = 'data-splide-lazy';\n/**\r\n * The name for a data attribute of srcset.\r\n *\r\n * @type {string}\r\n */\n\nvar SRCSET_DATA_NAME = 'data-splide-lazy-srcset';\n/**\r\n * The component for loading slider images lazily.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n * @param {string} name       - A component name as a lowercase string.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const lazyload = (function (Splide, Components, name) {\n  /**\r\n   * Next index for sequential loading.\r\n   *\r\n   * @type {number}\r\n   */\n  var nextIndex;\n  /**\r\n   * Store objects containing an img element and a Slide object.\r\n   *\r\n   * @type {Object[]}\r\n   */\n\n  var images;\n  /**\r\n   * Store the options.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var options = Splide.options;\n  /**\r\n   * Whether to load images sequentially or not.\r\n   *\r\n   * @type {boolean}\r\n   */\n\n  var isSequential = options.lazyLoad === 'sequential';\n  /**\r\n   * Lazyload component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Lazyload = {\n    /**\r\n     * Mount only when the lazyload option is provided.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: options.lazyLoad,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('mounted refresh', function () {\n        init();\n        Components.Elements.each(function (Slide) {\n          each(Slide.slide.querySelectorAll(\"[\" + SRC_DATA_NAME + \"], [\" + SRCSET_DATA_NAME + \"]\"), function (img) {\n            if (!img.src && !img.srcset) {\n              images.push({\n                img: img,\n                Slide: Slide\n              });\n              applyStyle(img, {\n                display: 'none'\n              });\n            }\n          });\n        });\n\n        if (isSequential) {\n          loadNext();\n        }\n      });\n\n      if (!isSequential) {\n        Splide.on(\"mounted refresh moved.\" + name, check);\n      }\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: init\n  };\n  /**\r\n   * Initialize parameters.\r\n   */\n\n  function init() {\n    images = [];\n    nextIndex = 0;\n  }\n  /**\r\n   * Check how close each image is from the active slide and\r\n   * determine whether to start loading or not, according to the distance.\r\n   *\r\n   * @param {number} index - Current index.\r\n   */\n\n\n  function check(index) {\n    index = isNaN(index) ? Splide.index : index;\n    images = images.filter(function (image) {\n      if (image.Slide.isWithin(index, options.perPage * (options.preloadPages + 1))) {\n        load(image.img, image.Slide);\n        return false;\n      }\n\n      return true;\n    }); // Unbind if all images are loaded.\n\n    if (!images[0]) {\n      Splide.off(\"moved.\" + name);\n    }\n  }\n  /**\r\n   * Start loading an image.\r\n   * Creating a clone of the image element since setting src attribute directly to it\r\n   * often occurs 'hitch', blocking some other processes of a browser.\r\n   *\r\n   * @param {Element} img   - An image element.\r\n   * @param {Object}  Slide - A Slide object.\r\n   */\n\n\n  function load(img, Slide) {\n    addClass(Slide.slide, STATUS_CLASSES.loading);\n    var spinner = create('span', {\n      \"class\": Splide.classes.spinner\n    });\n    append(img.parentElement, spinner);\n\n    img.onload = function () {\n      loaded(img, spinner, Slide, false);\n    };\n\n    img.onerror = function () {\n      loaded(img, spinner, Slide, true);\n    };\n\n    setAttribute(img, 'srcset', getAttribute(img, SRCSET_DATA_NAME) || '');\n    setAttribute(img, 'src', getAttribute(img, SRC_DATA_NAME) || '');\n  }\n  /**\r\n   * Start loading a next image in images array.\r\n   */\n\n\n  function loadNext() {\n    if (nextIndex < images.length) {\n      var image = images[nextIndex];\n      load(image.img, image.Slide);\n    }\n\n    nextIndex++;\n  }\n  /**\r\n   * Called just after the image was loaded or loading was aborted by some error.\r\n   *\r\n   * @param {Element} img     - An image element.\r\n   * @param {Element} spinner - A spinner element.\r\n   * @param {Object}  Slide   - A Slide object.\r\n   * @param {boolean} error   - True if the image was loaded successfully or false on error.\r\n   */\n\n\n  function loaded(img, spinner, Slide, error) {\n    removeClass(Slide.slide, STATUS_CLASSES.loading);\n\n    if (!error) {\n      dom_remove(spinner);\n      applyStyle(img, {\n        display: ''\n      });\n      Splide.emit(name + \":loaded\", img).emit('resize');\n    }\n\n    if (isSequential) {\n      loadNext();\n    }\n  }\n\n  return Lazyload;\n});\n;// CONCATENATED MODULE: ./src/js/constants/a11y.js\n/**\r\n * Export aria attribute names.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n/**\r\n * Attribute name for aria-current.\r\n *\r\n * @type {string}\r\n */\nvar ARIA_CURRENRT = 'aria-current';\n/**\r\n * Attribute name for aria-control.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_CONTROLS = 'aria-controls';\n/**\r\n * Attribute name for aria-control.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_LABEL = 'aria-label';\n/**\r\n * Attribute name for aria-labelledby.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_LABELLEDBY = 'aria-labelledby';\n/**\r\n * Attribute name for aria-hidden.\r\n *\r\n * @type {string}\r\n */\n\nvar ARIA_HIDDEN = 'aria-hidden';\n/**\r\n * Attribute name for tab-index.\r\n *\r\n * @type {string}\r\n */\n\nvar TAB_INDEX = 'tabindex';\n;// CONCATENATED MODULE: ./src/js/components/keyboard/index.js\n/**\r\n * The component for controlling slides via keyboard.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Map a key to a slide control.\r\n *\r\n * @type {Object}\r\n */\n\nvar KEY_MAP = {\n  ltr: {\n    ArrowLeft: '<',\n    ArrowRight: '>',\n    // For IE.\n    Left: '<',\n    Right: '>'\n  },\n  rtl: {\n    ArrowLeft: '>',\n    ArrowRight: '<',\n    // For IE.\n    Left: '>',\n    Right: '<'\n  },\n  ttb: {\n    ArrowUp: '<',\n    ArrowDown: '>',\n    // For IE.\n    Up: '<',\n    Down: '>'\n  }\n};\n/**\r\n * The component for controlling slides via keyboard.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const keyboard = (function (Splide) {\n  /**\r\n   * Hold the target element.\r\n   *\r\n   * @type {Element|Document|undefined}\r\n   */\n  var target;\n  return {\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('mounted updated', function () {\n        var options = Splide.options;\n        var root = Splide.root;\n        var map = KEY_MAP[options.direction];\n        var keyboard = options.keyboard;\n\n        if (target) {\n          Splide.off('keydown', target);\n          removeAttribute(root, TAB_INDEX);\n        }\n\n        if (keyboard) {\n          if (keyboard === 'focused') {\n            target = root;\n            setAttribute(root, TAB_INDEX, 0);\n          } else {\n            target = document;\n          }\n\n          Splide.on('keydown', function (e) {\n            if (map[e.key]) {\n              Splide.go(map[e.key]);\n            }\n          }, target);\n        }\n      });\n    }\n  };\n});\n;// CONCATENATED MODULE: ./src/js/components/a11y/index.js\n/**\r\n * The component for enhancing accessibility.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n/**\r\n * The component for enhancing accessibility.\r\n *\r\n * @param {Splide} Splide     - A Splide instance.\r\n * @param {Object} Components - An object containing components.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const a11y = (function (Splide, Components) {\n  /**\r\n   * Hold a i18n object.\r\n   *\r\n   * @type {Object}\r\n   */\n  var i18n = Splide.i18n;\n  /**\r\n   * Hold the Elements component.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Elements = Components.Elements;\n  /**\r\n   * All attributes related with A11y.\r\n   *\r\n   * @type {string[]}\r\n   */\n\n  var allAttributes = [ARIA_HIDDEN, TAB_INDEX, ARIA_CONTROLS, ARIA_LABEL, ARIA_CURRENRT, 'role'];\n  /**\r\n   * A11y component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var A11y = {\n    /**\r\n     * Required only when the accessibility option is true.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: Splide.options.accessibility,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      Splide.on('visible', function (Slide) {\n        updateSlide(Slide.slide, true);\n      }).on('hidden', function (Slide) {\n        updateSlide(Slide.slide, false);\n      }).on('arrows:mounted', initArrows).on('arrows:updated', updateArrows).on('pagination:mounted', initPagination).on('pagination:updated', updatePagination).on('refresh', function () {\n        removeAttribute(Components.Clones.clones, allAttributes);\n      });\n\n      if (Splide.options.isNavigation) {\n        Splide.on('navigation:mounted navigation:updated', initNavigation).on('active', function (Slide) {\n          updateNavigation(Slide, true);\n        }).on('inactive', function (Slide) {\n          updateNavigation(Slide, false);\n        });\n      }\n\n      initAutoplay();\n    },\n\n    /**\r\n     * Destroy.\r\n     */\n    destroy: function destroy() {\n      var Arrows = Components.Arrows;\n      var arrows = Arrows ? Arrows.arrows : {};\n      removeAttribute(Elements.slides.concat([arrows.prev, arrows.next, Elements.play, Elements.pause]), allAttributes);\n    }\n  };\n  /**\r\n   * Update slide attributes when it gets visible or hidden.\r\n   *\r\n   * @param {Element} slide   - A slide element.\r\n   * @param {Boolean} visible - True when the slide gets visible, or false when hidden.\r\n   */\n\n  function updateSlide(slide, visible) {\n    setAttribute(slide, ARIA_HIDDEN, !visible);\n\n    if (Splide.options.slideFocus) {\n      setAttribute(slide, TAB_INDEX, visible ? 0 : -1);\n    }\n  }\n  /**\r\n   * Initialize arrows if they are available.\r\n   * Append screen reader elements and add aria-controls attribute.\r\n   *\r\n   * @param {Element} prev - Previous arrow element.\r\n   * @param {Element} next - Next arrow element.\r\n   */\n\n\n  function initArrows(prev, next) {\n    var controls = Elements.track.id;\n    setAttribute(prev, ARIA_CONTROLS, controls);\n    setAttribute(next, ARIA_CONTROLS, controls);\n  }\n  /**\r\n   * Update arrow attributes.\r\n   *\r\n   * @param {Element} prev      - Previous arrow element.\r\n   * @param {Element} next      - Next arrow element.\r\n   * @param {number}  prevIndex - Previous slide index or -1 when there is no precede slide.\r\n   * @param {number}  nextIndex - Next slide index or -1 when there is no next slide.\r\n   */\n\n\n  function updateArrows(prev, next, prevIndex, nextIndex) {\n    var index = Splide.index;\n    var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;\n    var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;\n    setAttribute(prev, ARIA_LABEL, prevLabel);\n    setAttribute(next, ARIA_LABEL, nextLabel);\n  }\n  /**\r\n   * Initialize pagination if it's available.\r\n   * Append a screen reader element and add aria-controls/label attribute to each item.\r\n   *\r\n   * @param {Object} data       - Data object containing all items.\r\n   * @param {Object} activeItem - An initial active item.\r\n   */\n\n\n  function initPagination(data, activeItem) {\n    if (activeItem) {\n      setAttribute(activeItem.button, ARIA_CURRENRT, true);\n    }\n\n    data.items.forEach(function (item) {\n      var options = Splide.options;\n      var text = options.focus === false && options.perPage > 1 ? i18n.pageX : i18n.slideX;\n      var label = sprintf(text, item.page + 1);\n      var button = item.button;\n      var controls = item.Slides.map(function (Slide) {\n        return Slide.slide.id;\n      });\n      setAttribute(button, ARIA_CONTROLS, controls.join(' '));\n      setAttribute(button, ARIA_LABEL, label);\n    });\n  }\n  /**\r\n   * Update pagination attributes.\r\n   *\r\n   * @param {Object}  data - Data object containing all items.\r\n   * @param {Element} prev - A previous active element.\r\n   * @param {Element} curr - A current active element.\r\n   */\n\n\n  function updatePagination(data, prev, curr) {\n    if (prev) {\n      removeAttribute(prev.button, ARIA_CURRENRT);\n    }\n\n    if (curr) {\n      setAttribute(curr.button, ARIA_CURRENRT, true);\n    }\n  }\n  /**\r\n   * Initialize autoplay buttons.\r\n   */\n\n\n  function initAutoplay() {\n    ['play', 'pause'].forEach(function (name) {\n      var elm = Elements[name];\n\n      if (elm) {\n        if (!isButton(elm)) {\n          setAttribute(elm, 'role', 'button');\n        }\n\n        setAttribute(elm, ARIA_CONTROLS, Elements.track.id);\n        setAttribute(elm, ARIA_LABEL, i18n[name]);\n      }\n    });\n  }\n  /**\r\n   * Initialize navigation slider.\r\n   * Add button role, aria-label, aria-controls to slide elements and append screen reader text to them.\r\n   *\r\n   * @param {Splide} main - A main Splide instance.\r\n   */\n\n\n  function initNavigation(main) {\n    Elements.each(function (Slide) {\n      var slide = Slide.slide;\n      var realIndex = Slide.realIndex;\n\n      if (!isButton(slide)) {\n        setAttribute(slide, 'role', 'button');\n      }\n\n      var slideIndex = realIndex > -1 ? realIndex : Slide.index;\n      var label = sprintf(i18n.slideX, slideIndex + 1);\n      var mainSlide = main.Components.Elements.getSlide(slideIndex);\n      setAttribute(slide, ARIA_LABEL, label);\n\n      if (mainSlide) {\n        setAttribute(slide, ARIA_CONTROLS, mainSlide.slide.id);\n      }\n    });\n  }\n  /**\r\n   * Update navigation attributes.\r\n   *\r\n   * @param {Object}  Slide  - A target Slide object.\r\n   * @param {boolean} active - True if the slide is active or false if inactive.\r\n   */\n\n\n  function updateNavigation(_ref, active) {\n    var slide = _ref.slide;\n\n    if (active) {\n      setAttribute(slide, ARIA_CURRENRT, true);\n    } else {\n      removeAttribute(slide, ARIA_CURRENRT);\n    }\n  }\n  /**\r\n   * Check if the given element is button or not.\r\n   *\r\n   * @param {Element} elm - An element to be checked.\r\n   *\r\n   * @return {boolean} - True if the given element is button.\r\n   */\n\n\n  function isButton(elm) {\n    return elm.tagName === 'BUTTON';\n  }\n\n  return A11y;\n});\n;// CONCATENATED MODULE: ./src/js/components/sync/index.js\n/**\r\n * The component for synchronizing a slider with another.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * The event name for sync.\r\n *\r\n * @type {string}\r\n */\n\nvar SYNC_EVENT = 'move.sync';\n/**\r\n * The event names for click navigation.\r\n * @type {string}\r\n */\n\nvar CLICK_EVENTS = 'mouseup touchend';\n/**\r\n * The keys for triggering the navigation button.\r\n *\r\n * @type {String[]}\r\n */\n\nvar TRIGGER_KEYS = [' ', 'Enter', 'Spacebar'];\n/**\r\n * The component for synchronizing a slider with another.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const sync = (function (Splide) {\n  /**\r\n   * Keep the sibling Splide instance.\r\n   *\r\n   * @type {Splide}\r\n   */\n  var sibling = Splide.sibling;\n  /**\r\n   * Whether the sibling slider is navigation or not.\r\n   *\r\n   * @type {Splide|boolean}\r\n   */\n\n  var isNavigation = sibling && sibling.options.isNavigation;\n  /**\r\n   * Layout component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Sync = {\n    /**\r\n     * Required only when the sub slider is available.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: !!sibling,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      syncMain();\n      syncSibling();\n\n      if (isNavigation) {\n        bind();\n        Splide.on('refresh', function () {\n          setTimeout(function () {\n            bind();\n            sibling.emit('navigation:updated', Splide);\n          });\n        });\n      }\n    },\n\n    /**\r\n     * Called after all components are mounted.\r\n     */\n    mounted: function mounted() {\n      if (isNavigation) {\n        sibling.emit('navigation:mounted', Splide);\n      }\n    }\n  };\n  /**\r\n   * Listen the primary slider event to move secondary one.\r\n   * Must unbind a handler at first to avoid infinite loop.\r\n   */\n\n  function syncMain() {\n    Splide.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n      sibling.off(SYNC_EVENT).go(sibling.is(LOOP) ? destIndex : newIndex, false);\n      syncSibling();\n    });\n  }\n  /**\r\n   * Listen the secondary slider event to move primary one.\r\n   * Must unbind a handler at first to avoid infinite loop.\r\n   */\n\n\n  function syncSibling() {\n    sibling.on(SYNC_EVENT, function (newIndex, prevIndex, destIndex) {\n      Splide.off(SYNC_EVENT).go(Splide.is(LOOP) ? destIndex : newIndex, false);\n      syncMain();\n    });\n  }\n  /**\r\n   * Listen some events on each slide.\r\n   */\n\n\n  function bind() {\n    sibling.Components.Elements.each(function (_ref) {\n      var slide = _ref.slide,\n          index = _ref.index;\n\n      /*\r\n       * Listen mouseup and touchend events to handle click.\r\n       */\n      Splide.off(CLICK_EVENTS, slide).on(CLICK_EVENTS, function (e) {\n        // Ignore a middle or right click.\n        if (!e.button || e.button === 0) {\n          moveSibling(index);\n        }\n      }, slide);\n      /*\r\n       * Subscribe keyup to handle Enter and Space key.\r\n       * Note that Array.includes is not supported by IE.\r\n       */\n\n      Splide.off('keyup', slide).on('keyup', function (e) {\n        if (TRIGGER_KEYS.indexOf(e.key) > -1) {\n          e.preventDefault();\n          moveSibling(index);\n        }\n      }, slide, {\n        passive: false\n      });\n    });\n  }\n  /**\r\n   * Move the sibling to the given index.\r\n   * Need to check \"IDLE\" status because slides can be moving by Drag component.\r\n   *\r\n   * @param {number} index - Target index.\r\n   */\n\n\n  function moveSibling(index) {\n    if (Splide.State.is(IDLE)) {\n      sibling.go(index);\n    }\n  }\n\n  return Sync;\n});\n;// CONCATENATED MODULE: ./src/js/components/breakpoints/index.js\n/**\r\n * The component for updating options according to a current window width.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Interval time for throttle.\r\n *\r\n * @type {number}\r\n */\n\nvar THROTTLE = 50;\n/**\r\n * The component for updating options according to a current window width.\r\n *\r\n * @param {Splide} Splide - A Splide instance.\r\n *\r\n * @return {Object} - The component object.\r\n */\n\n/* harmony default export */ const breakpoints = (function (Splide) {\n  /**\r\n   * Store breakpoints.\r\n   *\r\n   * @type {Object|boolean}\r\n   */\n  var breakpoints = Splide.options.breakpoints;\n  /**\r\n   * The check function whose frequency of call is reduced.\r\n   *\r\n   * @type {Function}\r\n   */\n\n  var throttledCheck = throttle(check, THROTTLE);\n  /**\r\n   * Keep initial options.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var initialOptions;\n  /**\r\n   * An array containing objects of point and MediaQueryList.\r\n   *\r\n   * @type {Object[]}\r\n   */\n\n  var map = [];\n  /**\r\n   * Hold the previous breakpoint.\r\n   *\r\n   * @type {number|undefined}\r\n   */\n\n  var prevPoint;\n  /**\r\n   * Breakpoints component object.\r\n   *\r\n   * @type {Object}\r\n   */\n\n  var Breakpoints = {\n    /**\r\n     * Required only when the breakpoints definition is provided and browser supports matchMedia.\r\n     *\r\n     * @type {boolean}\r\n     */\n    required: breakpoints && matchMedia,\n\n    /**\r\n     * Called when the component is mounted.\r\n     */\n    mount: function mount() {\n      map = Object.keys(breakpoints).sort(function (n, m) {\n        return +n - +m;\n      }).map(function (point) {\n        return {\n          point: point,\n          mql: matchMedia(\"(max-width:\" + point + \"px)\")\n        };\n      });\n      /*\r\n       * To keep monitoring resize event after destruction without \"completely\",\r\n       * use native addEventListener instead of Splide.on.\r\n       */\n\n      this.destroy(true);\n      addEventListener('resize', throttledCheck); // Keep initial options to apply them when no breakpoint matches.\n\n      initialOptions = Splide.options;\n      check();\n    },\n\n    /**\r\n     * Destroy.\r\n     *\r\n     * @param {boolean} completely - Whether to destroy Splide completely.\r\n     */\n    destroy: function destroy(completely) {\n      if (completely) {\n        removeEventListener('resize', throttledCheck);\n      }\n    }\n  };\n  /**\r\n   * Check the breakpoint.\r\n   */\n\n  function check() {\n    var point = getPoint();\n\n    if (point !== prevPoint) {\n      prevPoint = point;\n      var State = Splide.State;\n      var options = breakpoints[point] || initialOptions;\n      var destroy = options.destroy;\n\n      if (destroy) {\n        Splide.options = initialOptions;\n        Splide.destroy(destroy === 'completely');\n      } else {\n        if (State.is(DESTROYED)) {\n          Splide.mount();\n        }\n\n        Splide.options = options;\n      }\n    }\n  }\n  /**\r\n   * Return the breakpoint matching current window width.\r\n   * Note that Array.prototype.find is not supported by IE.\r\n   *\r\n   * @return {number|string} - A breakpoint as number or string. -1 if no point matches.\r\n   */\n\n\n  function getPoint() {\n    var item = map.filter(function (item) {\n      return item.mql.matches;\n    })[0];\n    return item ? item.point : -1;\n  }\n\n  return Breakpoints;\n});\n;// CONCATENATED MODULE: ./src/js/components/index.js\n/**\r\n * Export components.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar COMPLETE = {\n  Options: options,\n  Breakpoints: breakpoints,\n  Controller: controller,\n  Elements: components_elements,\n  Track: track,\n  Clones: clones,\n  Layout: layout,\n  Drag: drag,\n  Click: click,\n  Autoplay: autoplay,\n  Cover: cover,\n  Arrows: arrows,\n  Pagination: pagination,\n  LazyLoad: lazyload,\n  Keyboard: keyboard,\n  Sync: sync,\n  A11y: a11y\n};\nvar LIGHT = {\n  Options: options,\n  Controller: controller,\n  Elements: components_elements,\n  Track: track,\n  Clones: clones,\n  Layout: layout,\n  Drag: drag,\n  Click: click,\n  Arrows: arrows,\n  Pagination: pagination,\n  A11y: a11y\n};\n;// CONCATENATED MODULE: ./build/module/module.js\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\r\n * Export Splide class for import.\r\n *\r\n * @author    Naotoshi Fujita\r\n * @copyright Naotoshi Fujita. All rights reserved.\r\n */\n\n\n/**\r\n * Export Splide class for import from other projects.\r\n */\n\nvar module_Splide = /*#__PURE__*/function (_Core) {\n  _inheritsLoose(Splide, _Core);\n\n  function Splide(root, options) {\n    return _Core.call(this, root, options, COMPLETE) || this;\n  }\n\n  return Splide;\n}(Splide);\n\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(__webpack_module_cache__[moduleId]) {\n/******/ \t\t\treturn __webpack_module_cache__[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__webpack_require__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t// module exports must be returned from runtime so entry inlining is disabled\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(311);\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzcGxpZGVqcy9zcGxpZGUvZGlzdC9qcy9zcGxpZGUuZXNtLmpzPzRhMzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUt1QjtBQUM3QixDQUFDO0FBQ0Qsd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qix3RkFBd0YsVUFBVTtBQUNsRyxlQUFlLFNBQVM7QUFDeEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQSw0RkFBNEYsYUFBYTtBQUN6RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxQkFBcUI7QUFDN0IsUUFBUSxxQkFBcUI7QUFDN0I7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSxDQUFDO0FBQ0QsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBLGFBQWEsZUFBZTtBQUM1QixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGNBQWMsaUJBQWlCO0FBQy9COzs7QUFHQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixzRkFBc0YsVUFBVTtBQUNoRyxhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwRkFBMEYsYUFBYTtBQUN2RztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7O0FBR0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7O0FBR1A7QUFDQTtBQUNBLE9BQU8sRUFBRTs7QUFFVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsWUFBWSxFQUFFO0FBQ2QsWUFBWSxFQUFFO0FBQ2QsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBLFlBQVksRUFBRTtBQUNkO0FBQ0EsZUFBZSxjQUFjO0FBQzdCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GOztBQUVuRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQseUNBQXlDO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsa0JBQWtCO0FBQ25GO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9Ac3BsaWRlanMvc3BsaWRlL2Rpc3QvanMvc3BsaWRlLmVzbS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogU3BsaWRlLmpzXG4gKiBWZXJzaW9uICA6IDIuNC4yMFxuICogTGljZW5zZSAgOiBNSVRcbiAqIENvcHlyaWdodDogMjAyMCBOYW90b3NoaSBGdWppdGFcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiU3BsaWRlXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIlNwbGlkZVwiXSA9IGZhY3RvcnkoKTtcbn0pKHNlbGYsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gMzExOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyBFU00gQ09NUEFUIEZMQUdcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgXCJkZWZhdWx0XCI6ICgpID0+IC8qIGJpbmRpbmcgKi8gbW9kdWxlX1NwbGlkZVxufSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vc3JjL2pzL2NvbnN0YW50cy9zdGF0ZXMuanNcbnZhciBzdGF0ZXNfbmFtZXNwYWNlT2JqZWN0ID0ge307XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoc3RhdGVzX25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoc3RhdGVzX25hbWVzcGFjZU9iamVjdCwge1xuICBcIkNSRUFURURcIjogKCkgPT4gQ1JFQVRFRCxcbiAgXCJERVNUUk9ZRURcIjogKCkgPT4gREVTVFJPWUVELFxuICBcIklETEVcIjogKCkgPT4gSURMRSxcbiAgXCJNT1VOVEVEXCI6ICgpID0+IE1PVU5URUQsXG4gIFwiTU9WSU5HXCI6ICgpID0+IE1PVklOR1xufSk7XG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb3JlL2V2ZW50LmpzXG4vKipcclxuICogVGhlIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYW4gRXZlbnQgb2JqZWN0IHNpbXBseSBtYW5hZ2luZyBldmVudHMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIFRoZSBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGFuIEV2ZW50IG9iamVjdCBzaW1wbHkgbWFuYWdpbmcgZXZlbnRzLlxyXG4gKi9cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29yZV9ldmVudCA9IChmdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIFN0b3JlIGFsbCBldmVudCBkYXRhLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0FycmF5fVxyXG4gICAqL1xuICB2YXIgZGF0YSA9IFtdO1xuICB2YXIgRXZlbnQgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBTdWJzY3JpYmUgdGhlIGdpdmVuIGV2ZW50KHMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgIGV2ZW50cyAgLSBBbiBldmVudCBuYW1lLiBVc2Ugc3BhY2UgdG8gc2VwYXJhdGUgbXVsdGlwbGUgZXZlbnRzLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsc28sIG5hbWVzcGFjZSBpcyBhY2NlcHRlZCBieSBkb3QsIHN1Y2ggYXMgJ3Jlc2l6ZS57bmFtZXNwYWNlfScuXHJcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gQSBjYWxsYmFjayBmdW5jdGlvbi5cclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gIGVsbSAgICAgLSBPcHRpb25hbC4gTmF0aXZlIGV2ZW50IHdpbGwgYmUgbGlzdGVuZWQgdG8gd2hlbiB0aGlzIGFyZyBpcyBwcm92aWRlZC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAgIG9wdGlvbnMgLSBPcHRpb25hbC4gT3B0aW9ucyBmb3IgYWRkRXZlbnRMaXN0ZW5lci5cclxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbiBvbihldmVudHMsIGhhbmRsZXIsIGVsbSwgb3B0aW9ucykge1xuICAgICAgaWYgKGVsbSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGVsbSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuXG4gICAgICBldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZWxtKSB7XG4gICAgICAgICAgZWxtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5wdXNoKHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgICBlbG06IGVsbSxcbiAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmUgdGhlIGdpdmVuIGV2ZW50KHMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgZXZlbnRzIC0gQSBldmVudCBuYW1lIG9yIG5hbWVzIHNwbGl0IGJ5IHNwYWNlLlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbG0gICAgLSBPcHRpb25hbC4gcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhpcyBhcmcgaXMgcHJvdmlkZWQuXHJcbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uIG9mZihldmVudHMsIGVsbSkge1xuICAgICAgaWYgKGVsbSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGVsbSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50cy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIGlmIChpdGVtICYmIGl0ZW0uZXZlbnQgPT09IGV2ZW50ICYmIGl0ZW0uZWxtID09PSBlbG0pIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIEVtaXQgYW4gZXZlbnQuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBvbmx5IGZvciBjdXN0b20gZXZlbnRzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSAgZXZlbnQgLSBBbiBldmVudCBuYW1lLlxyXG4gICAgICogQHBhcmFtIHsqfSAgICAgICBhcmdzICAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHBhc3NlZCB0byBoYW5kbGVycy5cclxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoIWl0ZW0uZWxtICYmIGl0ZW0uZXZlbnQuc3BsaXQoJy4nKVswXSA9PT0gZXZlbnQpIHtcbiAgICAgICAgICBpdGVtLmhhbmRsZXIuYXBwbHkoaXRlbSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENsZWFyIGV2ZW50IGRhdGEuXHJcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgZGF0YS5mb3JFYWNoKHVuc3Vic2NyaWJlKTtcbiAgICAgIGRhdGEgPSBbXTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgZXZlbnQgZGF0YS5cclxuICAgKi9cblxuICBmdW5jdGlvbiB1bnN1YnNjcmliZShpdGVtKSB7XG4gICAgaWYgKGl0ZW0uZWxtKSB7XG4gICAgICBpdGVtLmVsbS5yZW1vdmVFdmVudExpc3RlbmVyKGl0ZW0uZXZlbnQsIGl0ZW0uaGFuZGxlciwgaXRlbS5vcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gRXZlbnQ7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb3JlL3N0YXRlLmpzXG4vKipcclxuICogVGhlIGZ1bmN0aW9uIHByb3ZpZGluZyBhIHN1cGVyIHNpbXBsZSBzdGF0ZSBzeXN0ZW0uXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIFRoZSBmdW5jdGlvbiBwcm92aWRpbmcgYSBzdXBlciBzaW1wbGUgc3RhdGUgc3lzdGVtLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGluaXRpYWxTdGF0ZSAtIFByb3ZpZGUgdGhlIGluaXRpYWwgc3RhdGUgdmFsdWUuXHJcbiAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBzdGF0ZSA9IChmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gIC8qKlxyXG4gICAqIFN0b3JlIHRoZSBjdXJyZW50IHN0YXRlLlxyXG4gICAqXHJcbiAgICogQHR5cGUge3N0cmluZ3xudW1iZXJ9XHJcbiAgICovXG4gIHZhciBjdXJyID0gaW5pdGlhbFN0YXRlO1xuICByZXR1cm4ge1xuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlIHN0YXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gc3RhdGUgLSBBIG5ldyBzdGF0ZS5cclxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgICBjdXJyID0gc3RhdGU7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogVmVyaWZ5IGlmIHRoZSBjdXJyZW50IHN0YXRlIGlzIGdpdmVuIG9uZSBvciBub3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBzdGF0ZSAtIEEgc3RhdGUgbmFtZSB0byBiZSB2ZXJpZmllZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdGhlIGdpdmVuIG9uZS5cclxuICAgICAqL1xuICAgIGlzOiBmdW5jdGlvbiBpcyhzdGF0ZSkge1xuICAgICAgcmV0dXJuIHN0YXRlID09PSBjdXJyO1xuICAgIH1cbiAgfTtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL3V0aWxzL29iamVjdC5qc1xuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuLyoqXHJcbiAqIFNvbWUgdXRpbGl0eSBmdW5jdGlvbnMgcmVsYXRlZCB3aXRoIE9iamVjdCwgc3VwcG9ydGluZyBJRS5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xudmFyIGtleXMgPSBPYmplY3Qua2V5cztcbi8qKlxyXG4gKiBJdGVyYXRlIGFuIG9iamVjdCBsaWtlIEFycmF5LmZvckVhY2guXHJcbiAqIElFIGRvZXNuJ3Qgc3VwcG9ydCBmb3JFYWNoIG9mIEhUTUxDb2xsZWN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gICAgb2JqICAgICAgIC0gQW4gb2JqZWN0LlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSAgY2FsbGJhY2sgIC0gQSBmdW5jdGlvbiBoYW5kbGluZyBlYWNoIHZhbHVlLiBBcmd1bWVudHMgYXJlIHZhbHVlLCBwcm9wZXJ0eSBhbmQgaW5kZXguXHJcbiAqL1xuXG5mdW5jdGlvbiBlYWNoKG9iaiwgY2FsbGJhY2spIHtcbiAga2V5cyhvYmopLnNvbWUoZnVuY3Rpb24gKGtleSwgaW5kZXgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sob2JqW2tleV0sIGtleSwgaW5kZXgpO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBSZXR1cm4gdmFsdWVzIG9mIHRoZSBnaXZlbiBvYmplY3QgYXMgYW4gYXJyYXkuXHJcbiAqIElFIGRvZXNuJ3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gQW4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtBcnJheX0gLSBBbiBhcnJheSBjb250YWluaW5nIGFsbCB2YWx1ZXMgb2YgdGhlIGdpdmVuIG9iamVjdC5cclxuICovXG5cbmZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcbiAgcmV0dXJuIGtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfSk7XG59XG4vKipcclxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHN1YmplY3QgaXMgb2JqZWN0IG9yIG5vdC5cclxuICpcclxuICogQHBhcmFtIHsqfSBzdWJqZWN0IC0gQSBzdWJqZWN0IHRvIGJlIHZlcmlmaWVkLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdChzdWJqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCc7XG59XG4vKipcclxuICogTWVyZ2UgdHdvIG9iamVjdHMgZGVlcGx5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gdG8gICAtIEFuIG9iamVjdCB3aGVyZSBcImZyb21cIiBpcyBtZXJnZWQuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmcm9tIC0gQW4gb2JqZWN0IG1lcmdlZCB0byBcInRvXCIuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBBIG1lcmdlZCBvYmplY3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBtZXJnZShfcmVmLCBmcm9tKSB7XG4gIHZhciB0byA9IF9leHRlbmRzKHt9LCBfcmVmKTtcblxuICBlYWNoKGZyb20sIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgaWYgKCFpc09iamVjdCh0b1trZXldKSkge1xuICAgICAgICB0b1trZXldID0ge307XG4gICAgICB9XG5cbiAgICAgIHRvW2tleV0gPSBtZXJnZSh0b1trZXldLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdG87XG59XG4vKipcclxuICogQXNzaWduIGFsbCBwcm9wZXJ0aWVzIFwiZnJvbVwiIHRvIFwidG9cIiBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0byAgIC0gQW4gb2JqZWN0IHdoZXJlIHByb3BlcnRpZXMgYXJlIGFzc2lnbmVkLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZnJvbSAtIEFuIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBhc3NpZ25lZCB0byBcInRvXCIuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBBbiBhc3NpZ25lZCBvYmplY3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBvYmplY3RfYXNzaWduKHRvLCBmcm9tKSB7XG4gIGtleXMoZnJvbSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCF0b1trZXldKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodG8sIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihmcm9tLCBrZXkpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdG87XG59XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvdXRpbHMvdXRpbHMuanNcbi8qKlxyXG4gKiBBIHBhY2thZ2Ugb2Ygc29tZSBtaXNjZWxsYW5lb3VzIHV0aWxpdHkgZnVuY3Rpb25zLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiB2YWx1ZSB0byBhcnJheS5cclxuICpcclxuICogQHBhcmFtIHsqfSB2YWx1ZSAtIEFueSB2YWx1ZS5cclxuICpcclxuICogQHJldHVybiB7KltdfSAtIEFycmF5IGNvbnRhaW5pbmcgdGhlIGdpdmVuIHZhbHVlLlxyXG4gKi9cblxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59XG4vKipcclxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGJldHdlZW4gbWluIGFuZCBtYXguXHJcbiAqIE1pbiB3aWxsIGJlIHJldHVybmVkIHdoZW4gdGhlIHZhbHVlIGlzIGxlc3MgdGhhbiBtaW4gb3IgbWF4IHdpbGwgZG8gd2hlbiBncmVhdGVyIHRoYW4gbWF4LlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBBIG51bWJlciB0byBiZSBjaGVja2VkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbTEgICAgLSBNaW5pbXVtIG9yIG1heGltdW0gbnVtYmVyLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbTIgICAgLSBNYXhpbXVtIG9yIG1pbmltdW0gbnVtYmVyLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gQSB2YWx1ZSBpdHNlbGYsIG1pbiBvciBtYXguXHJcbiAqL1xuXG5mdW5jdGlvbiBiZXR3ZWVuKHZhbHVlLCBtMSwgbTIpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtMSA+IG0yID8gbTIgOiBtMSksIG0xID4gbTIgPyBtMSA6IG0yKTtcbn1cbi8qKlxyXG4gKiBUaGUgc3ByaW50ZiBtZXRob2Qgd2l0aCBtaW5pbXVtIGZ1bmN0aW9uYWxpdHkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICBmb3JtYXQgICAgICAgLSBUaGUgc3RyaW5nIGZvcm1hdC5cclxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHJlcGxhY2VtZW50cyAtIFJlcGxhY2VtZW50cyBhY2NlcHRpbmcgbXVsdGlwbGUgYXJndW1lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIENvbnZlcnRlZCBzdHJpbmcuXHJcbiAqL1xuXG5mdW5jdGlvbiBzcHJpbnRmKGZvcm1hdCwgcmVwbGFjZW1lbnRzKSB7XG4gIHZhciBpID0gMDtcbiAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkocmVwbGFjZW1lbnRzKVtpKytdO1xuICB9KTtcbn1cbi8qKlxyXG4gKiBBcHBlbmQgcHggdW5pdCB0byB0aGUgZ2l2ZW4gc3ViamVjdCBpZiBuZWNlc3NhcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgLSBBIHZhbHVlIHRoYXQgbWF5IG5vdCBpbmNsdWRlIGFuIHVuaXQuXHJcbiAqXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gLSBJZiB0aGUgdmFsdWUgaXMgc3RyaW5nLCByZXR1cm4gaXRzZWxmLlxyXG4gKiAgICAgICAgICAgICAgICAgICAgSWYgbnVtYmVyLCBkbyB2YWx1ZSArIFwicHhcIi4gQW4gZW1wdHkgc3RyaW5nLCBvdGhlcndpc2UuXHJcbiAqL1xuXG5mdW5jdGlvbiB1bml0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IDApIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgKyAncHgnO1xuICB9XG5cbiAgcmV0dXJuIHR5cGUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiAnJztcbn1cbi8qKlxyXG4gKiBQYWQgc3RhcnQgd2l0aCAwLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIC0gQSBudW1iZXIgdG8gYmUgZmlsbGVkIHdpdGggMC5cclxuICpcclxuICogQHJldHVybiB7c3RyaW5nfG51bWJlcn0gLSBQYWRkZWQgbnVtYmVyLlxyXG4gKi9cblxuZnVuY3Rpb24gcGFkKG51bWJlcikge1xuICByZXR1cm4gbnVtYmVyIDwgMTAgPyAnMCcgKyBudW1iZXIgOiBudW1iZXI7XG59XG4vKipcclxuICogQ29udmVydCB0aGUgZ2l2ZW4gdmFsdWUgdG8gcGl4ZWwuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgICAgcm9vdCAgLSBSb290IGVsZW1lbnQgd2hlcmUgYSBkdW1teSBkaXYgaXMgYXBwZW5kZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gdmFsdWUgLSBDU1MgdmFsdWUgdG8gYmUgY29udmVydGVkLCBzdWNoIGFzIDEwcmVtLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IC0gUGl4ZWwuXHJcbiAqL1xuXG5mdW5jdGlvbiB0b1BpeGVsKHJvb3QsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGRpdiA9IGNyZWF0ZSgnZGl2Jywge30pO1xuICAgIGFwcGx5U3R5bGUoZGl2LCB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpZHRoOiB2YWx1ZVxuICAgIH0pO1xuICAgIGFwcGVuZChyb290LCBkaXYpO1xuICAgIHZhbHVlID0gZGl2LmNsaWVudFdpZHRoO1xuICAgIGRvbV9yZW1vdmUoZGl2KTtcbiAgfVxuXG4gIHJldHVybiArdmFsdWUgfHwgMDtcbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy91dGlscy9kb20uanNcbi8qKlxyXG4gKiBTb21lIHV0aWxpdHkgZnVuY3Rpb25zIHJlbGF0ZWQgd2l0aCBET00uXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG4vKipcclxuICogRmluZCB0aGUgZmlyc3QgZWxlbWVudCBtYXRjaGluZyB0aGUgZ2l2ZW4gc2VsZWN0b3IuXHJcbiAqIEJlIGF3YXJlIHRoYXQgYWxsIHNlbGVjdG9ycyBhZnRlciBhIHNwYWNlIGFyZSBpZ25vcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR8Tm9kZX0gIGVsbSAgICAgICAtIEFuIGFuY2VzdG9yIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgc2VsZWN0b3IgIC0gRE9NU3RyaW5nLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtFbGVtZW50fG51bGx9IC0gQSBmb3VuZCBlbGVtZW50IG9yIG51bGwuXHJcbiAqL1xuXG5mdW5jdGlvbiBmaW5kKGVsbSwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIGVsbSA/IGVsbS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yLnNwbGl0KCcgJylbMF0pIDogbnVsbDtcbn1cbi8qKlxyXG4gKiBGaW5kIGEgZmlyc3QgY2hpbGQgaGF2aW5nIHRoZSBnaXZlbiB0YWcgb3IgY2xhc3MgbmFtZS5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnQgICAgICAgICAtIEEgcGFyZW50IGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgdGFnT3JDbGFzc05hbWUgLSBBIHRhZyBvciBjbGFzcyBuYW1lLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtFbGVtZW50fHVuZGVmaW5lZH0gLSBBIGZvdW5kIGVsZW1lbnQgb24gc3VjY2VzcyBvciB1bmRlZmluZWQgb24gZmFpbHVyZS5cclxuICovXG5cbmZ1bmN0aW9uIGNoaWxkKHBhcmVudCwgdGFnT3JDbGFzc05hbWUpIHtcbiAgcmV0dXJuIGNoaWxkcmVuKHBhcmVudCwgdGFnT3JDbGFzc05hbWUpWzBdO1xufVxuLyoqXHJcbiAqIFJldHVybiBjaGlsZSBlbGVtZW50cyB0aGF0IG1hdGNoZXMgdGhlIHByb3ZpZGVkIHRhZyBvciBjbGFzcyBuYW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudCAgICAgICAgIC0gQSBwYXJlbnQgZWxlbWVudC5cclxuICogQHBhcmFtIHtzdHJpbmd9ICB0YWdPckNsYXNzTmFtZSAtIEEgdGFnIG9yIGNsYXNzIG5hbWUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge0VsZW1lbnRbXX0gLSBGb3VuZCBlbGVtZW50cy5cclxuICovXG5cbmZ1bmN0aW9uIGNoaWxkcmVuKHBhcmVudCwgdGFnT3JDbGFzc05hbWUpIHtcbiAgaWYgKHBhcmVudCkge1xuICAgIHJldHVybiB2YWx1ZXMocGFyZW50LmNoaWxkcmVuKS5maWx0ZXIoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICByZXR1cm4gaGFzQ2xhc3MoY2hpbGQsIHRhZ09yQ2xhc3NOYW1lLnNwbGl0KCcgJylbMF0pIHx8IGNoaWxkLnRhZ05hbWUgPT09IHRhZ09yQ2xhc3NOYW1lO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIFtdO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhbiBlbGVtZW50IHdpdGggc29tZSBvcHRpb25hbCBhdHRyaWJ1dGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnICAgLSBBIHRhZyBuYW1lLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgLSBBbiBvYmplY3QgYW55IGF0dHJpYnV0ZSBwYWlycyBvZiBuYW1lIGFuZCB2YWx1ZS5cclxuICpcclxuICogQHJldHVybiB7RWxlbWVudH0gLSBBIGNyZWF0ZWQgZWxlbWVudC5cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSh0YWcsIGF0dHJzKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGVhY2goYXR0cnMsIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XG4gICAgcmV0dXJuIHNldEF0dHJpYnV0ZShlbG0sIGtleSwgdmFsdWUpO1xuICB9KTtcbiAgcmV0dXJuIGVsbTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIERPTSBub2RlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbCAtIEhUTUwgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtOb2RlfSAtIEEgY3JlYXRlZCBub2RlLlxyXG4gKi9cblxuZnVuY3Rpb24gZG9taWZ5KGh0bWwpIHtcbiAgdmFyIGRpdiA9IGNyZWF0ZSgnZGl2Jywge30pO1xuICBkaXYuaW5uZXJIVE1MID0gaHRtbDtcbiAgcmV0dXJuIGRpdi5maXJzdENoaWxkO1xufVxuLyoqXHJcbiAqIFJlbW92ZSBhIGdpdmVuIGVsZW1lbnQgZnJvbSBhIERPTSB0cmVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfSBlbG1zIC0gRWxlbWVudChzKSB0byBiZSByZW1vdmVkLlxyXG4gKi9cblxuZnVuY3Rpb24gZG9tX3JlbW92ZShlbG1zKSB7XG4gIHRvQXJyYXkoZWxtcykuZm9yRWFjaChmdW5jdGlvbiAoZWxtKSB7XG4gICAgaWYgKGVsbSkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsbS5wYXJlbnRFbGVtZW50O1xuICAgICAgcGFyZW50ICYmIHBhcmVudC5yZW1vdmVDaGlsZChlbG0pO1xuICAgIH1cbiAgfSk7XG59XG4vKipcclxuICogQXBwZW5kIGEgY2hpbGQgdG8gYSBnaXZlbiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudCAtIEEgcGFyZW50IGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gY2hpbGQgIC0gQW4gZWxlbWVudCB0byBiZSBhcHBlbmRlZC5cclxuICovXG5cbmZ1bmN0aW9uIGFwcGVuZChwYXJlbnQsIGNoaWxkKSB7XG4gIGlmIChwYXJlbnQpIHtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9XG59XG4vKipcclxuICogSW5zZXJ0IGFuIGVsZW1lbnQgYmVmb3JlIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fE5vZGV9IHJlZiAtIEEgcmVmZXJlbmNlIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgICBlbG0gLSBBbiBlbGVtZW50IHRvIGJlIGluc2VydGVkLlxyXG4gKi9cblxuZnVuY3Rpb24gYmVmb3JlKGVsbSwgcmVmKSB7XG4gIGlmIChlbG0gJiYgcmVmKSB7XG4gICAgdmFyIHBhcmVudCA9IHJlZi5wYXJlbnRFbGVtZW50O1xuICAgIHBhcmVudCAmJiBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsbSwgcmVmKTtcbiAgfVxufVxuLyoqXHJcbiAqIEFwcGx5IHN0eWxlcyB0byB0aGUgZ2l2ZW4gZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbG0gICAgIC0gQW4gZWxlbWVudCB3aGVyZSBzdHlsZXMgYXJlIGFwcGxpZWQuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSAgc3R5bGVzICAtIE9iamVjdCBjb250YWluaW5nIHN0eWxlcy5cclxuICovXG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZWxtLCBzdHlsZXMpIHtcbiAgaWYgKGVsbSkge1xuICAgIGVhY2goc3R5bGVzLCBmdW5jdGlvbiAodmFsdWUsIHByb3ApIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICBlbG0uc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuLyoqXHJcbiAqIEFkZCBvciByZW1vdmUgY2xhc3NlcyB0by9mcm9tIHRoZSBlbGVtZW50LlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBpbnRlcm5hbCB1c2FnZS5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSAgICAgICAgIGVsbSAgICAgLSBBbiBlbGVtZW50IHdoZXJlIGNsYXNzZXMgYXJlIGFkZGVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gY2xhc3NlcyAtIENsYXNzIG5hbWVzIGJlaW5nIGFkZGVkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgcmVtb3ZlICAtIFdoZXRoZXIgdG8gcmVtb3ZlIG9yIGFkZCBjbGFzc2VzLlxyXG4gKi9cblxuZnVuY3Rpb24gYWRkT3JSZW1vdmVDbGFzc2VzKGVsbSwgY2xhc3NlcywgcmVtb3ZlKSB7XG4gIGlmIChlbG0pIHtcbiAgICB0b0FycmF5KGNsYXNzZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGVsbS5jbGFzc0xpc3RbcmVtb3ZlID8gJ3JlbW92ZScgOiAnYWRkJ10obmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxyXG4gKiBBZGQgY2xhc3NlcyB0byB0aGUgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSAgICAgICAgICBlbG0gICAgIC0gQW4gZWxlbWVudCB3aGVyZSBjbGFzc2VzIGFyZSBhZGRlZC5cclxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119ICBjbGFzc2VzIC0gQ2xhc3MgbmFtZXMgYmVpbmcgYWRkZWQuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsbSwgY2xhc3Nlcykge1xuICBhZGRPclJlbW92ZUNsYXNzZXMoZWxtLCBjbGFzc2VzLCBmYWxzZSk7XG59XG4vKipcclxuICogUmVtb3ZlIGEgY2xhc3MgZnJvbSB0aGUgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSAgICAgICAgIGVsbSAgICAgLSBBbiBlbGVtZW50IHdoZXJlIGNsYXNzZXMgYXJlIHJlbW92ZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBjbGFzc2VzIC0gQSBjbGFzcyBuYW1lIGJlaW5nIHJlbW92ZWQuXHJcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbG0sIGNsYXNzZXMpIHtcbiAgYWRkT3JSZW1vdmVDbGFzc2VzKGVsbSwgY2xhc3NlcywgdHJ1ZSk7XG59XG4vKipcclxuICogVmVyaWZ5IGlmIHRoZSBwcm92aWRlZCBlbGVtZW50IGhhcyB0aGUgY2xhc3Mgb3Igbm90LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsbSAgICAgICAtIEFuIGVsZW1lbnQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgY2xhc3NOYW1lIC0gQSBjbGFzcyBuYW1lLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGVsZW1lbnQgaGFzIHRoZSBjbGFzcyBvciBmYWxzZSBpZiBub3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBoYXNDbGFzcyhlbG0sIGNsYXNzTmFtZSkge1xuICByZXR1cm4gISFlbG0gJiYgZWxtLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xufVxuLyoqXHJcbiAqIFNldCBhdHRyaWJ1dGUgdG8gdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gICAgICAgICAgICAgICAgIGVsbSAgIC0gQW4gZWxlbWVudCB3aGVyZSBhbiBhdHRyaWJ1dGUgaXMgYXNzaWduZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgIG5hbWUgIC0gQXR0cmlidXRlIG5hbWUuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcnxib29sZWFufSAgIHZhbHVlIC0gQXR0cmlidXRlIHZhbHVlLlxyXG4gKi9cblxuZnVuY3Rpb24gc2V0QXR0cmlidXRlKGVsbSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKGVsbSkge1xuICAgIGVsbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICB9XG59XG4vKipcclxuICogR2V0IGF0dHJpYnV0ZSBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsbSAgLSBBbiBlbGVtZW50IHdoZXJlIGFuIGF0dHJpYnV0ZSBpcyBhc3NpZ25lZC5cclxuICogQHBhcmFtIHtzdHJpbmd9ICBuYW1lIC0gQXR0cmlidXRlIG5hbWUuXHJcbiAqXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gLSBUaGUgdmFsdWUgb2YgdGhlIGdpdmVuIGF0dHJpYnV0ZSBpZiBhdmFpbGFibGUuIEFuIGVtcHR5IHN0cmluZyBpZiBub3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGUoZWxtLCBuYW1lKSB7XG4gIHJldHVybiBlbG0gPyBlbG0uZ2V0QXR0cmlidXRlKG5hbWUpIDogJyc7XG59XG4vKipcclxuICogUmVtb3ZlIGF0dHJpYnV0ZSBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfSBlbG1zICAtIEFuIGVsZW1lbnQgd2hlcmUgYW4gYXR0cmlidXRlIGlzIHJlbW92ZWQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSAgICAgIG5hbWVzIC0gQXR0cmlidXRlIG5hbWUuXHJcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVBdHRyaWJ1dGUoZWxtcywgbmFtZXMpIHtcbiAgdG9BcnJheShuYW1lcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHRvQXJyYXkoZWxtcykuZm9yRWFjaChmdW5jdGlvbiAoZWxtKSB7XG4gICAgICByZXR1cm4gZWxtICYmIGVsbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuLyoqXHJcbiAqIFJldHVybiB0aGUgUmVjdCBvYmplY3Qgb2YgdGhlIHByb3ZpZGVkIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSBlbG0gLSBBbiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtDbGllbnRSZWN0fERPTVJlY3R9IC0gQSByZWN0IG9iamVjdC5cclxuICovXG5cbmZ1bmN0aW9uIGdldFJlY3QoZWxtKSB7XG4gIHJldHVybiBlbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG59XG4vKipcclxuICogVHJpZ2dlciB0aGUgZ2l2ZW4gY2FsbGJhY2sgYWZ0ZXIgYWxsIGltYWdlcyBjb250YWluZWQgYnkgdGhlIGVsZW1lbnQgYXJlIGxvYWRlZC5cclxuICpcclxuICogQHBhcmFtIHtFbGVtZW50fSAgZWxtICAgICAgLSBFbGVtZW50IHRoYXQgbWF5IGNvbnRhaW4gaW1hZ2VzLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIGZpcmVkIHJpZ2h0IGFmdGVyIGFsbCBpbWFnZXMgYXJlIGxvYWRlZC5cclxuICovXG5cbmZ1bmN0aW9uIGxvYWRlZChlbG0sIGNhbGxiYWNrKSB7XG4gIHZhciBpbWFnZXMgPSBlbG0ucXVlcnlTZWxlY3RvckFsbCgnaW1nJyk7XG4gIHZhciBsZW5ndGggPSBpbWFnZXMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGgpIHtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIGVhY2goaW1hZ2VzLCBmdW5jdGlvbiAoaW1nKSB7XG4gICAgICBpbWcub25sb2FkID0gaW1nLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgrK2NvdW50ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFRyaWdnZXIgdGhlIGNhbGxiYWNrIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGlzIG5vIGltYWdlLlxuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb25zdGFudHMvdHlwZXMuanNcbi8qKlxyXG4gKiBFeHBvcnQgc2xpZGVyIHR5cGVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBOb3JtYWwgc2xpZGVyLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cbnZhciBTTElERSA9ICdzbGlkZSc7XG4vKipcclxuICogTG9vcCBhZnRlciB0aGUgbGFzdCBzbGlkZSBhbmQgYmVmb3JlIHRoZSBmaXJzdCBvbmUuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgTE9PUCA9ICdsb29wJztcbi8qKlxyXG4gKiBUaGUgdHJhY2sgZG9lc24ndCBtb3ZlLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIEZBREUgPSAnZmFkZSc7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvdHJhbnNpdGlvbnMvc2xpZGUvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBnZW5lcmFsIHNsaWRlIGVmZmVjdCB0cmFuc2l0aW9uLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGdlbmVyYWwgc2xpZGUgZWZmZWN0IHRyYW5zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBzbGlkZSA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzKSB7XG4gIC8qKlxyXG4gICAqIEhvbGQgdGhlIGxpc3QgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtFbGVtZW50fVxyXG4gICAqL1xuICB2YXIgbGlzdDtcbiAgLyoqXHJcbiAgICogSG9sZCB0aGUgb25FbmQgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICpcclxuICAgKiBAdHlwZSB7ZnVuY3Rpb259XHJcbiAgICovXG5cbiAgdmFyIGVuZENhbGxiYWNrO1xuICByZXR1cm4ge1xuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgbGlzdCA9IENvbXBvbmVudHMuRWxlbWVudHMubGlzdDtcbiAgICAgIFNwbGlkZS5vbigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldCA9PT0gbGlzdCAmJiBlbmRDYWxsYmFjaykge1xuICAgICAgICAgIGVuZENhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGxpc3QpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFN0YXJ0IHRyYW5zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICAgZGVzdEluZGV4IC0gRGVzdGluYXRpb24gc2xpZGUgaW5kZXggdGhhdCBtaWdodCBiZSBjbG9uZSdzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICAgbmV3SW5kZXggIC0gTmV3IGluZGV4LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICAgcHJldkluZGV4IC0gUHJldmlvdXMgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gICBjb29yZCAgICAgLSBEZXN0aW5hdGlvbiBjb29yZGluYXRlcy5cclxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRvbmUgICAgICAtIENhbGxiYWNrIGZ1bmN0aW9uIG11c3QgYmUgaW52b2tlZCB3aGVuIHRyYW5zaXRpb24gaXMgY29tcGxldGVkLlxyXG4gICAgICovXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGRlc3RJbmRleCwgbmV3SW5kZXgsIHByZXZJbmRleCwgY29vcmQsIGRvbmUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgICB2YXIgZWRnZUluZGV4ID0gQ29tcG9uZW50cy5Db250cm9sbGVyLmVkZ2VJbmRleDtcbiAgICAgIHZhciBzcGVlZCA9IG9wdGlvbnMuc3BlZWQ7XG4gICAgICBlbmRDYWxsYmFjayA9IGRvbmU7XG5cbiAgICAgIGlmIChTcGxpZGUuaXMoU0xJREUpKSB7XG4gICAgICAgIGlmIChwcmV2SW5kZXggPT09IDAgJiYgbmV3SW5kZXggPj0gZWRnZUluZGV4IHx8IHByZXZJbmRleCA+PSBlZGdlSW5kZXggJiYgbmV3SW5kZXggPT09IDApIHtcbiAgICAgICAgICBzcGVlZCA9IG9wdGlvbnMucmV3aW5kU3BlZWQgfHwgc3BlZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXBwbHlTdHlsZShsaXN0LCB7XG4gICAgICAgIHRyYW5zaXRpb246IFwidHJhbnNmb3JtIFwiICsgc3BlZWQgKyBcIm1zIFwiICsgb3B0aW9ucy5lYXNpbmcsXG4gICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoXCIgKyBjb29yZC54ICsgXCJweCxcIiArIGNvb3JkLnkgKyBcInB4KVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy90cmFuc2l0aW9ucy9mYWRlL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgZmFkZSB0cmFuc2l0aW9uLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGZhZGUgdHJhbnNpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGZhZGUgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cykge1xuICB2YXIgRmFkZSA9IHtcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqIEFwcGx5IHRyYW5zaXRpb24gc3R5bGUgdG8gdGhlIGZpcnN0IHNsaWRlLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgYXBwbHkoU3BsaWRlLmluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCB0cmFuc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgICBkZXN0SW5kZXggLSBEZXN0aW5hdGlvbiBzbGlkZSBpbmRleCB0aGF0IG1pZ2h0IGJlIGNsb25lJ3MuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gICAgbmV3SW5kZXggIC0gTmV3IGluZGV4LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICAgIHByZXZJbmRleCAtIFByZXZpb3VzIGluZGV4LlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9ICAgIGNvb3JkICAgICAtIERlc3RpbmF0aW9uIGNvb3JkaW5hdGVzLlxyXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gIGRvbmUgICAgICAtIENhbGxiYWNrIGZ1bmN0aW9uIG11c3QgYmUgaW52b2tlZCB3aGVuIHRyYW5zaXRpb24gaXMgY29tcGxldGVkLlxyXG4gICAgICovXG4gICAgc3RhcnQ6IGZ1bmN0aW9uIHN0YXJ0KGRlc3RJbmRleCwgbmV3SW5kZXgsIHByZXZJbmRleCwgY29vcmQsIGRvbmUpIHtcbiAgICAgIHZhciB0cmFjayA9IENvbXBvbmVudHMuRWxlbWVudHMudHJhY2s7XG4gICAgICBhcHBseVN0eWxlKHRyYWNrLCB7XG4gICAgICAgIGhlaWdodDogdW5pdCh0cmFjay5jbGllbnRIZWlnaHQpXG4gICAgICB9KTtcbiAgICAgIGFwcGx5KG5ld0luZGV4KTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGFwcGx5U3R5bGUodHJhY2ssIHtcbiAgICAgICAgICBoZWlnaHQ6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBBcHBseSB0cmFuc2l0aW9uIHN0eWxlIHRvIHRoZSBzbGlkZSBzcGVjaWZpZWQgYnkgdGhlIGdpdmVuIGluZGV4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQSBzbGlkZSBpbmRleC5cclxuICAgKi9cblxuICBmdW5jdGlvbiBhcHBseShpbmRleCkge1xuICAgIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgYXBwbHlTdHlsZShDb21wb25lbnRzLkVsZW1lbnRzLnNsaWRlc1tpbmRleF0sIHtcbiAgICAgIHRyYW5zaXRpb246IFwib3BhY2l0eSBcIiArIG9wdGlvbnMuc3BlZWQgKyBcIm1zIFwiICsgb3B0aW9ucy5lYXNpbmdcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBGYWRlO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvdHJhbnNpdGlvbnMvaW5kZXguanNcbi8qKlxyXG4gKiBFeHBvcnQgdHJhbnNpdGlvbiBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvcmUvY29tcG9zZXIuanNcbi8qKlxyXG4gKiBQcm92aWRlIGEgZnVuY3Rpb24gZm9yIGNvbXBvc2luZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG4vKipcclxuICogQ29tcG9zZSBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gICBTcGxpZGUgICAgIC0gU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gICBDb21wb25lbnRzIC0gQWRkaXRpb25hbCBjb21wb25lbnRzLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBUcmFuc2l0aW9uIC0gQ2hhbmdlIGNvbXBvbmVudCBmb3IgdHJhbnNpdGlvbi5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBjb21wb25lbnRzLlxyXG4gKi9cblxuZnVuY3Rpb24gY29tcG9zZShTcGxpZGUsIENvbXBvbmVudHMsIFRyYW5zaXRpb24pIHtcbiAgdmFyIGNvbXBvbmVudHMgPSB7fTtcbiAgZWFjaChDb21wb25lbnRzLCBmdW5jdGlvbiAoQ29tcG9uZW50LCBuYW1lKSB7XG4gICAgY29tcG9uZW50c1tuYW1lXSA9IENvbXBvbmVudChTcGxpZGUsIGNvbXBvbmVudHMsIG5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH0pO1xuXG4gIGlmICghVHJhbnNpdGlvbikge1xuICAgIFRyYW5zaXRpb24gPSBTcGxpZGUuaXMoRkFERSkgPyBmYWRlIDogc2xpZGU7XG4gIH1cblxuICBjb21wb25lbnRzLlRyYW5zaXRpb24gPSBUcmFuc2l0aW9uKFNwbGlkZSwgY29tcG9uZW50cyk7XG4gIHJldHVybiBjb21wb25lbnRzO1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL3V0aWxzL2Vycm9yLmpzXG4vKipcclxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIG91dHB1dHRpbmcgbG9ncy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogUHJlZml4IG9mIGFuIGVycm9yIG1hc3NhZ2UuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xudmFyIE1FU1NBR0VfUFJFRklYID0gJ1tTUExJREVdJztcbi8qKlxyXG4gKiBEaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb24gdGhlIGJyb3dzZXIgY29uc29sZS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBBbiBlcnJvciBtZXNzYWdlLlxyXG4gKi9cblxuZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICBjb25zb2xlLmVycm9yKE1FU1NBR0VfUFJFRklYICsgXCIgXCIgKyBtZXNzYWdlKTtcbn1cbi8qKlxyXG4gKiBDaGVjayBleGlzdGVuY2Ugb2YgdGhlIGdpdmVuIG9iamVjdCBhbmQgdGhyb3cgYW4gZXJyb3IgaWYgaXQgZG9lc24ndC5cclxuICpcclxuICogQHRocm93cyB7RXJyb3J9XHJcbiAqXHJcbiAqIEBwYXJhbSB7Kn0gICAgICBzdWJqZWN0IC0gQSBzdWJqZWN0IHRvIGJlIGNvbmZpcm1lZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBBbiBlcnJvciBtZXNzYWdlLlxyXG4gKi9cblxuZnVuY3Rpb24gZXhpc3Qoc3ViamVjdCwgbWVzc2FnZSkge1xuICBpZiAoIXN1YmplY3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb25zdGFudHMvY2xhc3Nlcy5qc1xuLyoqXHJcbiAqIEV4cG9ydCBjbGFzcyBuYW1lcy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogQSByb290IGNsYXNzIG5hbWUuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xudmFyIFJPT1QgPSAnc3BsaWRlJztcbi8qKlxyXG4gKiBUaGUgZGVmaW5pdGlvbiB0YWJsZSBvZiBhbGwgY2xhc3NlcyBmb3IgZWxlbWVudHMuXHJcbiAqIFRoZXkgbWlnaHQgYmUgbW9kaWZpZWQgYnkgb3B0aW9ucy5cclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICovXG5cbnZhciBFTEVNRU5UX0NMQVNTRVMgPSB7XG4gIHJvb3Q6IFJPT1QsXG4gIHNsaWRlcjogUk9PVCArIFwiX19zbGlkZXJcIixcbiAgdHJhY2s6IFJPT1QgKyBcIl9fdHJhY2tcIixcbiAgbGlzdDogUk9PVCArIFwiX19saXN0XCIsXG4gIHNsaWRlOiBST09UICsgXCJfX3NsaWRlXCIsXG4gIGNvbnRhaW5lcjogUk9PVCArIFwiX19zbGlkZV9fY29udGFpbmVyXCIsXG4gIGFycm93czogUk9PVCArIFwiX19hcnJvd3NcIixcbiAgYXJyb3c6IFJPT1QgKyBcIl9fYXJyb3dcIixcbiAgcHJldjogUk9PVCArIFwiX19hcnJvdy0tcHJldlwiLFxuICBuZXh0OiBST09UICsgXCJfX2Fycm93LS1uZXh0XCIsXG4gIHBhZ2luYXRpb246IFJPT1QgKyBcIl9fcGFnaW5hdGlvblwiLFxuICBwYWdlOiBST09UICsgXCJfX3BhZ2luYXRpb25fX3BhZ2VcIixcbiAgY2xvbmU6IFJPT1QgKyBcIl9fc2xpZGUtLWNsb25lXCIsXG4gIHByb2dyZXNzOiBST09UICsgXCJfX3Byb2dyZXNzXCIsXG4gIGJhcjogUk9PVCArIFwiX19wcm9ncmVzc19fYmFyXCIsXG4gIGF1dG9wbGF5OiBST09UICsgXCJfX2F1dG9wbGF5XCIsXG4gIHBsYXk6IFJPT1QgKyBcIl9fcGxheVwiLFxuICBwYXVzZTogUk9PVCArIFwiX19wYXVzZVwiLFxuICBzcGlubmVyOiBST09UICsgXCJfX3NwaW5uZXJcIixcbiAgc3I6IFJPT1QgKyBcIl9fc3JcIlxufTtcbi8qKlxyXG4gKiBEZWZpbml0aW9ucyBvZiBzdGF0dXMgY2xhc3Nlcy5cclxuICpcclxuICogQHR5cGUge09iamVjdH1cclxuICovXG5cbnZhciBTVEFUVVNfQ0xBU1NFUyA9IHtcbiAgYWN0aXZlOiAnaXMtYWN0aXZlJyxcbiAgdmlzaWJsZTogJ2lzLXZpc2libGUnLFxuICBsb2FkaW5nOiAnaXMtbG9hZGluZydcbn07XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29uc3RhbnRzL2kxOG4uanNcbi8qKlxyXG4gKiBFeHBvcnQgaTE4biB0ZXh0cyBhcyBvYmplY3QuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIFRleHRzIGZvciBpMThuLlxyXG4gKlxyXG4gKiBAdHlwZSB7T2JqZWN0fVxyXG4gKi9cbnZhciBJMThOID0ge1xuICBwcmV2OiAnUHJldmlvdXMgc2xpZGUnLFxuICBuZXh0OiAnTmV4dCBzbGlkZScsXG4gIGZpcnN0OiAnR28gdG8gZmlyc3Qgc2xpZGUnLFxuICBsYXN0OiAnR28gdG8gbGFzdCBzbGlkZScsXG4gIHNsaWRlWDogJ0dvIHRvIHNsaWRlICVzJyxcbiAgcGFnZVg6ICdHbyB0byBwYWdlICVzJyxcbiAgcGxheTogJ1N0YXJ0IGF1dG9wbGF5JyxcbiAgcGF1c2U6ICdQYXVzZSBhdXRvcGxheSdcbn07XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29uc3RhbnRzL2RlZmF1bHRzLmpzXG4vKipcclxuICogRXhwb3J0IGRlZmF1bHQgb3B0aW9ucy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cbnZhciBERUZBVUxUUyA9IHtcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIGEgc2xpZGVyIHR5cGUuXHJcbiAgICogLSAnc2xpZGUnOiBSZWd1bGFyIHNsaWRlci5cclxuICAgKiAtICdsb29wJyA6IENhcm91c2VsIHNsaWRlci5cclxuICAgKiAtICdmYWRlJyA6IENoYW5nZSBzbGlkZXMgd2l0aCBmYWRlIHRyYW5zaXRpb24uIHBlclBhZ2UsIGRyYWcgb3B0aW9ucyBhcmUgaWdub3JlZC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXG4gIHR5cGU6ICdzbGlkZScsXG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byByZXdpbmQgYSBzbGlkZXIgYmVmb3JlIHRoZSBmaXJzdCBzbGlkZSBvciBhZnRlciB0aGUgbGFzdCBvbmUuXHJcbiAgICogSW4gXCJsb29wXCIgbW9kZSwgdGhpcyBvcHRpb24gaXMgaWdub3JlZC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICByZXdpbmQ6IGZhbHNlLFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zaXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgc3BlZWQ6IDQwMCxcblxuICAvKipcclxuICAgKiBUcmFuc2l0aW9uIHNwZWVkIG9uIHJld2luZCBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICByZXdpbmRTcGVlZDogMCxcblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIHByZXZlbnQgYW55IGFjdGlvbnMgd2hpbGUgYSBzbGlkZXIgaXMgdHJhbnNpdGlvbmluZy5cclxuICAgKiBJZiBmYWxzZSwgbmF2aWdhdGlvbiwgZHJhZyBhbmQgc3dpcGUgd29yayB3aGlsZSB0aGUgc2xpZGVyIGlzIHJ1bm5pbmcuXHJcbiAgICogRXZlbiBzbywgaXQgd2lsbCBiZSBmb3JjZWQgdG8gd2FpdCBmb3IgdHJhbnNpdGlvbiBpbiBzb21lIGNhc2VzIGluIHRoZSBsb29wIG1vZGUgdG8gc2hpZnQgYSBzbGlkZXIuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgd2FpdEZvclRyYW5zaXRpb246IHRydWUsXG5cbiAgLyoqXHJcbiAgICogRGVmaW5lIHNsaWRlciBtYXggd2lkdGguXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICB3aWR0aDogMCxcblxuICAvKipcclxuICAgKiBEZWZpbmUgc2xpZGVyIGhlaWdodC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIGhlaWdodDogMCxcblxuICAvKipcclxuICAgKiBGaXggd2lkdGggb2Ygc2xpZGVzLiBDU1MgZm9ybWF0IGlzIGFsbG93ZWQgc3VjaCBhcyAxMGVtLCA4MCUgb3IgODB2dy5cclxuICAgKiBwZXJQYWdlIG51bWJlciB3aWxsIGJlIGlnbm9yZWQgd2hlbiB0aGlzIG9wdGlvbiBpcyBmYWxzeS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ8c3RyaW5nfVxyXG4gICAqL1xuICBmaXhlZFdpZHRoOiAwLFxuXG4gIC8qKlxyXG4gICAqIEZpeCBoZWlnaHQgb2Ygc2xpZGVzLiBDU1MgZm9ybWF0IGlzIGFsbG93ZWQgc3VjaCBhcyAxMGVtLCA4MHZoIGJ1dCAlIHVuaXQgaXMgbm90IGFjY2VwdGVkLlxyXG4gICAqIGhlaWdodFJhdGlvIG9wdGlvbiB3aWxsIGJlIGlnbm9yZWQgd2hlbiB0aGlzIG9wdGlvbiBpcyBmYWxzeS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ8c3RyaW5nfVxyXG4gICAqL1xuICBmaXhlZEhlaWdodDogMCxcblxuICAvKipcclxuICAgKiBEZXRlcm1pbmUgaGVpZ2h0IG9mIHNsaWRlcyBieSByYXRpbyB0byBhIHNsaWRlciB3aWR0aC5cclxuICAgKiBUaGlzIHdpbGwgYmUgaWdub3JlZCB3aGVuIHRoZSBmaXhlZEhlaWdodCBpcyBwcm92aWRlZC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIGhlaWdodFJhdGlvOiAwLFxuXG4gIC8qKlxyXG4gICAqIElmIHRydWUsIHNsaWRlIHdpZHRoIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB0aGUgZWxlbWVudCB3aWR0aCBpdHNlbGYuXHJcbiAgICogLSBwZXJQYWdlL3Blck1vdmUgc2hvdWxkIGJlIDEuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgYXV0b1dpZHRoOiBmYWxzZSxcblxuICAvKipcclxuICAgKiBJZiB0cnVlLCBzbGlkZSBoZWlnaHQgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IHRoZSBlbGVtZW50IHdpZHRoIGl0c2VsZi5cclxuICAgKiAtIHBlclBhZ2UvcGVyTW92ZSBzaG91bGQgYmUgMS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICBhdXRvSGVpZ2h0OiBmYWxzZSxcblxuICAvKipcclxuICAgKiBEZXRlcm1pbmUgaG93IG1hbnkgc2xpZGVzIHNob3VsZCBiZSBkaXNwbGF5ZWQgcGVyIHBhZ2UuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBwZXJQYWdlOiAxLFxuXG4gIC8qKlxyXG4gICAqIERldGVybWluZSBob3cgbWFueSBzbGlkZXMgc2hvdWxkIGJlIG1vdmVkIHdoZW4gYSBzbGlkZXIgZ29lcyB0byBuZXh0IG9yIHBlcnYuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBwZXJNb3ZlOiAwLFxuXG4gIC8qKlxyXG4gICAqIERldGVybWluZSBtYW51YWxseSBob3cgbWFueSBjbG9uZXMgc2hvdWxkIGJlIGdlbmVyYXRlZCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZS5cclxuICAgKiBUaGUgdG90YWwgbnVtYmVyIG9mIGNsb25lcyB3aWxsIGJlIHR3aWNlIG9mIHRoaXMgbnVtYmVyLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgY2xvbmVzOiAwLFxuXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGluZGV4LlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgc3RhcnQ6IDAsXG5cbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIHdoaWNoIHNsaWRlIHNob3VsZCBiZSBmb2N1c2VkIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBzbGlkZXMgaW4gYSBwYWdlLlxyXG4gICAqIEEgc3RyaW5nIFwiY2VudGVyXCIgaXMgYWNjZXB0YWJsZSBmb3IgY2VudGVyaW5nIHNsaWRlcy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufG51bWJlcnxzdHJpbmd9XHJcbiAgICovXG4gIGZvY3VzOiBmYWxzZSxcblxuICAvKipcclxuICAgKiBHYXAgYmV0d2VlbiBzbGlkZXMuIENTUyBmb3JtYXQgaXMgYWxsb3dlZCBzdWNoIGFzIDFlbS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ8c3RyaW5nfVxyXG4gICAqL1xuICBnYXA6IDAsXG5cbiAgLyoqXHJcbiAgICogU2V0IHBhZGRpbmctbGVmdC9yaWdodCBpbiBob3Jpem9udGFsIG1vZGUgb3IgcGFkZGluZy10b3AvYm90dG9tIGluIHZlcnRpY2FsIG9uZS5cclxuICAgKiBHaXZlIGEgc2luZ2xlIHZhbHVlIHRvIHNldCBhIHNhbWUgc2l6ZSBmb3IgYm90aCBzaWRlcyBvclxyXG4gICAqIGRvIGFuIG9iamVjdCBmb3IgZGlmZmVyZW50IHNpemVzLlxyXG4gICAqIEFsc28sIENTUyBmb3JtYXQgaXMgYWxsb3dlZCBzdWNoIGFzIDFlbS5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICogLSAxMDogTnVtYmVyXHJcbiAgICogLSAnMWVtJzogQ1NTIGZvcm1hdC5cclxuICAgKiAtIHsgbGVmdDogMCwgcmlnaHQ6IDIwIH06IE9iamVjdCBmb3IgZGlmZmVyZW50IHNpemVzIGluIGhvcml6b250YWwgbW9kZS5cclxuICAgKiAtIHsgdG9wOiAwLCBib3R0b206IDIwIH06IE9iamVjdCBmb3IgZGlmZmVyZW50IHNpemVzIGluIHZlcnRpY2FsIG1vZGUuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfHN0cmluZ3xPYmplY3R9XHJcbiAgICovXG4gIHBhZGRpbmc6IDAsXG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBhcHBlbmQgYXJyb3dzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIGFycm93czogdHJ1ZSxcblxuICAvKipcclxuICAgKiBDaGFuZ2UgdGhlIGFycm93IFNWRyBwYXRoIGxpa2UgJ203LjYxIDAuODA3LTIuMTIuLi4nLlxyXG4gICAqXHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cbiAgYXJyb3dQYXRoOiAnJyxcblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIGFwcGVuZCBwYWdpbmF0aW9uKGluZGljYXRvciBkb3RzKSBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgcGFnaW5hdGlvbjogdHJ1ZSxcblxuICAvKipcclxuICAgKiBBY3RpdmF0ZSBhdXRvcGxheS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICBhdXRvcGxheTogZmFsc2UsXG5cbiAgLyoqXHJcbiAgICogQXV0b3BsYXkgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgaW50ZXJ2YWw6IDUwMDAsXG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBzdG9wIGF1dG9wbGF5IHdoZW4gYSBzbGlkZXIgaXMgaG92ZXJlZC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICBwYXVzZU9uSG92ZXI6IHRydWUsXG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBzdG9wIGF1dG9wbGF5IHdoZW4gYSBzbGlkZXIgZWxlbWVudHMgYXJlIGZvY3VzZWQuXHJcbiAgICogVHJ1ZSBpcyByZWNvbW1lbmRlZCBmb3IgYWNjZXNzaWJpbGl0eS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICBwYXVzZU9uRm9jdXM6IHRydWUsXG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byByZXNldCBwcm9ncmVzcyBvZiB0aGUgYXV0b3BsYXkgdGltZXIgd2hlbiByZXN1bWVkLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIHJlc2V0UHJvZ3Jlc3M6IHRydWUsXG5cbiAgLyoqXHJcbiAgICogTG9hZGluZyBpbWFnZXMgbGF6aWx5LlxyXG4gICAqIEltYWdlIHNyYyBtdXN0IGJlIHByb3ZpZGVkIGJ5IGEgZGF0YS1zcGxpZGUtbGF6eSBhdHRyaWJ1dGUuXHJcbiAgICpcclxuICAgKiAtIGZhbHNlOiBEbyBub3RoaW5nLlxyXG4gICAqIC0gJ25lYXJieSc6IE9ubHkgaW1hZ2VzIGFyb3VuZCBhbiBhY3RpdmUgc2xpZGUgd2lsbCBiZSBsb2FkZWQuXHJcbiAgICogLSAnc2VxdWVudGlhbCc6IEFsbCBpbWFnZXMgd2lsbCBiZSBzZXF1ZW50aWFsbHkgbG9hZGVkLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW58c3RyaW5nfVxyXG4gICAqL1xuICBsYXp5TG9hZDogZmFsc2UsXG5cbiAgLyoqXHJcbiAgICogVGhpcyBvcHRpb24gd29ya3Mgb25seSB3aGVuIGEgbGF6eUxvYWQgb3B0aW9uIGlzIFwibmVhcmJ5XCIuXHJcbiAgICogRGV0ZXJtaW5lIGhvdyBtYW55IHBhZ2VzKG5vdCBzbGlkZXMpIGFyb3VuZCBhbiBhY3RpdmUgc2xpZGUgc2hvdWxkIGJlIGxvYWRlZCBiZWZvcmVoYW5kLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgcHJlbG9hZFBhZ2VzOiAxLFxuXG4gIC8qKlxyXG4gICAqIEVhc2luZyBmb3IgQ1NTIHRyYW5zaXRpb24uIEZvciBleGFtcGxlLCBsaW5lYXIsIGVhc2Ugb3IgY3ViaWMtYmV6aWVyKCkuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xuICBlYXNpbmc6ICdjdWJpYy1iZXppZXIoLjQyLC42NSwuMjcsLjk5KScsXG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBlbmFibGUga2V5Ym9hcmQgc2hvcnRjdXRzXHJcbiAgICogLSB0cnVlIG9yICdnbG9iYWwnOiBMaXN0ZW4gdG8ga2V5ZG93biBldmVudCBvZiB0aGUgZG9jdW1lbnQuXHJcbiAgICogLSAnZm9jdXNlZCc6IExpc3RlbiB0byB0aGUga2V5ZG93biBldmVudCBvZiB0aGUgc2xpZGVyIHJvb3QgZWxlbWVudC4gdGFiaW5kZXg9XCIwXCIgd2lsbCBiZSBhZGRlZCB0byB0aGUgZWxlbWVudC5cclxuICAgKiAtIGZhbHNlOiBEaXNhYmxlIGtleWJvYXJkIHNob3J0Y3V0cy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufHN0cmluZ31cclxuICAgKi9cbiAga2V5Ym9hcmQ6ICdnbG9iYWwnLFxuXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gYWxsb3cgbW91c2UgZHJhZyBhbmQgdG91Y2ggc3dpcGUuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgZHJhZzogdHJ1ZSxcblxuICAvKipcclxuICAgKiBUaGUgYW5nbGUgdGhyZXNob2xkIGZvciBkcmFnLlxyXG4gICAqIFRoZSBzbGlkZXIgc3RhcnRzIG1vdmluZyBvbmx5IHdoZW4gdGhlIGRyYWcgYW5nbGUgaXMgbGVzcyB0aGFuIHRoaXMgdGhyZXNob2xkLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgZHJhZ0FuZ2xlVGhyZXNob2xkOiAzMCxcblxuICAvKipcclxuICAgKiBEaXN0YW5jZSB0aHJlc2hvbGQgZm9yIGRldGVybWluaW5nIGlmIHRoZSBhY3Rpb24gaXMgXCJmbGlja1wiIG9yIFwic3dpcGVcIi5cclxuICAgKiBXaGVuIGEgZHJhZyBkaXN0YW5jZSBpcyBvdmVyIHRoaXMgdmFsdWUsIHRoZSBhY3Rpb24gd2lsbCBiZSB0cmVhdGVkIGFzIFwic3dpcGVcIiwgbm90IFwiZmxpY2tcIi5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIHN3aXBlRGlzdGFuY2VUaHJlc2hvbGQ6IDE1MCxcblxuICAvKipcclxuICAgKiBWZWxvY2l0eSB0aHJlc2hvbGQgZm9yIGRldGVybWluaW5nIGlmIHRoZSBhY3Rpb24gaXMgXCJmbGlja1wiIG9yIFwic3dpcGVcIi5cclxuICAgKiBBcm91bmQgMC41IGlzIHJlY29tbWVuZGVkLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cbiAgZmxpY2tWZWxvY2l0eVRocmVzaG9sZDogLjYsXG5cbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lIHBvd2VyIG9mIGZsaWNrLiBUaGUgbGFyZ2VyIG51bWJlciB0aGlzIGlzLCB0aGUgZmFydGhlciBhIHNsaWRlciBydW5zIGJ5IGZsaWNrLlxyXG4gICAqIEFyb3VuZCA1MDAgaXMgcmVjb21tZW5kZWQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuICBmbGlja1Bvd2VyOiA2MDAsXG5cbiAgLyoqXHJcbiAgICogTGltaXQgYSBudW1iZXIgb2YgcGFnZXMgdG8gbW92ZSBieSBmbGljay5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIGZsaWNrTWF4UGFnZXM6IDEsXG5cbiAgLyoqXHJcbiAgICogU2xpZGVyIGRpcmVjdGlvbi5cclxuICAgKiAtICdsdHInOiBMZWZ0IHRvIHJpZ2h0LlxyXG4gICAqIC0gJ3J0bCc6IFJpZ2h0IHRvIGxlZnQuXHJcbiAgICogLSAndHRiJzogVG9wIHRvIGJvdHRvbS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXG4gIGRpcmVjdGlvbjogJ2x0cicsXG5cbiAgLyoqXHJcbiAgICogU2V0IGltZyBzcmMgdG8gYmFja2dyb3VuZC1pbWFnZSBvZiBpdHMgcGFyZW50IGVsZW1lbnQuXHJcbiAgICogSW1hZ2VzIHdpdGggdmFyaW91cyBzaXplcyBjYW4gYmUgZGlzcGxheWVkIGFzIHNhbWUgZGltZW5zaW9uIHdpdGhvdXQgY3JvcHBpbmcgd29yay5cclxuICAgKiBmaXhlZEhlaWdodCBvciBoZWlnaHRSYXRpbyBpcyByZXF1aXJlZC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICBjb3ZlcjogZmFsc2UsXG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBlbmFibGUgYWNjZXNzaWJpbGl0eShhcmlhIGFuZCBzY3JlZW4gcmVhZGVyIHRleHRzKSBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgYWNjZXNzaWJpbGl0eTogdHJ1ZSxcblxuICAvKipcclxuICAgKiBXaGV0aGVyIHRvIGFkZCB0YWJpbmRleD1cIjBcIiB0byB2aXNpYmxlIHNsaWRlcyBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cbiAgc2xpZGVGb2N1czogdHJ1ZSxcblxuICAvKipcclxuICAgKiBEZXRlcm1pbmUgaWYgYSBzbGlkZXIgaXMgbmF2aWdhdGlvbiBmb3IgYW5vdGhlci5cclxuICAgKiBVc2UgXCJzeW5jXCIgQVBJIHRvIHN5bmNocm9uaXplIHR3byBzbGlkZXJzLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIGlzTmF2aWdhdGlvbjogZmFsc2UsXG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byB0cmltIHNwYWNlcyBiZWZvcmUgdGhlIGZpc3Qgc2xpZGUgb3IgYWZ0ZXIgdGhlIGxhc3Qgb25lIHdoZW4gXCJmb2N1c1wiIGlzIG5vdCAwLlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIHRyaW1TcGFjZTogdHJ1ZSxcblxuICAvKipcclxuICAgKiBUaGUgXCJpcy1hY3RpdmVcIiBjbGFzcyBpcyBhZGRlZCBhZnRlciB0cmFuc2l0aW9uIGFzIGRlZmF1bHQuXHJcbiAgICogSWYgdHJ1ZSwgaXQgd2lsbCBiZSBhZGRlZCBiZWZvcmUgbW92ZS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICB1cGRhdGVPbk1vdmU6IGZhbHNlLFxuXG4gIC8qKlxyXG4gICAqIFRocm90dGxlIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHJlc2l6ZSBldmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIHRocm90dGxlOiAxMDAsXG5cbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBkZXN0cm95IGEgc2xpZGVyIG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICBkZXN0cm95OiBmYWxzZSxcblxuICAvKipcclxuICAgKiBPcHRpb25zIGZvciBzcGVjaWZpYyBicmVha3BvaW50cy5cclxuICAgKlxyXG4gICAqIEBleGFtcGxlXHJcbiAgICoge1xyXG4gICAqICAgMTAwMDoge1xyXG4gICAqICAgICBwZXJQYWdlOiAzLFxyXG4gICAqICAgICBnYXA6IDIwXHJcbiAgICogICB9LFxyXG4gICAqICAgNjAwOiB7XHJcbiAgICogICAgIHBlclBhZ2U6IDEsXHJcbiAgICogICAgIGdhcDogNSxcclxuICAgKiAgIH1cclxuICAgKiB9XHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbnxPYmplY3R9XHJcbiAgICovXG4gIGJyZWFrcG9pbnRzOiBmYWxzZSxcblxuICAvKipcclxuICAgKiBDb2xsZWN0aW9uIG9mIGNsYXNzIG5hbWVzLlxyXG4gICAqXHJcbiAgICogQHNlZSAuL2NsYXNzZXMuanNcclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG4gIGNsYXNzZXM6IEVMRU1FTlRfQ0xBU1NFUyxcblxuICAvKipcclxuICAgKiBDb2xsZWN0aW9uIG9mIGkxOG4gdGV4dHMuXHJcbiAgICpcclxuICAgKiBAc2VlIC4vaTE4bi5qc1xyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cbiAgaTE4bjogSTE4TlxufTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb25zdGFudHMvc3RhdGVzLmpzXG4vKipcclxuICogRXhwb3J0IHN0YXRlIGNvbnN0YW50cy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogU3BsaWRlIGhhcyBiZWVuIGp1c3QgY3JlYXRlZC5cclxuICpcclxuICogQHR5cGUge251bWJlcn1cclxuICovXG52YXIgQ1JFQVRFRCA9IDE7XG4vKipcclxuICogQWxsIGNvbXBvbmVudHMgaGF2ZSBiZWVuIG1vdW50ZWQgYW5kIGluaXRpYWxpemVkLlxyXG4gKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKi9cblxudmFyIE1PVU5URUQgPSAyO1xuLyoqXHJcbiAqIFNwbGlkZSBpcyByZWFkeSBmb3IgdHJhbnNpdGlvbi5cclxuICpcclxuICogQHR5cGUge251bWJlcn1cclxuICovXG5cbnZhciBJRExFID0gMztcbi8qKlxyXG4gKiBTcGxpZGUgaXMgbW92aW5nLlxyXG4gKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKi9cblxudmFyIE1PVklORyA9IDQ7XG4vKipcclxuICogU3BsaWRlIGlzIG1vdmluZy5cclxuICpcclxuICogQHR5cGUge251bWJlcn1cclxuICovXG5cbnZhciBERVNUUk9ZRUQgPSA1O1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL3NwbGlkZS5qc1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG4vKipcclxuICogVGhlIG1haW4gY2xhc3MgZm9yIGFwcGx5aW5nIFNwbGlkZSB0byBhbiBlbGVtZW50LlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG5cblxuXG5cblxuLyoqXHJcbiAqIFRoZSBtYWluIGNsYXNzIGZvciBhcHBseWluZyBTcGxpZGUgdG8gYW4gZWxlbWVudCxcclxuICogcHJvdmlkaW5nIHNvbWUgQVBJcyB0byBjb250cm9sIHRoZSBiZWhhdmlvci5cclxuICovXG5cbnZhciBTcGxpZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcclxuICAgKiBTcGxpZGUgY29uc3RydWN0b3IuXHJcbiAgICpcclxuICAgKiBAdGhyb3dzIHtFcnJvcn0gV2hlbiB0aGUgZ2l2ZW4gcm9vdCBlbGVtZW50IG9yIHNlbGVjdG9yIGlzIGludmFsaWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR8c3RyaW5nfSAgcm9vdCAgICAgICAtIEEgc2VsZWN0b3IgZm9yIGEgcm9vdCBlbGVtZW50IG9yIGFuIGVsZW1lbnQgaXRzZWxmLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICBvcHRpb25zICAgIC0gT3B0aW9uYWwuIE9wdGlvbnMgdG8gY2hhbmdlIGRlZmF1bHQgYmVoYXZpb3VyLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgICAgICAgICBDb21wb25lbnRzIC0gT3B0aW9uYWwuIENvbXBvbmVudHMuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFNwbGlkZShyb290LCBvcHRpb25zLCBDb21wb25lbnRzKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChDb21wb25lbnRzID09PSB2b2lkIDApIHtcbiAgICAgIENvbXBvbmVudHMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnJvb3QgPSByb290IGluc3RhbmNlb2YgRWxlbWVudCA/IHJvb3QgOiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJvb3QpO1xuICAgIGV4aXN0KHRoaXMucm9vdCwgJ0FuIGludmFsaWQgZWxlbWVudC9zZWxlY3RvciB3YXMgZ2l2ZW4uJyk7XG4gICAgdGhpcy5Db21wb25lbnRzID0gbnVsbDtcbiAgICB0aGlzLkV2ZW50ID0gY29yZV9ldmVudCgpO1xuICAgIHRoaXMuU3RhdGUgPSBzdGF0ZShDUkVBVEVEKTtcbiAgICB0aGlzLlNUQVRFUyA9IHN0YXRlc19uYW1lc3BhY2VPYmplY3Q7XG4gICAgdGhpcy5fbyA9IG1lcmdlKERFRkFVTFRTLCBvcHRpb25zKTtcbiAgICB0aGlzLl9pID0gMDtcbiAgICB0aGlzLl9jID0gQ29tcG9uZW50cztcbiAgICB0aGlzLl9lID0ge307IC8vIEV4dGVuc2lvbnNcblxuICAgIHRoaXMuX3QgPSBudWxsOyAvLyBUcmFuc2l0aW9uXG4gIH1cbiAgLyoqXHJcbiAgICogQ29tcG9zZSBhbmQgbW91bnQgY29tcG9uZW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgIEV4dGVuc2lvbnMgLSBPcHRpb25hbC4gQWRkaXRpb25hbCBjb21wb25lbnRzLlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFRyYW5zaXRpb24gLSBPcHRpb25hbC4gU2V0IGEgY3VzdG9tIHRyYW5zaXRpb24gY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7U3BsaWRlfHVuZGVmaW5lZH0gLSBUaGlzIGluc3RhbmNlIG9yIHVuZGVmaW5lZCBpZiBhbiBleGNlcHRpb24gb2NjdXJyZWQuXHJcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gU3BsaWRlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ubW91bnQgPSBmdW5jdGlvbiBtb3VudChFeHRlbnNpb25zLCBUcmFuc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGlmIChFeHRlbnNpb25zID09PSB2b2lkIDApIHtcbiAgICAgIEV4dGVuc2lvbnMgPSB0aGlzLl9lO1xuICAgIH1cblxuICAgIGlmIChUcmFuc2l0aW9uID09PSB2b2lkIDApIHtcbiAgICAgIFRyYW5zaXRpb24gPSB0aGlzLl90O1xuICAgIH1cblxuICAgIC8vIFJlc2V0IHRoZSBzdGF0ZS5cbiAgICB0aGlzLlN0YXRlLnNldChDUkVBVEVEKTtcbiAgICB0aGlzLl9lID0gRXh0ZW5zaW9ucztcbiAgICB0aGlzLl90ID0gVHJhbnNpdGlvbjtcbiAgICB0aGlzLkNvbXBvbmVudHMgPSBjb21wb3NlKHRoaXMsIG1lcmdlKHRoaXMuX2MsIEV4dGVuc2lvbnMpLCBUcmFuc2l0aW9uKTtcblxuICAgIHRyeSB7XG4gICAgICBlYWNoKHRoaXMuQ29tcG9uZW50cywgZnVuY3Rpb24gKGNvbXBvbmVudCwga2V5KSB7XG4gICAgICAgIHZhciByZXF1aXJlZCA9IGNvbXBvbmVudC5yZXF1aXJlZDtcblxuICAgICAgICBpZiAocmVxdWlyZWQgPT09IHVuZGVmaW5lZCB8fCByZXF1aXJlZCkge1xuICAgICAgICAgIGNvbXBvbmVudC5tb3VudCAmJiBjb21wb25lbnQubW91bnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgX3RoaXMuQ29tcG9uZW50c1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBTdGF0ZSA9IHRoaXMuU3RhdGU7XG4gICAgU3RhdGUuc2V0KE1PVU5URUQpO1xuICAgIGVhY2godGhpcy5Db21wb25lbnRzLCBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICBjb21wb25lbnQubW91bnRlZCAmJiBjb21wb25lbnQubW91bnRlZCgpO1xuICAgIH0pO1xuICAgIHRoaXMuZW1pdCgnbW91bnRlZCcpO1xuICAgIFN0YXRlLnNldChJRExFKTtcbiAgICB0aGlzLmVtaXQoJ3JlYWR5Jyk7XG4gICAgYXBwbHlTdHlsZSh0aGlzLnJvb3QsIHtcbiAgICAgIHZpc2liaWxpdHk6ICd2aXNpYmxlJ1xuICAgIH0pO1xuICAgIHRoaXMub24oJ21vdmUgZHJhZycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBTdGF0ZS5zZXQoTU9WSU5HKTtcbiAgICB9KS5vbignbW92ZWQgZHJhZ2dlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBTdGF0ZS5zZXQoSURMRSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogU2V0IHN5bmMgdGFyZ2V0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTcGxpZGV9IHNwbGlkZSAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7U3BsaWRlfSAtIFRoaXMgaW5zdGFuY2UuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uc3luYyA9IGZ1bmN0aW9uIHN5bmMoc3BsaWRlKSB7XG4gICAgdGhpcy5zaWJsaW5nID0gc3BsaWRlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIGNhbGxiYWNrIGZpcmVkIG9uIHRoZSBnaXZlbiBldmVudChzKS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgIGV2ZW50cyAgLSBBbiBldmVudCBuYW1lLiBVc2Ugc3BhY2UgdG8gc2VwYXJhdGUgbXVsdGlwbGUgZXZlbnRzLlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbHNvLCBuYW1lc3BhY2UgaXMgYWNjZXB0ZWQgYnkgZG90LCBzdWNoIGFzICdyZXNpemUue25hbWVzcGFjZX0nLlxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgLSBBIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gIGVsbSAgICAgLSBPcHRpb25hbC4gTmF0aXZlIGV2ZW50IHdpbGwgYmUgbGlzdGVuZWQgdG8gd2hlbiB0aGlzIGFyZyBpcyBwcm92aWRlZC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gICBvcHRpb25zIC0gT3B0aW9uYWwuIE9wdGlvbnMgZm9yIGFkZEV2ZW50TGlzdGVuZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtTcGxpZGV9IC0gVGhpcyBpbnN0YW5jZS5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50cywgaGFuZGxlciwgZWxtLCBvcHRpb25zKSB7XG4gICAgaWYgKGVsbSA9PT0gdm9pZCAwKSB7XG4gICAgICBlbG0gPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLkV2ZW50Lm9uKGV2ZW50cywgaGFuZGxlciwgZWxtLCBvcHRpb25zKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBVbnN1YnNjcmliZSB0aGUgZ2l2ZW4gZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gIGV2ZW50cyAtIEEgZXZlbnQgbmFtZS5cclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsbSAgICAtIE9wdGlvbmFsLiByZW1vdmVFdmVudExpc3RlbmVyKCkgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGlzIGFyZyBpcyBwcm92aWRlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1NwbGlkZX0gLSBUaGlzIGluc3RhbmNlLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9mZiA9IGZ1bmN0aW9uIG9mZihldmVudHMsIGVsbSkge1xuICAgIGlmIChlbG0gPT09IHZvaWQgMCkge1xuICAgICAgZWxtID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLkV2ZW50Lm9mZihldmVudHMsIGVsbSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogRW1pdCBhbiBldmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIEFuIGV2ZW50IG5hbWUuXHJcbiAgICogQHBhcmFtIHsqfSAgICAgIGFyZ3MgIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgcGFzc2VkIHRvIGhhbmRsZXJzLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgdmFyIF90aGlzJEV2ZW50O1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgKF90aGlzJEV2ZW50ID0gdGhpcy5FdmVudCkuZW1pdC5hcHBseShfdGhpcyRFdmVudCwgW2V2ZW50XS5jb25jYXQoYXJncykpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogR28gdG8gdGhlIHNsaWRlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gY29udHJvbC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gY29udHJvbCAtIEEgY29udHJvbCBwYXR0ZXJuLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgd2FpdCAgICAtIE9wdGlvbmFsLiBXaGV0aGVyIHRvIHdhaXQgZm9yIHRyYW5zaXRpb24uXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ28gPSBmdW5jdGlvbiBnbyhjb250cm9sLCB3YWl0KSB7XG4gICAgaWYgKHdhaXQgPT09IHZvaWQgMCkge1xuICAgICAgd2FpdCA9IHRoaXMub3B0aW9ucy53YWl0Rm9yVHJhbnNpdGlvbjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5TdGF0ZS5pcyhJRExFKSB8fCB0aGlzLlN0YXRlLmlzKE1PVklORykgJiYgIXdhaXQpIHtcbiAgICAgIHRoaXMuQ29tcG9uZW50cy5Db250cm9sbGVyLmdvKGNvbnRyb2wsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBWZXJpZnkgd2hldGhlciB0aGUgc2xpZGVyIHR5cGUgaXMgdGhlIGdpdmVuIG9uZSBvciBub3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEEgc2xpZGVyIHR5cGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIHNsaWRlciB0eXBlIGlzIHRoZSBwcm92aWRlZCB0eXBlIG9yIGZhbHNlIGlmIG5vdC5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pcyA9IGZ1bmN0aW9uIGlzKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gdGhpcy5fby50eXBlO1xuICB9XG4gIC8qKlxyXG4gICAqIEluc2VydCBhIHNsaWRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gc2xpZGUgLSBBIHNsaWRlIGVsZW1lbnQgdG8gYmUgYWRkZWQuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgaW5kZXggLSBBIHNsaWRlIHdpbGwgYmUgYWRkZWQgYXQgdGhlIHBvc2l0aW9uLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChzbGlkZSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgaW5kZXggPSAtMTtcbiAgICB9XG5cbiAgICB0aGlzLkNvbXBvbmVudHMuRWxlbWVudHMuYWRkKHNsaWRlLCBpbmRleCwgdGhpcy5yZWZyZXNoLmJpbmQodGhpcykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgc2xpZGUgZGVzaWduYXRlZCBieSB0aGUgaW5kZXguXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBBIHNsaWRlIGluZGV4LlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShpbmRleCkge1xuICAgIHRoaXMuQ29tcG9uZW50cy5FbGVtZW50cy5yZW1vdmUoaW5kZXgpO1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgYWxsIFNsaWRlIG9iamVjdHMgYW5kIGNsb25lcyBhbmQgcmVjcmVhdGUgdGhlbSBhZ2Fpbi5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZWZyZXNoID0gZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICB0aGlzLmVtaXQoJ3JlZnJlc2g6YmVmb3JlJykuZW1pdCgncmVmcmVzaCcpLmVtaXQoJ3Jlc2l6ZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxyXG4gICAqIERlc3Ryb3kgdGhlIFNwbGlkZS5cclxuICAgKiBcIkNvbXBsZXRlbHlcIiBib29sZWFuIGlzIG1haW5seSBmb3IgYnJlYWtwb2ludHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXBsZXRlbHkgLSBEZXN0cm95IGNvbXBsZXRlbHkuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koY29tcGxldGVseSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKGNvbXBsZXRlbHkgPT09IHZvaWQgMCkge1xuICAgICAgY29tcGxldGVseSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gUG9zdHBvbmUgZGVzdHJveSBiZWNhdXNlIGl0IHNob3VsZCBiZSBkb25lIGFmdGVyIG1vdW50LlxuICAgIGlmICh0aGlzLlN0YXRlLmlzKENSRUFURUQpKSB7XG4gICAgICB0aGlzLm9uKCdyZWFkeScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi5kZXN0cm95KGNvbXBsZXRlbHkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFsdWVzKHRoaXMuQ29tcG9uZW50cykucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgY29tcG9uZW50LmRlc3Ryb3kgJiYgY29tcG9uZW50LmRlc3Ryb3koY29tcGxldGVseSk7XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95JywgY29tcGxldGVseSk7IC8vIERlc3Ryb3kgYWxsIGV2ZW50IGhhbmRsZXJzLCBpbmNsdWRpbmcgb25lcyBmb3IgbmF0aXZlIGV2ZW50cy5cblxuICAgIHRoaXMuRXZlbnQuZGVzdHJveSgpO1xuICAgIHRoaXMuU3RhdGUuc2V0KERFU1RST1lFRCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBjdXJyZW50IHNsaWRlIGluZGV4LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBjdXJyZW50IHNsaWRlIGluZGV4LlxyXG4gICAvLyAqL1xuICA7XG5cbiAgX2NyZWF0ZUNsYXNzKFNwbGlkZSwgW3tcbiAgICBrZXk6IFwiaW5kZXhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY3VycmVudCBzbGlkZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGluZGV4IC0gQSBuZXcgaW5kZXguXHJcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5kZXgpIHtcbiAgICAgIHRoaXMuX2kgPSBwYXJzZUludChpbmRleCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGxlbmd0aCBvZiBzbGlkZXMuXHJcbiAgICAgKiBUaGlzIGlzIGFuIGFsaWFzIG9mIEVsZW1lbnRzLmxlbmd0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gQSBudW1iZXIgb2Ygc2xpZGVzLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLkNvbXBvbmVudHMuRWxlbWVudHMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybiBvcHRpb25zLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLSBPcHRpb25zIG9iamVjdC5cclxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwib3B0aW9uc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX287XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogU2V0IG9wdGlvbnMgd2l0aCBtZXJnaW5nIHRoZSBnaXZlbiBvYmplY3QgdG8gdGhlIGN1cnJlbnQgb25lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gTmV3IG9wdGlvbnMuXHJcbiAgICAgKi9cbiAgICAsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICAgICAgdmFyIGNyZWF0ZWQgPSB0aGlzLlN0YXRlLmlzKENSRUFURUQpO1xuXG4gICAgICBpZiAoIWNyZWF0ZWQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fbyA9IG1lcmdlKHRoaXMuX28sIG9wdGlvbnMpO1xuXG4gICAgICBpZiAoIWNyZWF0ZWQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGVkJywgdGhpcy5fbyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBjbGFzcyBsaXN0LlxyXG4gICAgICogVGhpcyBpcyBhbiBhbGlhcyBvZiBTcGxpZGUub3B0aW9ucy5jbGFzc0xpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAtIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBjbGFzcyBsaXN0LlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjbGFzc2VzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fby5jbGFzc2VzO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgaTE4biBzdHJpbmdzLlxyXG4gICAgICogVGhpcyBpcyBhbiBhbGlhcyBvZiBTcGxpZGUub3B0aW9ucy5pMThuLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdH0gLSBBbiBvYmplY3QgY29udGFpbmluZyBhbGwgaTE4biBzdHJpbmdzLlxyXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJpMThuXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fby5pMThuO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTcGxpZGU7XG59KCk7XG5cblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvb3B0aW9ucy9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGluaXRpYWxpemluZyBvcHRpb25zLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgaW5pdGlhbGl6aW5nIG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBvcHRpb25zID0gKGZ1bmN0aW9uIChTcGxpZGUpIHtcbiAgLyoqXHJcbiAgICogUmV0cmlldmUgb3B0aW9ucyBmcm9tIHRoZSBkYXRhIGF0dHJpYnV0ZS5cclxuICAgKiBOb3RlIHRoYXQgSUUxMCBkb2Vzbid0IHN1cHBvcnQgZGF0YXNldCBwcm9wZXJ0eS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXG4gIHZhciBvcHRpb25zID0gZ2V0QXR0cmlidXRlKFNwbGlkZS5yb290LCAnZGF0YS1zcGxpZGUnKTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIHRyeSB7XG4gICAgICBTcGxpZGUub3B0aW9ucyA9IEpTT04ucGFyc2Uob3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoZS5tZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgaWYgKFNwbGlkZS5TdGF0ZS5pcyhDUkVBVEVEKSkge1xuICAgICAgICBTcGxpZGUuaW5kZXggPSBTcGxpZGUub3B0aW9ucy5zdGFydDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb25zdGFudHMvZGlyZWN0aW9ucy5qc1xuLyoqXHJcbiAqIEV4cG9ydCBsYXlvdXQgbW9kZXMuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIEVudW1lcmF0ZSBzbGlkZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cbnZhciBMVFIgPSAnbHRyJztcbi8qKlxyXG4gKiBFbnVtZXJhdGUgc2xpZGVzIGZyb20gcmlnaHQgdG8gbGVmdC5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBSVEwgPSAncnRsJztcbi8qKlxyXG4gKiBFbnVtZXJhdGUgc2xpZGVzIGluIGEgY29sLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIFRUQiA9ICd0dGInO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvZWxlbWVudHMvc2xpZGUuanNcbi8qKlxyXG4gKiBUaGUgc3ViIGNvbXBvbmVudCBmb3IgaGFuZGxpbmcgZWFjaCBzbGlkZS5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuXG5cblxuLyoqXHJcbiAqIEV2ZW50cyBmb3IgcmVzdG9yaW5nIG9yaWdpbmFsIHN0eWxlcy5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBTVFlMRV9SRVNUT1JFX0VWRU5UUyA9ICd1cGRhdGUuc2xpZGUnO1xuLyoqXHJcbiAqIFRoZSBzdWIgY29tcG9uZW50IGZvciBoYW5kbGluZyBlYWNoIHNsaWRlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gIFNwbGlkZSAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gIGluZGV4ICAgICAtIEFuIHVuaXF1ZSBzbGlkZSBpbmRleC5cclxuICogQHBhcmFtIHtudW1iZXJ9ICByZWFsSW5kZXggLSBDbG9uZXMgc2hvdWxkIHBhc3MgYSByZWFsIHNsaWRlIGluZGV4LlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHNsaWRlICAgICAtIEEgc2xpZGUgZWxlbWVudC5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBzdWIgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgZWxlbWVudHNfc2xpZGUgPSAoZnVuY3Rpb24gKFNwbGlkZSwgaW5kZXgsIHJlYWxJbmRleCwgc2xpZGUpIHtcbiAgLyoqXHJcbiAgICogV2hldGhlciB0byB1cGRhdGUgXCJpcy1hY3RpdmVcIiBjbGFzcyBiZWZvcmUgb3IgYWZ0ZXIgdHJhbnNpdGlvbi5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuICB2YXIgdXBkYXRlT25Nb3ZlID0gU3BsaWRlLm9wdGlvbnMudXBkYXRlT25Nb3ZlO1xuICAvKipcclxuICAgKiBFdmVudHMgd2hlbiB0aGUgc2xpZGUgc3RhdHVzIGlzIHVwZGF0ZWQuXHJcbiAgICogQXBwZW5kIGEgbmFtZXNwYWNlIHRvIHJlbW92ZSBsaXN0ZW5lcnMgbGF0ZXIuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xuXG4gIHZhciBTVEFUVVNfVVBEQVRFX0VWRU5UUyA9ICdyZWFkeS5zbGlkZSB1cGRhdGVkLnNsaWRlIHJlc2l6ZWQuc2xpZGUgbW92ZWQuc2xpZGUnICsgKHVwZGF0ZU9uTW92ZSA/ICcgbW92ZS5zbGlkZScgOiAnJyk7XG4gIC8qKlxyXG4gICAqIFNsaWRlIHN1YiBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgU2xpZGUgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBTbGlkZSBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxyXG4gICAgICovXG4gICAgc2xpZGU6IHNsaWRlLFxuXG4gICAgLyoqXHJcbiAgICAgKiBTbGlkZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXG4gICAgaW5kZXg6IGluZGV4LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZWFsIGluZGV4IGZvciBjbG9uZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xuICAgIHJlYWxJbmRleDogcmVhbEluZGV4LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDb250YWluZXIgZWxlbWVudCBpZiBhdmFpbGFibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge0VsZW1lbnR8dW5kZWZpbmVkfVxyXG4gICAgICovXG4gICAgY29udGFpbmVyOiBjaGlsZChzbGlkZSwgU3BsaWRlLmNsYXNzZXMuY29udGFpbmVyKSxcblxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGlzIGlzIGEgY2xvbmVkIHNsaWRlIG9yIG5vdC5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xuICAgIGlzQ2xvbmU6IHJlYWxJbmRleCA+IC0xLFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuaXNDbG9uZSkge1xuICAgICAgICBzbGlkZS5pZCA9IFNwbGlkZS5yb290LmlkICsgXCItc2xpZGVcIiArIHBhZChpbmRleCArIDEpO1xuICAgICAgfVxuXG4gICAgICBTcGxpZGUub24oU1RBVFVTX1VQREFURV9FVkVOVFMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnVwZGF0ZSgpO1xuICAgICAgfSkub24oU1RZTEVfUkVTVE9SRV9FVkVOVFMsIHJlc3RvcmVTdHlsZXMpLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFNwbGlkZS5lbWl0KCdjbGljaycsIF90aGlzKTtcbiAgICAgIH0sIHNsaWRlKTtcbiAgICAgIC8qXHJcbiAgICAgICAqIEFkZCBcImlzLWFjdGl2ZVwiIGNsYXNzIHRvIGEgY2xvbmUgZWxlbWVudCB0ZW1wb3JhcmlseVxyXG4gICAgICAgKiBhbmQgaXQgd2lsbCBiZSByZW1vdmVkIG9uIFwibW92ZWRcIiBldmVudC5cclxuICAgICAgICovXG5cbiAgICAgIGlmICh1cGRhdGVPbk1vdmUpIHtcbiAgICAgICAgU3BsaWRlLm9uKCdtb3ZlLnNsaWRlJywgZnVuY3Rpb24gKG5ld0luZGV4KSB7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ID09PSByZWFsSW5kZXgpIHtcbiAgICAgICAgICAgIF91cGRhdGUodHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IC8vIE1ha2Ugc3VyZSB0aGUgc2xpZGUgaXMgc2hvd24uXG5cblxuICAgICAgYXBwbHlTdHlsZShzbGlkZSwge1xuICAgICAgICBkaXNwbGF5OiAnJ1xuICAgICAgfSk7IC8vIEhvbGQgdGhlIG9yaWdpbmFsIHN0eWxlcy5cblxuICAgICAgdGhpcy5zdHlsZXMgPSBnZXRBdHRyaWJ1dGUoc2xpZGUsICdzdHlsZScpIHx8ICcnO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kuXHJcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgU3BsaWRlLm9mZihTVEFUVVNfVVBEQVRFX0VWRU5UUykub2ZmKFNUWUxFX1JFU1RPUkVfRVZFTlRTKS5vZmYoJ2NsaWNrJywgc2xpZGUpO1xuICAgICAgcmVtb3ZlQ2xhc3Moc2xpZGUsIHZhbHVlcyhTVEFUVVNfQ0xBU1NFUykpO1xuICAgICAgcmVzdG9yZVN0eWxlcygpO1xuICAgICAgcmVtb3ZlQXR0cmlidXRlKHRoaXMuY29udGFpbmVyLCAnc3R5bGUnKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgYWN0aXZlIGFuZCB2aXNpYmxlIHN0YXR1cy5cclxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgX3VwZGF0ZSh0aGlzLmlzQWN0aXZlKCksIGZhbHNlKTtcblxuICAgICAgX3VwZGF0ZSh0aGlzLmlzVmlzaWJsZSgpLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoaXMgc2xpZGUgaXMgYWN0aXZlIG9yIG5vdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIHNsaWRlIGlzIGFjdGl2ZSBvciBmYWxzZSBpZiBub3QuXHJcbiAgICAgKi9cbiAgICBpc0FjdGl2ZTogZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgICByZXR1cm4gU3BsaWRlLmluZGV4ID09PSBpbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoaXMgc2xpZGUgaXMgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnQgb3Igbm90LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgc2xpZGUgaXMgdmlzaWJsZSBvciBmYWxzZSBpZiBub3QuXHJcbiAgICAgKi9cbiAgICBpc1Zpc2libGU6IGZ1bmN0aW9uIGlzVmlzaWJsZSgpIHtcbiAgICAgIHZhciBhY3RpdmUgPSB0aGlzLmlzQWN0aXZlKCk7XG5cbiAgICAgIGlmIChTcGxpZGUuaXMoRkFERSkgfHwgYWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmU7XG4gICAgICB9XG5cbiAgICAgIHZhciBjZWlsID0gTWF0aC5jZWlsO1xuICAgICAgdmFyIHRyYWNrUmVjdCA9IGdldFJlY3QoU3BsaWRlLkNvbXBvbmVudHMuRWxlbWVudHMudHJhY2spO1xuICAgICAgdmFyIHNsaWRlUmVjdCA9IGdldFJlY3Qoc2xpZGUpO1xuXG4gICAgICBpZiAoU3BsaWRlLm9wdGlvbnMuZGlyZWN0aW9uID09PSBUVEIpIHtcbiAgICAgICAgcmV0dXJuIHRyYWNrUmVjdC50b3AgPD0gc2xpZGVSZWN0LnRvcCAmJiBzbGlkZVJlY3QuYm90dG9tIDw9IGNlaWwodHJhY2tSZWN0LmJvdHRvbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cmFja1JlY3QubGVmdCA8PSBzbGlkZVJlY3QubGVmdCAmJiBzbGlkZVJlY3QucmlnaHQgPD0gY2VpbCh0cmFja1JlY3QucmlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSBob3cgZmFyIHRoaXMgc2xpZGUgaXMgZnJvbSBhbm90aGVyIHNsaWRlIGFuZFxyXG4gICAgICogcmV0dXJuIHRydWUgaWYgdGhlIGRpc3RhbmNlIGlzIHdpdGhpbiB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tICAgLSBJbmRleCBvZiBhIHRhcmdldCBzbGlkZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aXRoaW4gLSBUcnVlIGlmIHRoZSBzbGlkZSBpcyB3aXRoaW4gdGhpcyBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBzbGlkZSBpcyB3aXRoaW4gdGhlIG51bWJlciBvciBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cbiAgICBpc1dpdGhpbjogZnVuY3Rpb24gaXNXaXRoaW4oZnJvbSwgd2l0aGluKSB7XG4gICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKGZyb20gLSBpbmRleCk7XG5cbiAgICAgIGlmICghU3BsaWRlLmlzKFNMSURFKSAmJiAhdGhpcy5pc0Nsb25lKSB7XG4gICAgICAgIGRpZmYgPSBNYXRoLm1pbihkaWZmLCBTcGxpZGUubGVuZ3RoIC0gZGlmZik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaWZmIDwgd2l0aGluO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogVXBkYXRlIGNsYXNzZXMgZm9yIGFjdGl2aXR5IG9yIHZpc2liaWxpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZSAgICAgICAgLSBJcyBhY3RpdmUvdmlzaWJsZSBvciBub3QuXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBmb3JWaXNpYmlsaXR5IC0gVG9nZ2xlIGNsYXNzZXMgZm9yIGFjdGl2aXR5IG9yIHZpc2liaWxpdHkuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gX3VwZGF0ZShhY3RpdmUsIGZvclZpc2liaWxpdHkpIHtcbiAgICB2YXIgdHlwZSA9IGZvclZpc2liaWxpdHkgPyAndmlzaWJsZScgOiAnYWN0aXZlJztcbiAgICB2YXIgY2xhc3NOYW1lID0gU1RBVFVTX0NMQVNTRVNbdHlwZV07XG5cbiAgICBpZiAoYWN0aXZlKSB7XG4gICAgICBhZGRDbGFzcyhzbGlkZSwgY2xhc3NOYW1lKTtcbiAgICAgIFNwbGlkZS5lbWl0KFwiXCIgKyB0eXBlLCBTbGlkZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXNDbGFzcyhzbGlkZSwgY2xhc3NOYW1lKSkge1xuICAgICAgICByZW1vdmVDbGFzcyhzbGlkZSwgY2xhc3NOYW1lKTtcbiAgICAgICAgU3BsaWRlLmVtaXQoXCJcIiArIChmb3JWaXNpYmlsaXR5ID8gJ2hpZGRlbicgOiAnaW5hY3RpdmUnKSwgU2xpZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSZXN0b3JlIHRoZSBvcmlnaW5hbCBzdHlsZXMuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiByZXN0b3JlU3R5bGVzKCkge1xuICAgIHNldEF0dHJpYnV0ZShzbGlkZSwgJ3N0eWxlJywgU2xpZGUuc3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBTbGlkZTtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvZWxlbWVudHMvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBtYWluIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG5cblxuLyoqXHJcbiAqIFRoZSBwcm9wZXJ0eSBuYW1lIGZvciBVSUQgc3RvcmVkIGluIGEgd2luZG93IG9iamVjdC5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBVSURfTkFNRSA9ICd1aWQnO1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIG1haW4gZWxlbWVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb21wb25lbnRzX2VsZW1lbnRzID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMpIHtcbiAgLyoqXHJcbiAgICogSG9sZCB0aGUgcm9vdCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR9XHJcbiAgICovXG4gIHZhciByb290ID0gU3BsaWRlLnJvb3Q7XG4gIC8qKlxyXG4gICAqIEhvbGQgdGhlIGNsYXNzIGxpc3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBjbGFzc2VzID0gU3BsaWRlLmNsYXNzZXM7XG4gIC8qKlxyXG4gICAqIFN0b3JlIFNsaWRlIG9iamVjdHMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICovXG5cbiAgdmFyIFNsaWRlcyA9IFtdO1xuICAvKlxyXG4gICAqIEFzc2lnbiB1bmlxdWUgSUQgdG8gdGhlIHJvb3QgZWxlbWVudCBpZiBpdCBkb2Vzbid0IGhhdmUgdGhlIG9uZS5cclxuICAgKiBOb3RlIHRoYXQgSUUgZG9lc24ndCBzdXBwb3J0IHBhZFN0YXJ0KCkgdG8gZmlsbCB0aGUgdWlkIGJ5IDAuXHJcbiAgICovXG5cbiAgaWYgKCFyb290LmlkKSB7XG4gICAgd2luZG93LnNwbGlkZSA9IHdpbmRvdy5zcGxpZGUgfHwge307XG4gICAgdmFyIHVpZCA9IHdpbmRvdy5zcGxpZGVbVUlEX05BTUVdIHx8IDA7XG4gICAgd2luZG93LnNwbGlkZVtVSURfTkFNRV0gPSArK3VpZDtcbiAgICByb290LmlkID0gXCJzcGxpZGVcIiArIHBhZCh1aWQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEVsZW1lbnRzIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG5cbiAgdmFyIEVsZW1lbnRzID0ge1xuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICogQ29sbGVjdCBtYWluIGVsZW1lbnRzIGFuZCBzdG9yZSB0aGVtIGFzIG1lbWJlciBwcm9wZXJ0aWVzLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5pbml0KCk7XG4gICAgICBTcGxpZGUub24oJ3JlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmRlc3Ryb3koKTtcblxuICAgICAgICBfdGhpcy5pbml0KCk7XG4gICAgICB9KS5vbigndXBkYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3Mocm9vdCwgZ2V0Q2xhc3NlcygpKTtcbiAgICAgICAgYWRkQ2xhc3Mocm9vdCwgZ2V0Q2xhc3NlcygpKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kuXHJcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgU2xpZGVzLmZvckVhY2goZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICAgIFNsaWRlLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgICAgU2xpZGVzID0gW107XG4gICAgICByZW1vdmVDbGFzcyhyb290LCBnZXRDbGFzc2VzKCkpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemF0aW9uLlxyXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBjb2xsZWN0KCk7XG4gICAgICBhZGRDbGFzcyhyb290LCBnZXRDbGFzc2VzKCkpO1xuICAgICAgdGhpcy5zbGlkZXMuZm9yRWFjaChmdW5jdGlvbiAoc2xpZGUsIGluZGV4KSB7XG4gICAgICAgIF90aGlzMi5yZWdpc3RlcihzbGlkZSwgaW5kZXgsIC0xKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGEgc2xpZGUgdG8gY3JlYXRlIGEgU2xpZGUgb2JqZWN0IGFuZCBoYW5kbGUgaXRzIGJlaGF2aW9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gc2xpZGUgICAgIC0gQSBzbGlkZSBlbGVtZW50LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICBpbmRleCAgICAgLSBBIHVuaXF1ZSBpbmRleC4gVGhpcyBjYW4gYmUgbmVnYXRpdmUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gIHJlYWxJbmRleCAtIEEgcmVhbCBpbmRleCBmb3IgY2xvbmVzLiBTZXQgLTEgZm9yIHJlYWwgc2xpZGVzLlxyXG4gICAgICovXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKHNsaWRlLCBpbmRleCwgcmVhbEluZGV4KSB7XG4gICAgICB2YXIgU2xpZGVPYmplY3QgPSBlbGVtZW50c19zbGlkZShTcGxpZGUsIGluZGV4LCByZWFsSW5kZXgsIHNsaWRlKTtcbiAgICAgIFNsaWRlT2JqZWN0Lm1vdW50KCk7XG4gICAgICBTbGlkZXMucHVzaChTbGlkZU9iamVjdCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBTbGlkZSBvYmplY3QgZGVzaWduYXRlZCBieSB0aGUgaW5kZXguXHJcbiAgICAgKiBOb3RlIHRoYXQgXCJmaW5kXCIgaXMgbm90IHN1cHBvcnRlZCBieSBJRS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSAtIEEgU2xpZGUgb2JqZWN0IGlmIGF2YWlsYWJsZS4gVW5kZWZpbmVkIGlmIG5vdC5cclxuICAgICAqL1xuICAgIGdldFNsaWRlOiBmdW5jdGlvbiBnZXRTbGlkZShpbmRleCkge1xuICAgICAgcmV0dXJuIFNsaWRlcy5maWx0ZXIoZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICAgIHJldHVybiBTbGlkZS5pbmRleCA9PT0gaW5kZXg7XG4gICAgICB9KVswXTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYWxsIFNsaWRlIG9iamVjdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ2xvbmVzIC0gV2hldGhlciB0byBpbmNsdWRlIGNsb25lZCBzbGlkZXMgb3Igbm90LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfSAtIFNsaWRlIG9iamVjdHMuXHJcbiAgICAgKi9cbiAgICBnZXRTbGlkZXM6IGZ1bmN0aW9uIGdldFNsaWRlcyhpbmNsdWRlQ2xvbmVzKSB7XG4gICAgICByZXR1cm4gaW5jbHVkZUNsb25lcyA/IFNsaWRlcyA6IFNsaWRlcy5maWx0ZXIoZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICAgIHJldHVybiAhU2xpZGUuaXNDbG9uZTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiBTbGlkZSBvYmplY3RzIGJlbG9uZ2luZyB0byB0aGUgZ2l2ZW4gcGFnZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFnZSAtIEEgcGFnZSBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0W119IC0gQW4gYXJyYXkgY29udGFpbmluZyBTbGlkZSBvYmplY3RzLlxyXG4gICAgICovXG4gICAgZ2V0U2xpZGVzQnlQYWdlOiBmdW5jdGlvbiBnZXRTbGlkZXNCeVBhZ2UocGFnZSkge1xuICAgICAgdmFyIGlkeCA9IENvbXBvbmVudHMuQ29udHJvbGxlci50b0luZGV4KHBhZ2UpO1xuICAgICAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICAgIHZhciBtYXggPSBvcHRpb25zLmZvY3VzICE9PSBmYWxzZSA/IDEgOiBvcHRpb25zLnBlclBhZ2U7XG4gICAgICByZXR1cm4gU2xpZGVzLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgaW5kZXggPSBfcmVmLmluZGV4O1xuICAgICAgICByZXR1cm4gaWR4IDw9IGluZGV4ICYmIGluZGV4IDwgaWR4ICsgbWF4O1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0IGEgc2xpZGUgdG8gYSBzbGlkZXIuXHJcbiAgICAgKiBOZWVkIHRvIHJlZnJlc2ggU3BsaWRlIGFmdGVyIGFkZGluZyBhIHNsaWRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Tm9kZXxzdHJpbmd9IHNsaWRlICAgIC0gQSBzbGlkZSBlbGVtZW50IHRvIGJlIGFkZGVkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9ICAgICAgaW5kZXggICAgLSBBIHNsaWRlIHdpbGwgYmUgYWRkZWQgYXQgdGhlIHBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgY2FsbGJhY2sgLSBDYWxsZWQgcmlnaHQgYWZ0ZXIgdGhlIHNsaWRlIGlzIGFkZGVkIHRvIHRoZSBET00gdHJlZS5cclxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24gYWRkKHNsaWRlLCBpbmRleCwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2Ygc2xpZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNsaWRlID0gZG9taWZ5KHNsaWRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNsaWRlIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICB2YXIgcmVmID0gdGhpcy5zbGlkZXNbaW5kZXhdOyAvLyBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiBtb3VudCgpIG9mIGEgU2xpZGUgY29tcG9uZW50LlxuXG4gICAgICAgIGFwcGx5U3R5bGUoc2xpZGUsIHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGJlZm9yZShzbGlkZSwgcmVmKTtcbiAgICAgICAgICB0aGlzLnNsaWRlcy5zcGxpY2UoaW5kZXgsIDAsIHNsaWRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcHBlbmQodGhpcy5saXN0LCBzbGlkZSk7XG4gICAgICAgICAgdGhpcy5zbGlkZXMucHVzaChzbGlkZSk7XG4gICAgICAgIH1cblxuICAgICAgICBsb2FkZWQoc2xpZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhzbGlkZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhIHNsaWRlIGZyb20gYSBzbGlkZXIuXHJcbiAgICAgKiBOZWVkIHRvIHJlZnJlc2ggU3BsaWRlIGFmdGVyIHJlbW92aW5nIGEgc2xpZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZGV4IC0gU2xpZGUgaW5kZXguXHJcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShpbmRleCkge1xuICAgICAgZG9tX3JlbW92ZSh0aGlzLnNsaWRlcy5zcGxpY2UoaW5kZXgsIDEpWzBdKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmb3IgZWFjaCBTbGlkZSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIGZ1bmN0aW9uLiBUaGUgZmlyc3QgYXJndW1lbnQgd2lsbCBiZSB0aGUgU2xpZGUgb2JqZWN0LlxyXG4gICAgICovXG4gICAgZWFjaDogZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuICAgICAgU2xpZGVzLmZvckVhY2goY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiBzbGlkZXMgbGVuZ3RoIHdpdGhvdXQgY2xvbmVzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBTbGlkZSBsZW5ndGguXHJcbiAgICAgKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2xpZGVzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gXCJTbGlkZU9iamVjdHNcIiBsZW5ndGggaW5jbHVkaW5nIGNsb25lcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gU2xpZGUgbGVuZ3RoIGluY2x1ZGluZyBjbG9uZXMuXHJcbiAgICAgKi9cbiAgICBnZXQgdG90YWwoKSB7XG4gICAgICByZXR1cm4gU2xpZGVzLmxlbmd0aDtcbiAgICB9XG5cbiAgfTtcbiAgLyoqXHJcbiAgICogQ29sbGVjdCBlbGVtZW50cy5cclxuICAgKi9cblxuICBmdW5jdGlvbiBjb2xsZWN0KCkge1xuICAgIEVsZW1lbnRzLnNsaWRlciA9IGNoaWxkKHJvb3QsIGNsYXNzZXMuc2xpZGVyKTtcbiAgICBFbGVtZW50cy50cmFjayA9IGZpbmQocm9vdCwgXCIuXCIgKyBjbGFzc2VzLnRyYWNrKTtcbiAgICBFbGVtZW50cy5saXN0ID0gY2hpbGQoRWxlbWVudHMudHJhY2ssIGNsYXNzZXMubGlzdCk7XG4gICAgZXhpc3QoRWxlbWVudHMudHJhY2sgJiYgRWxlbWVudHMubGlzdCwgJ1RyYWNrIG9yIGxpc3Qgd2FzIG5vdCBmb3VuZC4nKTtcbiAgICBFbGVtZW50cy5zbGlkZXMgPSBjaGlsZHJlbihFbGVtZW50cy5saXN0LCBjbGFzc2VzLnNsaWRlKTtcbiAgICB2YXIgYXJyb3dzID0gZmluZFBhcnRzKGNsYXNzZXMuYXJyb3dzKTtcbiAgICBFbGVtZW50cy5hcnJvd3MgPSB7XG4gICAgICBwcmV2OiBmaW5kKGFycm93cywgXCIuXCIgKyBjbGFzc2VzLnByZXYpLFxuICAgICAgbmV4dDogZmluZChhcnJvd3MsIFwiLlwiICsgY2xhc3Nlcy5uZXh0KVxuICAgIH07XG4gICAgdmFyIGF1dG9wbGF5ID0gZmluZFBhcnRzKGNsYXNzZXMuYXV0b3BsYXkpO1xuICAgIEVsZW1lbnRzLmJhciA9IGZpbmQoZmluZFBhcnRzKGNsYXNzZXMucHJvZ3Jlc3MpLCBcIi5cIiArIGNsYXNzZXMuYmFyKTtcbiAgICBFbGVtZW50cy5wbGF5ID0gZmluZChhdXRvcGxheSwgXCIuXCIgKyBjbGFzc2VzLnBsYXkpO1xuICAgIEVsZW1lbnRzLnBhdXNlID0gZmluZChhdXRvcGxheSwgXCIuXCIgKyBjbGFzc2VzLnBhdXNlKTtcbiAgICBFbGVtZW50cy50cmFjay5pZCA9IEVsZW1lbnRzLnRyYWNrLmlkIHx8IHJvb3QuaWQgKyBcIi10cmFja1wiO1xuICAgIEVsZW1lbnRzLmxpc3QuaWQgPSBFbGVtZW50cy5saXN0LmlkIHx8IHJvb3QuaWQgKyBcIi1saXN0XCI7XG4gIH1cbiAgLyoqXHJcbiAgICogUmV0dXJuIGNsYXNzIG5hbWVzIGZvciB0aGUgcm9vdCBlbGVtZW50LlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NlcygpIHtcbiAgICB2YXIgcm9vdENsYXNzID0gY2xhc3Nlcy5yb290O1xuICAgIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgcmV0dXJuIFtyb290Q2xhc3MgKyBcIi0tXCIgKyBvcHRpb25zLnR5cGUsIHJvb3RDbGFzcyArIFwiLS1cIiArIG9wdGlvbnMuZGlyZWN0aW9uLCBvcHRpb25zLmRyYWcgPyByb290Q2xhc3MgKyBcIi0tZHJhZ2dhYmxlXCIgOiAnJywgb3B0aW9ucy5pc05hdmlnYXRpb24gPyByb290Q2xhc3MgKyBcIi0tbmF2XCIgOiAnJywgU1RBVFVTX0NMQVNTRVMuYWN0aXZlXTtcbiAgfVxuICAvKipcclxuICAgKiBGaW5kIHBhcnRzIG9ubHkgZnJvbSBjaGlsZHJlbiBvZiB0aGUgcm9vdCBvciB0cmFjay5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IC0gQSBmb3VuZCBlbGVtZW50IG9yIHVuZGVmaW5lZC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGZpbmRQYXJ0cyhjbGFzc05hbWUpIHtcbiAgICByZXR1cm4gY2hpbGQocm9vdCwgY2xhc3NOYW1lKSB8fCBjaGlsZChFbGVtZW50cy5zbGlkZXIsIGNsYXNzTmFtZSk7XG4gIH1cblxuICByZXR1cm4gRWxlbWVudHM7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2NvbnRyb2xsZXIvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyB0aGUgdHJhY2suXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgY29udHJvbGxpbmcgdGhlIHRyYWNrLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY29udHJvbGxlciA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzKSB7XG4gIC8qKlxyXG4gICAqIFN0b3JlIGN1cnJlbnQgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG4gIHZhciBvcHRpb25zO1xuICAvKipcclxuICAgKiBUcnVlIGlmIHRoZSBzbGlkZSBpcyBMT09QIG1vZGUuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cblxuICB2YXIgaXNMb29wO1xuICAvKipcclxuICAgKiBDb250cm9sbGVyIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBDb250cm9sbGVyID0ge1xuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgICAgaXNMb29wID0gU3BsaWRlLmlzKExPT1ApO1xuICAgICAgYmluZCgpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIE1ha2UgdHJhY2sgcnVuIGJ5IHRoZSBnaXZlbiBjb250cm9sLlxyXG4gICAgICogLSBcIit7aX1cIiA6IEluY3JlbWVudCB0aGUgc2xpZGUgaW5kZXggYnkgaS5cclxuICAgICAqIC0gXCIte2l9XCIgOiBEZWNyZW1lbnQgdGhlIHNsaWRlIGluZGV4IGJ5IGkuXHJcbiAgICAgKiAtIFwie2l9XCIgIDogR28gdG8gdGhlIHNsaWRlIHdob3NlIGluZGV4IGlzIGkuXHJcbiAgICAgKiAtIFwiPlwiICAgIDogR28gdG8gbmV4dCBwYWdlLlxyXG4gICAgICogLSBcIjxcIiAgICA6IEdvIHRvIHByZXYgcGFnZS5cclxuICAgICAqIC0gXCI+e2l9XCIgOiBHbyB0byBwYWdlIGkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBjb250cm9sICAtIEEgY29udHJvbCBwYXR0ZXJuLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSAgICAgICBzaWxlbnRseSAtIEdvIHRvIHRoZSBkZXN0aW5hdGlvbiB3aXRob3V0IGV2ZW50IGVtaXNzaW9uLlxyXG4gICAgICovXG4gICAgZ286IGZ1bmN0aW9uIGdvKGNvbnRyb2wsIHNpbGVudGx5KSB7XG4gICAgICB2YXIgZGVzdEluZGV4ID0gdGhpcy50cmltKHRoaXMucGFyc2UoY29udHJvbCkpO1xuICAgICAgQ29tcG9uZW50cy5UcmFjay5nbyhkZXN0SW5kZXgsIHRoaXMucmV3aW5kKGRlc3RJbmRleCksIHNpbGVudGx5KTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZSB0aGUgZ2l2ZW4gY29udHJvbCBhbmQgcmV0dXJuIHRoZSBkZXN0aW5hdGlvbiBpbmRleCBmb3IgdGhlIHRyYWNrLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb250cm9sIC0gQSBjb250cm9sIHRhcmdldCBwYXR0ZXJuLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBBIHBhcnNlZCB0YXJnZXQuXHJcbiAgICAgKi9cbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoY29udHJvbCkge1xuICAgICAgdmFyIGluZGV4ID0gU3BsaWRlLmluZGV4O1xuICAgICAgdmFyIG1hdGNoZXMgPSBTdHJpbmcoY29udHJvbCkubWF0Y2goLyhbK1xcLTw+XSspKFxcZCspPy8pO1xuICAgICAgdmFyIGluZGljYXRvciA9IG1hdGNoZXMgPyBtYXRjaGVzWzFdIDogJyc7XG4gICAgICB2YXIgbnVtYmVyID0gbWF0Y2hlcyA/IHBhcnNlSW50KG1hdGNoZXNbMl0pIDogMDtcblxuICAgICAgc3dpdGNoIChpbmRpY2F0b3IpIHtcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgaW5kZXggKz0gbnVtYmVyIHx8IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgaW5kZXggLT0gbnVtYmVyIHx8IDE7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGluZGV4ID0gcGFyc2VQYWdlKG51bWJlciwgaW5kZXgsIGluZGljYXRvciA9PT0gJzwnKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGluZGV4ID0gcGFyc2VJbnQoY29udHJvbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIGluZGV4IGZyb20gdGhlIGdpdmVuIHBhZ2UgbnVtYmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlIC0gUGFnZSBudW1iZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIEEgY29tcHV0ZWQgcGFnZSBudW1iZXIuXHJcbiAgICAgKi9cbiAgICB0b0luZGV4OiBmdW5jdGlvbiB0b0luZGV4KHBhZ2UpIHtcbiAgICAgIGlmIChoYXNGb2N1cygpKSB7XG4gICAgICAgIHJldHVybiBwYWdlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gU3BsaWRlLmxlbmd0aDtcbiAgICAgIHZhciBwZXJQYWdlID0gb3B0aW9ucy5wZXJQYWdlO1xuICAgICAgdmFyIGluZGV4ID0gcGFnZSAqIHBlclBhZ2U7XG4gICAgICBpbmRleCA9IGluZGV4IC0gKHRoaXMucGFnZUxlbmd0aCAqIHBlclBhZ2UgLSBsZW5ndGgpICogZmxvb3IoaW5kZXggLyBsZW5ndGgpOyAvLyBBZGp1c3RtZW50IGZvciB0aGUgbGFzdCBwYWdlLlxuXG4gICAgICBpZiAobGVuZ3RoIC0gcGVyUGFnZSA8PSBpbmRleCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpbmRleCA9IGxlbmd0aCAtIHBlclBhZ2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHBhZ2UgbnVtYmVyIGZyb20gdGhlIGdpdmVuIHNsaWRlIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFNsaWRlIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBBIGNvbXB1dGVkIHBhZ2UgbnVtYmVyLlxyXG4gICAgICovXG4gICAgdG9QYWdlOiBmdW5jdGlvbiB0b1BhZ2UoaW5kZXgpIHtcbiAgICAgIGlmIChoYXNGb2N1cygpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IFNwbGlkZS5sZW5ndGg7XG4gICAgICB2YXIgcGVyUGFnZSA9IG9wdGlvbnMucGVyUGFnZTsgLy8gTWFrZSB0aGUgbGFzdCBcInBlclBhZ2VcIiBudW1iZXIgb2Ygc2xpZGVzIGJlbG9uZyB0byB0aGUgbGFzdCBwYWdlLlxuXG4gICAgICBpZiAobGVuZ3RoIC0gcGVyUGFnZSA8PSBpbmRleCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmxvb3IoKGxlbmd0aCAtIDEpIC8gcGVyUGFnZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbG9vcihpbmRleCAvIHBlclBhZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFRyaW0gdGhlIGdpdmVuIGluZGV4IGFjY29yZGluZyB0byB0aGUgY3VycmVudCBtb2RlLlxyXG4gICAgICogSW5kZXggYmVpbmcgcmV0dXJuZWQgY291bGQgYmUgbGVzcyB0aGFuIDAgb3IgZ3JlYXRlciB0aGFuIHRoZSBsZW5ndGggaW4gTG9vcCBtb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIEFuIGluZGV4IGJlaW5nIHRyaW1tZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIEEgdHJpbW1lZCBpbmRleC5cclxuICAgICAqL1xuICAgIHRyaW06IGZ1bmN0aW9uIHRyaW0oaW5kZXgpIHtcbiAgICAgIGlmICghaXNMb29wKSB7XG4gICAgICAgIGluZGV4ID0gb3B0aW9ucy5yZXdpbmQgPyB0aGlzLnJld2luZChpbmRleCkgOiBiZXR3ZWVuKGluZGV4LCAwLCB0aGlzLmVkZ2VJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXdpbmQgdGhlIGdpdmVuIGluZGV4IGlmIGl0J3Mgb3V0IG9mIHJhbmdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIEFuIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBBIHJld291bmQgaW5kZXguXHJcbiAgICAgKi9cbiAgICByZXdpbmQ6IGZ1bmN0aW9uIHJld2luZChpbmRleCkge1xuICAgICAgdmFyIGVkZ2UgPSB0aGlzLmVkZ2VJbmRleDtcblxuICAgICAgaWYgKGlzTG9vcCkge1xuICAgICAgICB3aGlsZSAoaW5kZXggPiBlZGdlKSB7XG4gICAgICAgICAgaW5kZXggLT0gZWRnZSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgaW5kZXggKz0gZWRnZSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbmRleCA+IGVkZ2UpIHtcbiAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgaW5kZXggPSBlZGdlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiB0aGUgZGlyZWN0aW9uIGlzIFwicnRsXCIgb3Igbm90LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiBcInJ0bFwiIG9yIGZhbHNlIGlmIG5vdC5cclxuICAgICAqL1xuICAgIGlzUnRsOiBmdW5jdGlvbiBpc1J0bCgpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmRpcmVjdGlvbiA9PT0gUlRMO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgcGFnZSBsZW5ndGguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIE1heCBwYWdlIG51bWJlci5cclxuICAgICAqL1xuICAgIGdldCBwYWdlTGVuZ3RoKCkge1xuICAgICAgdmFyIGxlbmd0aCA9IFNwbGlkZS5sZW5ndGg7XG4gICAgICByZXR1cm4gaGFzRm9jdXMoKSA/IGxlbmd0aCA6IE1hdGguY2VpbChsZW5ndGggLyBvcHRpb25zLnBlclBhZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgZWRnZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gRWRnZSBpbmRleC5cclxuICAgICAqL1xuICAgIGdldCBlZGdlSW5kZXgoKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gU3BsaWRlLmxlbmd0aDtcblxuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNGb2N1cygpIHx8IG9wdGlvbnMuaXNOYXZpZ2F0aW9uIHx8IGlzTG9vcCkge1xuICAgICAgICByZXR1cm4gbGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxlbmd0aCAtIG9wdGlvbnMucGVyUGFnZTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBwcmV2aW91cyBzbGlkZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIGluZGV4IG9mIHRoZSBwcmV2aW91cyBzbGlkZSBpZiBhdmFpbGFibGUuIC0xIG90aGVyd2lzZS5cclxuICAgICAqL1xuICAgIGdldCBwcmV2SW5kZXgoKSB7XG4gICAgICB2YXIgcHJldiA9IFNwbGlkZS5pbmRleCAtIDE7XG5cbiAgICAgIGlmIChpc0xvb3AgfHwgb3B0aW9ucy5yZXdpbmQpIHtcbiAgICAgICAgcHJldiA9IHRoaXMucmV3aW5kKHByZXYpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldiA+IC0xID8gcHJldiA6IC0xO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG5leHQgc2xpZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBpbmRleCBvZiB0aGUgbmV4dCBzbGlkZSBpZiBhdmFpbGFibGUuIC0xIG90aGVyd2lzZS5cclxuICAgICAqL1xuICAgIGdldCBuZXh0SW5kZXgoKSB7XG4gICAgICB2YXIgbmV4dCA9IFNwbGlkZS5pbmRleCArIDE7XG5cbiAgICAgIGlmIChpc0xvb3AgfHwgb3B0aW9ucy5yZXdpbmQpIHtcbiAgICAgICAgbmV4dCA9IHRoaXMucmV3aW5kKG5leHQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU3BsaWRlLmluZGV4IDwgbmV4dCAmJiBuZXh0IDw9IHRoaXMuZWRnZUluZGV4IHx8IG5leHQgPT09IDAgPyBuZXh0IDogLTE7XG4gICAgfVxuXG4gIH07XG4gIC8qKlxyXG4gICAqIExpc3RlbiB0byBzb21lIGV2ZW50cy5cclxuICAgKi9cblxuICBmdW5jdGlvbiBiaW5kKCkge1xuICAgIFNwbGlkZS5vbignbW92ZScsIGZ1bmN0aW9uIChuZXdJbmRleCkge1xuICAgICAgU3BsaWRlLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgfSkub24oJ3VwZGF0ZWQgcmVmcmVzaCcsIGZ1bmN0aW9uIChuZXdPcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gbmV3T3B0aW9ucyB8fCBvcHRpb25zO1xuICAgICAgU3BsaWRlLmluZGV4ID0gYmV0d2VlbihTcGxpZGUuaW5kZXgsIDAsIENvbnRyb2xsZXIuZWRnZUluZGV4KTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBWZXJpZnkgaWYgdGhlIGZvY3VzIG9wdGlvbiBpcyBhdmFpbGFibGUgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIGEgc2xpZGVyIGhhcyB0aGUgZm9jdXMgb3B0aW9uLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaGFzRm9jdXMoKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZm9jdXMgIT09IGZhbHNlO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgbmV4dCBvciBwcmV2aW91cyBwYWdlIGluZGV4IGNvbXB1dGVkIGJ5IHRoZSBwYWdlIG51bWJlciBhbmQgY3VycmVudCBpbmRleC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgbnVtYmVyIC0gU3BlY2lmeSB0aGUgcGFnZSBudW1iZXIuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBpbmRleCAgLSBDdXJyZW50IGluZGV4LlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldiAgIC0gUHJldiBvciBuZXh0LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7bnVtYmVyfSAtIFNsaWRlIGluZGV4LlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcGFyc2VQYWdlKG51bWJlciwgaW5kZXgsIHByZXYpIHtcbiAgICBpZiAobnVtYmVyID4gLTEpIHtcbiAgICAgIHJldHVybiBDb250cm9sbGVyLnRvSW5kZXgobnVtYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgcGVyTW92ZSA9IG9wdGlvbnMucGVyTW92ZTtcbiAgICB2YXIgc2lnbiA9IHByZXYgPyAtMSA6IDE7XG5cbiAgICBpZiAocGVyTW92ZSkge1xuICAgICAgcmV0dXJuIGluZGV4ICsgcGVyTW92ZSAqIHNpZ247XG4gICAgfVxuXG4gICAgcmV0dXJuIENvbnRyb2xsZXIudG9JbmRleChDb250cm9sbGVyLnRvUGFnZShpbmRleCkgKyBzaWduKTtcbiAgfVxuXG4gIHJldHVybiBDb250cm9sbGVyO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy90cmFjay9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIG1vdmluZyBsaXN0IGluIHRoZSB0cmFjay5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuXG5cbnZhciBhYnMgPSBNYXRoLmFicztcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBtb3ZpbmcgbGlzdCBpbiB0aGUgdHJhY2suXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCB0cmFjayA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzKSB7XG4gIC8qKlxyXG4gICAqIEhvbGQgdGhlIExheW91dCBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuICB2YXIgTGF5b3V0O1xuICAvKipcclxuICAgKiBIb2xkIHRoZSBMYXlvdXQgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgRWxlbWVudHM7XG4gIC8qKlxyXG4gICAqIFN0b3JlIHRoZSBsaXN0IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RWxlbWVudH1cclxuICAgKi9cblxuICB2YXIgbGlzdDtcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgY3VycmVudCBkaXJlY3Rpb24gaXMgdmVydGljYWwgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG5cbiAgdmFyIGlzVmVydGljYWwgPSBTcGxpZGUub3B0aW9ucy5kaXJlY3Rpb24gPT09IFRUQjtcbiAgLyoqXHJcbiAgICogV2hldGhlciB0aGUgc2xpZGVyIHR5cGUgaXMgRkFERSBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cblxuICB2YXIgaXNGYWRlID0gU3BsaWRlLmlzKEZBREUpO1xuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBzbGlkZXIgZGlyZWN0aW9uIGlzIFJUTCBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cblxuICB2YXIgaXNSVEwgPSBTcGxpZGUub3B0aW9ucy5kaXJlY3Rpb24gPT09IFJUTDtcbiAgLyoqXHJcbiAgICogVGhpcyB3aWxsIGJlIHRydWUgd2hpbGUgdHJhbnNpdGlvbmluZyBmcm9tIHRoZSBsYXN0IGluZGV4IHRvIHRoZSBmaXJzdCBvbmUuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cblxuICB2YXIgaXNMb29wUGVuZGluZyA9IGZhbHNlO1xuICAvKipcclxuICAgKiBTaWduIGZvciB0aGUgZGlyZWN0aW9uLiBPbmx5IFJUTCBtb2RlIHVzZXMgdGhlIHBvc2l0aXZlIHNpZ24uXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xuXG4gIHZhciBzaWduID0gaXNSVEwgPyAxIDogLTE7XG4gIC8qKlxyXG4gICAqIFRyYWNrIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBUcmFjayA9IHtcbiAgICAvKipcclxuICAgICAqIE1ha2UgcHVibGljIHRoZSBzaWduIGRlZmluZWQgbG9jYWxseS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXG4gICAgc2lnbjogc2lnbixcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgRWxlbWVudHMgPSBDb21wb25lbnRzLkVsZW1lbnRzO1xuICAgICAgTGF5b3V0ID0gQ29tcG9uZW50cy5MYXlvdXQ7XG4gICAgICBsaXN0ID0gRWxlbWVudHMubGlzdDtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYWZ0ZXIgdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICogVGhlIHJlc2l6ZSBldmVudCBtdXN0IGJlIHJlZ2lzdGVyZWQgYWZ0ZXIgdGhlIExheW91dCdzIG9uZSBpcyBkb25lLlxyXG4gICAgICovXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICghaXNGYWRlKSB7XG4gICAgICAgIHRoaXMuanVtcCgwKTtcbiAgICAgICAgU3BsaWRlLm9uKCdtb3VudGVkIHJlc2l6ZSB1cGRhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLmp1bXAoU3BsaWRlLmluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogR28gdG8gdGhlIGdpdmVuIGRlc3RpbmF0aW9uIGluZGV4LlxyXG4gICAgICogQWZ0ZXIgYXJyaXZpbmcgdGhlcmUsIHRoZSB0cmFjayBpcyBqdW1wIHRvIHRoZSBuZXcgaW5kZXggd2l0aG91dCBhbmltYXRpb24sIG1haW5seSBmb3IgbG9vcCBtb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgZGVzdEluZGV4IC0gQSBkZXN0aW5hdGlvbiBpbmRleC5cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBjYW4gYmUgbmVnYXRpdmUgb3IgZ3JlYXRlciB0aGFuIHNsaWRlcyBsZW5ndGggZm9yIHJlYWNoaW5nIGNsb25lcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSAgbmV3SW5kZXggIC0gQW4gYWN0dWFsIG5ldyBpbmRleC4gVGhleSBhcmUgYWx3YXlzIHNhbWUgaW4gU2xpZGUgYW5kIFJld2luZCBtb2RlLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaWxlbnRseSAgLSBJZiB0cnVlLCBzdXBwcmVzcyBlbWl0dGluZyBldmVudHMuXHJcbiAgICAgKi9cbiAgICBnbzogZnVuY3Rpb24gZ28oZGVzdEluZGV4LCBuZXdJbmRleCwgc2lsZW50bHkpIHtcbiAgICAgIHZhciBuZXdQb3NpdGlvbiA9IGdldFRyaW1tZWRQb3NpdGlvbihkZXN0SW5kZXgpO1xuICAgICAgdmFyIHByZXZJbmRleCA9IFNwbGlkZS5pbmRleDsgLy8gUHJldmVudCBhbnkgYWN0aW9ucyB3aGlsZSB0cmFuc2l0aW9uaW5nIGZyb20gdGhlIGxhc3QgaW5kZXggdG8gdGhlIGZpcnN0IG9uZSBmb3IganVtcC5cblxuICAgICAgaWYgKFNwbGlkZS5TdGF0ZS5pcyhNT1ZJTkcpICYmIGlzTG9vcFBlbmRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpc0xvb3BQZW5kaW5nID0gZGVzdEluZGV4ICE9PSBuZXdJbmRleDtcblxuICAgICAgaWYgKCFzaWxlbnRseSkge1xuICAgICAgICBTcGxpZGUuZW1pdCgnbW92ZScsIG5ld0luZGV4LCBwcmV2SW5kZXgsIGRlc3RJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChNYXRoLmFicyhuZXdQb3NpdGlvbiAtIHRoaXMucG9zaXRpb24pID49IDEgfHwgaXNGYWRlKSB7XG4gICAgICAgIENvbXBvbmVudHMuVHJhbnNpdGlvbi5zdGFydChkZXN0SW5kZXgsIG5ld0luZGV4LCBwcmV2SW5kZXgsIHRoaXMudG9Db29yZChuZXdQb3NpdGlvbiksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBvblRyYW5zaXRpb25FbmQoZGVzdEluZGV4LCBuZXdJbmRleCwgcHJldkluZGV4LCBzaWxlbnRseSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRlc3RJbmRleCAhPT0gcHJldkluZGV4ICYmIFNwbGlkZS5vcHRpb25zLnRyaW1TcGFjZSA9PT0gJ21vdmUnKSB7XG4gICAgICAgICAgQ29tcG9uZW50cy5Db250cm9sbGVyLmdvKGRlc3RJbmRleCArIGRlc3RJbmRleCAtIHByZXZJbmRleCwgc2lsZW50bHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uVHJhbnNpdGlvbkVuZChkZXN0SW5kZXgsIG5ld0luZGV4LCBwcmV2SW5kZXgsIHNpbGVudGx5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIE1vdmUgdGhlIHRyYWNrIHRvIHRoZSBzcGVjaWZpZWQgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQSBkZXN0aW5hdGlvbiBpbmRleCB3aGVyZSB0aGUgdHJhY2sganVtcHMuXHJcbiAgICAgKi9cbiAgICBqdW1wOiBmdW5jdGlvbiBqdW1wKGluZGV4KSB7XG4gICAgICB0aGlzLnRyYW5zbGF0ZShnZXRUcmltbWVkUG9zaXRpb24oaW5kZXgpKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGxpc3QgcG9zaXRpb24gYnkgQ1NTIHRyYW5zbGF0ZSBwcm9wZXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gLSBBIG5ldyBwb3NpdGlvbiB2YWx1ZS5cclxuICAgICAqL1xuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gdHJhbnNsYXRlKHBvc2l0aW9uKSB7XG4gICAgICBhcHBseVN0eWxlKGxpc3QsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVwiICsgKGlzVmVydGljYWwgPyAnWScgOiAnWCcpICsgXCIoXCIgKyBwb3NpdGlvbiArIFwicHgpXCJcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIENhbmNlbCB0aGUgdHJhbnNpdGlvbiBhbmQgc2V0IHRoZSBsaXN0IHBvc2l0aW9uLlxyXG4gICAgICogQWxzbywgbG9vcCB0aGUgc2xpZGVyIGlmIG5lY2Vzc2FyeS5cclxuICAgICAqL1xuICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgaWYgKFNwbGlkZS5pcyhMT09QKSkge1xuICAgICAgICB0aGlzLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgIHRoaXMudHJhbnNsYXRlKHRoaXMucG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBhcHBseVN0eWxlKGxpc3QsIHtcbiAgICAgICAgdHJhbnNpdGlvbjogJydcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFNoaWZ0IHRoZSBzbGlkZXIgaWYgaXQgZXhjZWVkcyBib3JkZXJzIG9uIHRoZSBlZGdlLlxyXG4gICAgICovXG4gICAgc2hpZnQ6IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gYWJzKHRoaXMucG9zaXRpb24pO1xuICAgICAgdmFyIGxlZnQgPSBhYnModGhpcy50b1Bvc2l0aW9uKDApKTtcbiAgICAgIHZhciByaWdodCA9IGFicyh0aGlzLnRvUG9zaXRpb24oU3BsaWRlLmxlbmd0aCkpO1xuICAgICAgdmFyIGlubmVyU2l6ZSA9IHJpZ2h0IC0gbGVmdDtcblxuICAgICAgaWYgKHBvc2l0aW9uIDwgbGVmdCkge1xuICAgICAgICBwb3NpdGlvbiArPSBpbm5lclNpemU7XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID4gcmlnaHQpIHtcbiAgICAgICAgcG9zaXRpb24gLT0gaW5uZXJTaXplO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyYW5zbGF0ZShzaWduICogcG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFRyaW0gcmVkdW5kYW50IHNwYWNlcyBvbiB0aGUgbGVmdCBvciByaWdodCBlZGdlIGlmIG5lY2Vzc2FyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gLSBQb3NpdGlvbiB2YWx1ZSB0byBiZSB0cmltbWVkLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBUcmltbWVkIHBvc2l0aW9uLlxyXG4gICAgICovXG4gICAgdHJpbTogZnVuY3Rpb24gdHJpbShwb3NpdGlvbikge1xuICAgICAgaWYgKCFTcGxpZGUub3B0aW9ucy50cmltU3BhY2UgfHwgU3BsaWRlLmlzKExPT1ApKSB7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2UgPSBzaWduICogKExheW91dC50b3RhbFNpemUoKSAtIExheW91dC5zaXplIC0gTGF5b3V0LmdhcCk7XG4gICAgICByZXR1cm4gYmV0d2Vlbihwb3NpdGlvbiwgZWRnZSwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSBjbG9zZXN0IHNsaWRlIGluZGV4IGZyb20gdGhlIGdpdmVuIHBvc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiAtIEEgcG9zaXRpb24gY29udmVydGVkIHRvIGFuIHNsaWRlIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgY2xvc2VzdCBzbGlkZSBpbmRleC5cclxuICAgICAqL1xuICAgIHRvSW5kZXg6IGZ1bmN0aW9uIHRvSW5kZXgocG9zaXRpb24pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgdmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICBFbGVtZW50cy5nZXRTbGlkZXModHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgICAgdmFyIHNsaWRlSW5kZXggPSBTbGlkZS5pbmRleDtcbiAgICAgICAgdmFyIGRpc3RhbmNlID0gYWJzKF90aGlzMi50b1Bvc2l0aW9uKHNsaWRlSW5kZXgpIC0gcG9zaXRpb24pO1xuXG4gICAgICAgIGlmIChkaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICBpbmRleCA9IHNsaWRlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiBjb29yZGluYXRlcyBvYmplY3QgYnkgdGhlIGdpdmVuIHBvc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NpdGlvbiAtIEEgcG9zaXRpb24gdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAtIEEgY29vcmRpbmF0ZXMgb2JqZWN0LlxyXG4gICAgICovXG4gICAgdG9Db29yZDogZnVuY3Rpb24gdG9Db29yZChwb3NpdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogaXNWZXJ0aWNhbCA/IDAgOiBwb3NpdGlvbixcbiAgICAgICAgeTogaXNWZXJ0aWNhbCA/IHBvc2l0aW9uIDogMFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHRyYWNrIHBvc2l0aW9uIGJ5IGEgc2xpZGUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gU2xpZGUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAtIENhbGN1bGF0ZWQgcG9zaXRpb24uXHJcbiAgICAgKi9cbiAgICB0b1Bvc2l0aW9uOiBmdW5jdGlvbiB0b1Bvc2l0aW9uKGluZGV4KSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBMYXlvdXQudG90YWxTaXplKGluZGV4KSAtIExheW91dC5zbGlkZVNpemUoaW5kZXgpIC0gTGF5b3V0LmdhcDtcbiAgICAgIHJldHVybiBzaWduICogKHBvc2l0aW9uICsgdGhpcy5vZmZzZXQoaW5kZXgpKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgb2Zmc2V0IHZhbHVlLCBjb25zaWRlcmluZyBkaXJlY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIE9mZnNldCBhbW91bnQuXHJcbiAgICAgKi9cbiAgICBvZmZzZXQ6IGZ1bmN0aW9uIG9mZnNldChpbmRleCkge1xuICAgICAgdmFyIGZvY3VzID0gU3BsaWRlLm9wdGlvbnMuZm9jdXM7XG4gICAgICB2YXIgc2xpZGVTaXplID0gTGF5b3V0LnNsaWRlU2l6ZShpbmRleCk7XG5cbiAgICAgIGlmIChmb2N1cyA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcmV0dXJuIC0oTGF5b3V0LnNpemUgLSBzbGlkZVNpemUpIC8gMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIC0ocGFyc2VJbnQoZm9jdXMpIHx8IDApICogKHNsaWRlU2l6ZSArIExheW91dC5nYXApO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgY3VycmVudCBwb3NpdGlvbi5cclxuICAgICAqIFRoaXMgcmV0dXJucyB0aGUgY29ycmVjdCBwb3NpdGlvbiBldmVuIHdoaWxlIHRyYW5zaXRpb25pbmcgYnkgQ1NTLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBDdXJyZW50IHBvc2l0aW9uLlxyXG4gICAgICovXG4gICAgZ2V0IHBvc2l0aW9uKCkge1xuICAgICAgdmFyIHByb3AgPSBpc1ZlcnRpY2FsID8gJ3RvcCcgOiBpc1JUTCA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICByZXR1cm4gZ2V0UmVjdChsaXN0KVtwcm9wXSAtIChnZXRSZWN0KEVsZW1lbnRzLnRyYWNrKVtwcm9wXSAtIExheW91dC5wYWRkaW5nW3Byb3BdICogc2lnbik7XG4gICAgfVxuXG4gIH07XG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGVuZXZlciBzbGlkZXMgYXJyaXZlIGF0IGEgZGVzdGluYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gIGRlc3RJbmRleCAtIEEgZGVzdGluYXRpb24gaW5kZXguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9ICBuZXdJbmRleCAgLSBBIG5ldyBpbmRleC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gIHByZXZJbmRleCAtIEEgcHJldmlvdXMgaW5kZXguXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBzaWxlbnRseSAgLSBJZiB0cnVlLCBzdXBwcmVzcyBlbWl0dGluZyBldmVudHMuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kKGRlc3RJbmRleCwgbmV3SW5kZXgsIHByZXZJbmRleCwgc2lsZW50bHkpIHtcbiAgICBhcHBseVN0eWxlKGxpc3QsIHtcbiAgICAgIHRyYW5zaXRpb246ICcnXG4gICAgfSk7XG4gICAgaXNMb29wUGVuZGluZyA9IGZhbHNlO1xuXG4gICAgaWYgKCFpc0ZhZGUpIHtcbiAgICAgIFRyYWNrLmp1bXAobmV3SW5kZXgpO1xuICAgIH1cblxuICAgIGlmICghc2lsZW50bHkpIHtcbiAgICAgIFNwbGlkZS5lbWl0KCdtb3ZlZCcsIG5ld0luZGV4LCBwcmV2SW5kZXgsIGRlc3RJbmRleCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENvbnZlcnQgaW5kZXggdG8gdGhlIHRyaW1tZWQgcG9zaXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVHJpbW1lZCBwb3NpdGlvbi5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFRyaW1tZWRQb3NpdGlvbihpbmRleCkge1xuICAgIHJldHVybiBUcmFjay50cmltKFRyYWNrLnRvUG9zaXRpb24oaW5kZXgpKTtcbiAgfVxuXG4gIHJldHVybiBUcmFjaztcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvY2xvbmVzL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgY2xvbmluZyBzb21lIHNsaWRlcyBmb3IgXCJsb29wXCIgbW9kZSBvZiB0aGUgdHJhY2suXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG5cblxuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGNsb25pbmcgc29tZSBzbGlkZXMgZm9yIFwibG9vcFwiIG1vZGUgb2YgdGhlIHRyYWNrLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgY2xvbmVzID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMpIHtcbiAgLyoqXHJcbiAgICogU3RvcmUgaW5mb3JtYXRpb24gb2YgYWxsIGNsb25lcy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtBcnJheX1cclxuICAgKi9cbiAgdmFyIGNsb25lcyA9IFtdO1xuICAvKipcclxuICAgKiBTdG9yZSB0aGUgY3VycmVudCBjbG9uZSBjb3VudCBvbiBvbmUgc2lkZS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG5cbiAgdmFyIGNsb25lQ291bnQgPSAwO1xuICAvKipcclxuICAgKiBLZWVwIEVsZW1lbnRzIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIEVsZW1lbnRzID0gQ29tcG9uZW50cy5FbGVtZW50cztcbiAgLyoqXHJcbiAgICogQ2xvbmVzIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBDbG9uZXMgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoU3BsaWRlLmlzKExPT1ApKSB7XG4gICAgICAgIGluaXQoKTtcbiAgICAgICAgU3BsaWRlLm9uKCdyZWZyZXNoOmJlZm9yZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIH0pLm9uKCdyZWZyZXNoJywgaW5pdCkub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoY2xvbmVDb3VudCAhPT0gZ2V0Q2xvbmVDb3VudCgpKSB7XG4gICAgICAgICAgICAvLyBEZXN0cm95IGJlZm9yZSByZWZyZXNoIG5vdCB0byBjb2xsZWN0IGNsb25lcyBieSB0aGUgRWxlbWVudHMgY29tcG9uZW50LlxuICAgICAgICAgICAgX3RoaXMuZGVzdHJveSgpO1xuXG4gICAgICAgICAgICBTcGxpZGUucmVmcmVzaCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveS5cclxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBkb21fcmVtb3ZlKGNsb25lcyk7XG4gICAgICBjbG9uZXMgPSBbXTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYWxsIGNsb25lcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50W119IC0gQ2xvbmVkIGVsZW1lbnRzLlxyXG4gICAgICovXG4gICAgZ2V0IGNsb25lcygpIHtcbiAgICAgIHJldHVybiBjbG9uZXM7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGNsb25lIGxlbmd0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gQSBsZW5ndGggb2YgY2xvbmVzLlxyXG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiBjbG9uZXMubGVuZ3RoO1xuICAgIH1cblxuICB9O1xuICAvKipcclxuICAgKiBJbml0aWFsaXphdGlvbi5cclxuICAgKi9cblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIENsb25lcy5kZXN0cm95KCk7XG4gICAgY2xvbmVDb3VudCA9IGdldENsb25lQ291bnQoKTtcbiAgICBnZW5lcmF0ZUNsb25lcyhjbG9uZUNvdW50KTtcbiAgfVxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhbmQgYXBwZW5kL3ByZXBlbmQgY2xvbmVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gVGhlIGhhbGYgbnVtYmVyIG9mIGNsb25lcy5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlQ2xvbmVzKGNvdW50KSB7XG4gICAgdmFyIGxlbmd0aCA9IEVsZW1lbnRzLmxlbmd0aCxcbiAgICAgICAgcmVnaXN0ZXIgPSBFbGVtZW50cy5yZWdpc3RlcjtcblxuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIHZhciBzbGlkZXMgPSBFbGVtZW50cy5zbGlkZXM7XG5cbiAgICAgIHdoaWxlIChzbGlkZXMubGVuZ3RoIDwgY291bnQpIHtcbiAgICAgICAgc2xpZGVzID0gc2xpZGVzLmNvbmNhdChzbGlkZXMpO1xuICAgICAgfSAvLyBDbG9uZXMgYWZ0ZXIgdGhlIGxhc3QgZWxlbWVudC5cblxuXG4gICAgICBzbGlkZXMuc2xpY2UoMCwgY291bnQpLmZvckVhY2goZnVuY3Rpb24gKGVsbSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGNsb25lID0gY2xvbmVEZWVwbHkoZWxtKTtcbiAgICAgICAgYXBwZW5kKEVsZW1lbnRzLmxpc3QsIGNsb25lKTtcbiAgICAgICAgY2xvbmVzLnB1c2goY2xvbmUpO1xuICAgICAgICByZWdpc3RlcihjbG9uZSwgaW5kZXggKyBsZW5ndGgsIGluZGV4ICUgbGVuZ3RoKTtcbiAgICAgIH0pOyAvLyBDbG9uZXMgYmVmb3JlIHRoZSBmaXJzdCBlbGVtZW50LlxuXG4gICAgICBzbGlkZXMuc2xpY2UoLWNvdW50KS5mb3JFYWNoKGZ1bmN0aW9uIChlbG0sIGluZGV4KSB7XG4gICAgICAgIHZhciBjbG9uZSA9IGNsb25lRGVlcGx5KGVsbSk7XG4gICAgICAgIGJlZm9yZShjbG9uZSwgc2xpZGVzWzBdKTtcbiAgICAgICAgY2xvbmVzLnB1c2goY2xvbmUpO1xuICAgICAgICByZWdpc3RlcihjbG9uZSwgaW5kZXggLSBjb3VudCwgKGxlbmd0aCArIGluZGV4IC0gY291bnQgJSBsZW5ndGgpICUgbGVuZ3RoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm4gaGFsZiBjb3VudCBvZiBjbG9uZXMgdG8gYmUgZ2VuZXJhdGVkLlxyXG4gICAqIENsb25lIGNvdW50IGlzIGRldGVybWluZWQgYnk6XHJcbiAgICogLSBcImNsb25lc1wiIHZhbHVlIGluIHRoZSBvcHRpb25zLlxyXG4gICAqIC0gTnVtYmVyIG9mIHNsaWRlcyB0aGF0IGNhbiBiZSBwbGFjZWQgaW4gYSB2aWV3IGluIFwiZml4ZWRcIiBtb2RlLlxyXG4gICAqIC0gTWF4IHBhZ2VzIGEgZmxpY2sgYWN0aW9uIGNhbiBtb3ZlLlxyXG4gICAqIC0gV2hldGhlciB0aGUgc2xpZGUgbGVuZ3RoIGlzIGVub3VnaCBmb3IgcGVyUGFnZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBDb3VudCBmb3IgY2xvbmVzLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0Q2xvbmVDb3VudCgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuXG4gICAgaWYgKG9wdGlvbnMuY2xvbmVzKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5jbG9uZXM7XG4gICAgfSAvLyBVc2UgdGhlIHNsaWRlIGxlbmd0aCBpbiBhdXRvV2lkdGggbW9kZSBiZWNhdXNlIHRoZSBudW1iZXIgY2Fubm90IGJlIGNhbGN1bGF0ZWQuXG5cblxuICAgIHZhciBiYXNlQ291bnQgPSBvcHRpb25zLmF1dG9XaWR0aCB8fCBvcHRpb25zLmF1dG9IZWlnaHQgPyBFbGVtZW50cy5sZW5ndGggOiBvcHRpb25zLnBlclBhZ2U7XG4gICAgdmFyIGRpbWVuc2lvbiA9IG9wdGlvbnMuZGlyZWN0aW9uID09PSBUVEIgPyAnSGVpZ2h0JyA6ICdXaWR0aCc7XG4gICAgdmFyIGZpeGVkU2l6ZSA9IHRvUGl4ZWwoU3BsaWRlLnJvb3QsIG9wdGlvbnNbXCJmaXhlZFwiICsgZGltZW5zaW9uXSk7XG5cbiAgICBpZiAoZml4ZWRTaXplKSB7XG4gICAgICAvLyBSb3VnaGx5IGNhbGN1bGF0ZSB0aGUgY291bnQuIFRoaXMgbmVlZHMgbm90IHRvIGJlIHN0cmljdC5cbiAgICAgIGJhc2VDb3VudCA9IE1hdGguY2VpbChFbGVtZW50cy50cmFja1tcImNsaWVudFwiICsgZGltZW5zaW9uXSAvIGZpeGVkU2l6ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VDb3VudCAqIChvcHRpb25zLmRyYWcgPyBvcHRpb25zLmZsaWNrTWF4UGFnZXMgKyAxIDogMSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2xvbmUgZGVlcGx5IHRoZSBnaXZlbiBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbG0gLSBBbiBlbGVtZW50IGJlaW5nIGR1cGxpY2F0ZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtOb2RlfSAtIEEgY2xvbmVkIG5vZGUoZWxlbWVudCkuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBjbG9uZURlZXBseShlbG0pIHtcbiAgICB2YXIgY2xvbmUgPSBlbG0uY2xvbmVOb2RlKHRydWUpO1xuICAgIGFkZENsYXNzKGNsb25lLCBTcGxpZGUuY2xhc3Nlcy5jbG9uZSk7IC8vIElEIHNob3VsZCBub3QgYmUgZHVwbGljYXRlZC5cblxuICAgIHJlbW92ZUF0dHJpYnV0ZShjbG9uZSwgJ2lkJyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgcmV0dXJuIENsb25lcztcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvbGF5b3V0L2RpcmVjdGlvbnMvaG9yaXpvbnRhbC5qc1xuLyoqXHJcbiAqIFRoZSByZXNvbHZlciBjb21wb25lbnQgZm9yIGhvcml6b250YWwgbGF5b3V0LlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG4vKipcclxuICogVGhlIHJlc29sdmVyIGNvbXBvbmVudCBmb3IgaG9yaXpvbnRhbCBsYXlvdXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSByZXNvbHZlciBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGhvcml6b250YWwgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cykge1xuICAvKipcclxuICAgKiBLZWVwIHRoZSBFbGVtZW50cyBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xuICB2YXIgRWxlbWVudHMgPSBDb21wb25lbnRzLkVsZW1lbnRzO1xuICAvKipcclxuICAgKiBLZWVwIHRoZSByb290IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RWxlbWVudH1cclxuICAgKi9cblxuICB2YXIgcm9vdCA9IFNwbGlkZS5yb290O1xuICAvKipcclxuICAgKiBLZWVwIHRoZSB0cmFjayBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR9XHJcbiAgICovXG5cbiAgdmFyIHRyYWNrO1xuICAvKipcclxuICAgKiBLZWVwIHRoZSBsYXRlc3Qgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtFbGVtZW50fVxyXG4gICAqL1xuXG4gIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gIHJldHVybiB7XG4gICAgLyoqXHJcbiAgICAgKiBNYXJnaW4gcHJvcGVydHkgbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICovXG4gICAgbWFyZ2luOiAnbWFyZ2luJyArIChvcHRpb25zLmRpcmVjdGlvbiA9PT0gUlRMID8gJ0xlZnQnIDogJ1JpZ2h0JyksXG5cbiAgICAvKipcclxuICAgICAqIEFsd2F5cyAwIGJlY2F1c2UgdGhlIGhlaWdodCB3aWxsIGJlIGRldGVybWluZWQgYnkgaW5uZXIgY29udGVudHMuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqL1xuICAgIGhlaWdodDogMCxcblxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKi9cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemUgZ2FwIGFuZCBwYWRkaW5nLlxyXG4gICAgICogVGhpcyBtdXN0IGJlIGNhbGxlZCBvbiBpbml0LlxyXG4gICAgICovXG4gICAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgICB0cmFjayA9IEVsZW1lbnRzLnRyYWNrO1xuICAgICAgdGhpcy5nYXAgPSB0b1BpeGVsKHJvb3QsIG9wdGlvbnMuZ2FwKTtcbiAgICAgIHZhciBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nO1xuICAgICAgdmFyIGxlZnQgPSB0b1BpeGVsKHJvb3QsIHBhZGRpbmcubGVmdCB8fCBwYWRkaW5nKTtcbiAgICAgIHZhciByaWdodCA9IHRvUGl4ZWwocm9vdCwgcGFkZGluZy5yaWdodCB8fCBwYWRkaW5nKTtcbiAgICAgIHRoaXMucGFkZGluZyA9IHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICB9O1xuICAgICAgYXBwbHlTdHlsZSh0cmFjaywge1xuICAgICAgICBwYWRkaW5nTGVmdDogdW5pdChsZWZ0KSxcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiB1bml0KHJpZ2h0KVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRvdGFsIHdpZHRoIGZyb20gdGhlIGxlZnQgb2YgdGhlIGxpc3QgdG8gdGhlIHJpZ2h0IG9mIHRoZSBzbGlkZSBzcGVjaWZpZWQgYnkgdGhlIHByb3ZpZGVkIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIE9wdGlvbmFsLiBBIHNsaWRlIGluZGV4LiBJZiB1bmRlZmluZWQsIHRvdGFsIHdpZHRoIG9mIHRoZSBzbGlkZXIgd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVG90YWwgd2lkdGggdG8gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHNwZWNpZmllZCBzbGlkZSwgb3IgMCBmb3IgYW4gaW52YWxpZCBpbmRleC5cclxuICAgICAqL1xuICAgIHRvdGFsV2lkdGg6IGZ1bmN0aW9uIHRvdGFsV2lkdGgoaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluZGV4ID0gU3BsaWRlLmxlbmd0aCAtIDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBTbGlkZSA9IEVsZW1lbnRzLmdldFNsaWRlKGluZGV4KTtcbiAgICAgIHZhciB3aWR0aCA9IDA7XG5cbiAgICAgIGlmIChTbGlkZSkge1xuICAgICAgICB2YXIgc2xpZGVSZWN0ID0gZ2V0UmVjdChTbGlkZS5zbGlkZSk7XG4gICAgICAgIHZhciBsaXN0UmVjdCA9IGdldFJlY3QoRWxlbWVudHMubGlzdCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aW9uID09PSBSVEwpIHtcbiAgICAgICAgICB3aWR0aCA9IGxpc3RSZWN0LnJpZ2h0IC0gc2xpZGVSZWN0LmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2lkdGggPSBzbGlkZVJlY3QucmlnaHQgLSBsaXN0UmVjdC5sZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgd2lkdGggKz0gdGhpcy5nYXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHNsaWRlIHdpZHRoIGluIHB4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFNsaWRlIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgc2xpZGUgd2lkdGguXHJcbiAgICAgKi9cbiAgICBzbGlkZVdpZHRoOiBmdW5jdGlvbiBzbGlkZVdpZHRoKGluZGV4KSB7XG4gICAgICBpZiAob3B0aW9ucy5hdXRvV2lkdGgpIHtcbiAgICAgICAgdmFyIFNsaWRlID0gRWxlbWVudHMuZ2V0U2xpZGUoaW5kZXgpO1xuICAgICAgICByZXR1cm4gU2xpZGUgPyBTbGlkZS5zbGlkZS5vZmZzZXRXaWR0aCA6IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCA9IG9wdGlvbnMuZml4ZWRXaWR0aCB8fCAodGhpcy53aWR0aCArIHRoaXMuZ2FwKSAvIG9wdGlvbnMucGVyUGFnZSAtIHRoaXMuZ2FwO1xuICAgICAgcmV0dXJuIHRvUGl4ZWwocm9vdCwgd2lkdGgpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgc2xpZGUgaGVpZ2h0IGluIHB4LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgc2xpZGUgaGVpZ2h0LlxyXG4gICAgICovXG4gICAgc2xpZGVIZWlnaHQ6IGZ1bmN0aW9uIHNsaWRlSGVpZ2h0KCkge1xuICAgICAgdmFyIGhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IG9wdGlvbnMuZml4ZWRIZWlnaHQgfHwgdGhpcy53aWR0aCAqIG9wdGlvbnMuaGVpZ2h0UmF0aW87XG4gICAgICByZXR1cm4gdG9QaXhlbChyb290LCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiBzbGlkZXIgd2lkdGggd2l0aG91dCBwYWRkaW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBDdXJyZW50IHNsaWRlciB3aWR0aC5cclxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgIHJldHVybiB0cmFjay5jbGllbnRXaWR0aCAtIHRoaXMucGFkZGluZy5sZWZ0IC0gdGhpcy5wYWRkaW5nLnJpZ2h0O1xuICAgIH1cblxuICB9O1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9sYXlvdXQvZGlyZWN0aW9ucy92ZXJ0aWNhbC5qc1xuLyoqXHJcbiAqIFRoZSByZXNvbHZlciBjb21wb25lbnQgZm9yIHZlcnRpY2FsIGxheW91dC5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuLyoqXHJcbiAqIFRoZSByZXNvbHZlciBjb21wb25lbnQgZm9yIHZlcnRpY2FsIGxheW91dC5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIHJlc29sdmVyIG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgdmVydGljYWwgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cykge1xuICAvKipcclxuICAgKiBLZWVwIHRoZSBFbGVtZW50cyBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xuICB2YXIgRWxlbWVudHMgPSBDb21wb25lbnRzLkVsZW1lbnRzO1xuICAvKipcclxuICAgKiBLZWVwIHRoZSByb290IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RWxlbWVudH1cclxuICAgKi9cblxuICB2YXIgcm9vdCA9IFNwbGlkZS5yb290O1xuICAvKipcclxuICAgKiBLZWVwIHRoZSB0cmFjayBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR9XHJcbiAgICovXG5cbiAgdmFyIHRyYWNrO1xuICAvKipcclxuICAgKiBLZWVwIHRoZSBsYXRlc3Qgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtFbGVtZW50fVxyXG4gICAqL1xuXG4gIHZhciBvcHRpb25zO1xuICByZXR1cm4ge1xuICAgIC8qKlxyXG4gICAgICogTWFyZ2luIHByb3BlcnR5IG5hbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqL1xuICAgIG1hcmdpbjogJ21hcmdpbkJvdHRvbScsXG5cbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemF0aW9uLlxyXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmVzaXplIGdhcCBhbmQgcGFkZGluZy5cclxuICAgICAqIFRoaXMgbXVzdCBiZSBjYWxsZWQgb24gaW5pdC5cclxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgICAgdHJhY2sgPSBFbGVtZW50cy50cmFjaztcbiAgICAgIHRoaXMuZ2FwID0gdG9QaXhlbChyb290LCBvcHRpb25zLmdhcCk7XG4gICAgICB2YXIgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZztcbiAgICAgIHZhciB0b3AgPSB0b1BpeGVsKHJvb3QsIHBhZGRpbmcudG9wIHx8IHBhZGRpbmcpO1xuICAgICAgdmFyIGJvdHRvbSA9IHRvUGl4ZWwocm9vdCwgcGFkZGluZy5ib3R0b20gfHwgcGFkZGluZyk7XG4gICAgICB0aGlzLnBhZGRpbmcgPSB7XG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBib3R0b206IGJvdHRvbVxuICAgICAgfTtcbiAgICAgIGFwcGx5U3R5bGUodHJhY2ssIHtcbiAgICAgICAgcGFkZGluZ1RvcDogdW5pdCh0b3ApLFxuICAgICAgICBwYWRkaW5nQm90dG9tOiB1bml0KGJvdHRvbSlcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0b3RhbCBoZWlnaHQgZnJvbSB0aGUgdG9wIG9mIHRoZSBsaXN0IHRvIHRoZSBib3R0b20gb2YgdGhlIHNsaWRlIHNwZWNpZmllZCBieSB0aGUgcHJvdmlkZWQgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gT3B0aW9uYWwuIEEgc2xpZGUgaW5kZXguIElmIHVuZGVmaW5lZCwgdG90YWwgaGVpZ2h0IG9mIHRoZSBzbGlkZXIgd2lsbCBiZSByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVG90YWwgaGVpZ2h0IHRvIHRoZSBib3R0b20gb2YgdGhlIHNwZWNpZmllZCBzbGlkZSwgb3IgMCBmb3IgYW4gaW52YWxpZCBpbmRleC5cclxuICAgICAqL1xuICAgIHRvdGFsSGVpZ2h0OiBmdW5jdGlvbiB0b3RhbEhlaWdodChpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgaW5kZXggPSBTcGxpZGUubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIFNsaWRlID0gRWxlbWVudHMuZ2V0U2xpZGUoaW5kZXgpO1xuXG4gICAgICBpZiAoU2xpZGUpIHtcbiAgICAgICAgcmV0dXJuIGdldFJlY3QoU2xpZGUuc2xpZGUpLmJvdHRvbSAtIGdldFJlY3QoRWxlbWVudHMubGlzdCkudG9wICsgdGhpcy5nYXA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgc2xpZGUgd2lkdGggaW4gcHguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBzbGlkZSB3aWR0aC5cclxuICAgICAqL1xuICAgIHNsaWRlV2lkdGg6IGZ1bmN0aW9uIHNsaWRlV2lkdGgoKSB7XG4gICAgICByZXR1cm4gdG9QaXhlbChyb290LCBvcHRpb25zLmZpeGVkV2lkdGggfHwgdGhpcy53aWR0aCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBzbGlkZSBoZWlnaHQgaW4gcHguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gU2xpZGUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIFRoZSBzbGlkZSBoZWlnaHQuXHJcbiAgICAgKi9cbiAgICBzbGlkZUhlaWdodDogZnVuY3Rpb24gc2xpZGVIZWlnaHQoaW5kZXgpIHtcbiAgICAgIGlmIChvcHRpb25zLmF1dG9IZWlnaHQpIHtcbiAgICAgICAgdmFyIFNsaWRlID0gRWxlbWVudHMuZ2V0U2xpZGUoaW5kZXgpO1xuICAgICAgICByZXR1cm4gU2xpZGUgPyBTbGlkZS5zbGlkZS5vZmZzZXRIZWlnaHQgOiAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5maXhlZEhlaWdodCB8fCAodGhpcy5oZWlnaHQgKyB0aGlzLmdhcCkgLyBvcHRpb25zLnBlclBhZ2UgLSB0aGlzLmdhcDtcbiAgICAgIHJldHVybiB0b1BpeGVsKHJvb3QsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHNsaWRlciB3aWR0aCB3aXRob3V0IHBhZGRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAtIEN1cnJlbnQgc2xpZGVyIHdpZHRoLlxyXG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgcmV0dXJuIHRyYWNrLmNsaWVudFdpZHRoO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiBzbGlkZSBoZWlnaHQgd2l0aG91dCBwYWRkaW5nLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBTbGlkZXIgaGVpZ2h0LlxyXG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgIHZhciBoZWlnaHQgPSBvcHRpb25zLmhlaWdodCB8fCB0aGlzLndpZHRoICogb3B0aW9ucy5oZWlnaHRSYXRpbztcbiAgICAgIGV4aXN0KGhlaWdodCwgJ1wiaGVpZ2h0XCIgb3IgXCJoZWlnaHRSYXRpb1wiIGlzIG1pc3NpbmcuJyk7XG4gICAgICByZXR1cm4gdG9QaXhlbChyb290LCBoZWlnaHQpIC0gdGhpcy5wYWRkaW5nLnRvcCAtIHRoaXMucGFkZGluZy5ib3R0b207XG4gICAgfVxuXG4gIH07XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy91dGlscy90aW1lLmpzXG4vKipcclxuICogQSBwYWNrYWdlIG9mIHV0aWxpdHkgZnVuY3Rpb25zIHJlbGF0ZWQgd2l0aCB0aW1lLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBTaW1wbGUgdGhyb3R0bGUgZnVuY3Rpb24gdGhhdCBjb250cm9scyBob3cgb2Z0ZW4gdGhlIGdpdmVuIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIC0gQSBmdW5jdGlvbiB0byBiZSB0aHJvdHRsZWQuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSAgIHdhaXQgLSBUaW1lIGluIG1pbGxpc2Vjb25kIGZvciBpbnRlcnZhbCBvZiBleGVjdXRpb24uXHJcbiAqXHJcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSAtIEEgZGVib3VuY2VkIGZ1bmN0aW9uLlxyXG4gKi9cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQpIHtcbiAgdmFyIHRpbWVvdXQ7IC8vIERlY2xhcmUgZnVuY3Rpb24gYnkgdGhlIFwiZnVuY3Rpb25cIiBrZXl3b3JkIHRvIHByZXZlbnQgXCJ0aGlzXCIgZnJvbSBiZWluZyBpbmhlcml0ZWQuXG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuYygpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIH0sIHdhaXQpO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxyXG4gKiBDdXN0b20gc2V0SW50ZXJ2YWwgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBwcm9ncmVzcyByYXRlIGFzIGNhbGxiYWNrLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gZmlyZWQgZXZlcnkgdGltZSB0aGUgaW50ZXJ2YWwgdGltZSBwYXNzZXMuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSAgIGludGVydmFsIC0gSW50ZXJ2YWwgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9ncmVzcyAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gZmlyZWQgd2hlbmV2ZXIgdGhlIHByb2dyZXNzIGdvZXMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBBbiBvYmplY3QgY29udGFpbmluZyBwbGF5KCkgYW5kIHBhdXNlKCkgZnVuY3Rpb25zLlxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlSW50ZXJ2YWwoY2FsbGJhY2ssIGludGVydmFsLCBwcm9ncmVzcykge1xuICB2YXIgX3dpbmRvdyA9IHdpbmRvdyxcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IF93aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICB2YXIgc3RhcnQsXG4gICAgICBlbGFwc2UsXG4gICAgICByYXRlLFxuICAgICAgX3BhdXNlID0gdHJ1ZTtcblxuICB2YXIgc3RlcCA9IGZ1bmN0aW9uIHN0ZXAodGltZXN0YW1wKSB7XG4gICAgaWYgKCFfcGF1c2UpIHtcbiAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgPSB0aW1lc3RhbXA7XG5cbiAgICAgICAgaWYgKHJhdGUgJiYgcmF0ZSA8IDEpIHtcbiAgICAgICAgICBzdGFydCAtPSByYXRlICogaW50ZXJ2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxhcHNlID0gdGltZXN0YW1wIC0gc3RhcnQ7XG4gICAgICByYXRlID0gZWxhcHNlIC8gaW50ZXJ2YWw7XG5cbiAgICAgIGlmIChlbGFwc2UgPj0gaW50ZXJ2YWwpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICByYXRlID0gMTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgIHByb2dyZXNzKHJhdGUpO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgICAgX3BhdXNlID0gdHJ1ZTtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9LFxuICAgIHBsYXk6IGZ1bmN0aW9uIHBsYXkocmVzZXQpIHtcbiAgICAgIHN0YXJ0ID0gMDtcblxuICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgIHJhdGUgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3BhdXNlKSB7XG4gICAgICAgIF9wYXVzZSA9IGZhbHNlO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvbGF5b3V0L2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgaGFuZGluZyBzbGlkZSBsYXlvdXRzIGFuZCB0aGVpciBzaXplcy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuXG5cblxuXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgaGFuZGluZyBzbGlkZSBsYXlvdXRzIGFuZCB0aGVpciBzaXplcy5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGxheW91dCA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzKSB7XG4gIC8qKlxyXG4gICAqIEtlZXAgdGhlIEVsZW1lbnRzIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXG4gIHZhciBFbGVtZW50cyA9IENvbXBvbmVudHMuRWxlbWVudHM7XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIHNsaWRlciBpcyB2ZXJ0aWNhbCBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cblxuICB2YXIgaXNWZXJ0aWNhbCA9IFNwbGlkZS5vcHRpb25zLmRpcmVjdGlvbiA9PT0gVFRCO1xuICAvKipcclxuICAgKiBMYXlvdXQgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIExheW91dCA9IG9iamVjdF9hc3NpZ24oe1xuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgYmluZCgpO1xuICAgICAgaW5pdCgpOyAvLyBUaGUgd29yZCBcInNpemVcIiBtZWFucyB3aWR0aCBmb3IgYSBob3Jpem9udGFsIHNsaWRlciBhbmQgaGVpZ2h0IGZvciBhIHZlcnRpY2FsIHNsaWRlci5cblxuICAgICAgdGhpcy50b3RhbFNpemUgPSBpc1ZlcnRpY2FsID8gdGhpcy50b3RhbEhlaWdodCA6IHRoaXMudG90YWxXaWR0aDtcbiAgICAgIHRoaXMuc2xpZGVTaXplID0gaXNWZXJ0aWNhbCA/IHRoaXMuc2xpZGVIZWlnaHQgOiB0aGlzLnNsaWRlV2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveSB0aGUgY29tcG9uZW50LlxyXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZShbRWxlbWVudHMubGlzdCwgRWxlbWVudHMudHJhY2tdLCAnc3R5bGUnKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIHNsaWRlciBoZWlnaHQgb24gdGhlIHZlcnRpY2FsIG1vZGUgb3Igd2lkdGggb24gdGhlIGhvcml6b250YWwgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBpc1ZlcnRpY2FsID8gdGhpcy5oZWlnaHQgOiB0aGlzLndpZHRoO1xuICAgIH1cblxuICB9LCBpc1ZlcnRpY2FsID8gdmVydGljYWwoU3BsaWRlLCBDb21wb25lbnRzKSA6IGhvcml6b250YWwoU3BsaWRlLCBDb21wb25lbnRzKSk7XG4gIC8qKlxyXG4gICAqIEluaXQgc2xpZGVyIHN0eWxlcyBhY2NvcmRpbmcgdG8gb3B0aW9ucy5cclxuICAgKi9cblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIExheW91dC5pbml0KCk7XG4gICAgYXBwbHlTdHlsZShTcGxpZGUucm9vdCwge1xuICAgICAgbWF4V2lkdGg6IHVuaXQoU3BsaWRlLm9wdGlvbnMud2lkdGgpXG4gICAgfSk7XG4gICAgRWxlbWVudHMuZWFjaChmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgIFNsaWRlLnNsaWRlLnN0eWxlW0xheW91dC5tYXJnaW5dID0gdW5pdChMYXlvdXQuZ2FwKTtcbiAgICB9KTtcbiAgICByZXNpemUoKTtcbiAgfVxuICAvKipcclxuICAgKiBMaXN0ZW4gdGhlIHJlc2l6ZSBuYXRpdmUgZXZlbnQgd2l0aCB0aHJvdHRsZS5cclxuICAgKiBJbml0aWFsaXplIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkIG9yIG9wdGlvbnMgYXJlIHVwZGF0ZWQuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBiaW5kKCkge1xuICAgIFNwbGlkZS5vbigncmVzaXplIGxvYWQnLCB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XG4gICAgICBTcGxpZGUuZW1pdCgncmVzaXplJyk7XG4gICAgfSwgU3BsaWRlLm9wdGlvbnMudGhyb3R0bGUpLCB3aW5kb3cpLm9uKCdyZXNpemUnLCByZXNpemUpLm9uKCd1cGRhdGVkIHJlZnJlc2gnLCBpbml0KTtcbiAgfVxuICAvKipcclxuICAgKiBSZXNpemUgdGhlIHRyYWNrIGFuZCBzbGlkZSBlbGVtZW50cy5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgIExheW91dC5yZXNpemUoKTtcbiAgICBhcHBseVN0eWxlKEVsZW1lbnRzLnRyYWNrLCB7XG4gICAgICBoZWlnaHQ6IHVuaXQoTGF5b3V0LmhlaWdodClcbiAgICB9KTtcbiAgICB2YXIgc2xpZGVIZWlnaHQgPSBvcHRpb25zLmF1dG9IZWlnaHQgPyBudWxsIDogdW5pdChMYXlvdXQuc2xpZGVIZWlnaHQoKSk7XG4gICAgRWxlbWVudHMuZWFjaChmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgIGFwcGx5U3R5bGUoU2xpZGUuY29udGFpbmVyLCB7XG4gICAgICAgIGhlaWdodDogc2xpZGVIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgYXBwbHlTdHlsZShTbGlkZS5zbGlkZSwge1xuICAgICAgICB3aWR0aDogb3B0aW9ucy5hdXRvV2lkdGggPyBudWxsIDogdW5pdChMYXlvdXQuc2xpZGVXaWR0aChTbGlkZS5pbmRleCkpLFxuICAgICAgICBoZWlnaHQ6IFNsaWRlLmNvbnRhaW5lciA/IG51bGwgOiBzbGlkZUhlaWdodFxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgU3BsaWRlLmVtaXQoJ3Jlc2l6ZWQnKTtcbiAgfVxuXG4gIHJldHVybiBMYXlvdXQ7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2RyYWcvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBzdXBwb3J0aW5nIG1vdXNlIGRyYWcgYW5kIHN3aXBlLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG5cblxudmFyIGRyYWdfYWJzID0gTWF0aC5hYnM7XG4vKipcclxuICogSWYgdGhlIGFic29sdXRlIHZlbG9jaXR5IGlzIGdyZWF0ZXIgdGhhbnQgdGhpcyB2YWx1ZSxcclxuICogYSBzbGlkZXIgYWx3YXlzIGdvZXMgdG8gYSBkaWZmZXJlbnQgc2xpZGUgYWZ0ZXIgZHJhZywgbm90IGFsbG93ZWQgdG8gc3RheSBvbiBhIGN1cnJlbnQgc2xpZGUuXHJcbiAqL1xuXG52YXIgTUlOX1ZFTE9DSVRZID0gMC4xO1xuLyoqXHJcbiAqIEFkanVzdCBob3cgbXVjaCB0aGUgdHJhY2sgY2FuIGJlIHB1bGxlZCBvbiB0aGUgZmlyc3Qgb3IgbGFzdCBwYWdlLlxyXG4gKiBUaGUgbGFyZ2VyIG51bWJlciB0aGlzIGlzLCB0aGUgZmFydGhlciB0aGUgdHJhY2sgbW92ZXMuXHJcbiAqIFRoaXMgc2hvdWxkIGJlIGFyb3VuZCA1IC0gOS5cclxuICpcclxuICogQHR5cGUge251bWJlcn1cclxuICovXG5cbnZhciBGUklDVElPTl9SRURVQ0VSID0gNztcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IHN1cHBvcnRpbmcgbW91c2UgZHJhZyBhbmQgc3dpcGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBkcmFnID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMpIHtcbiAgLyoqXHJcbiAgICogU3RvcmUgdGhlIE1vdmUgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cbiAgdmFyIFRyYWNrID0gQ29tcG9uZW50cy5UcmFjaztcbiAgLyoqXHJcbiAgICogU3RvcmUgdGhlIENvbnRyb2xsZXIgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgQ29udHJvbGxlciA9IENvbXBvbmVudHMuQ29udHJvbGxlcjtcbiAgLyoqXHJcbiAgICogQ29vcmRpbmF0ZSBvZiB0aGUgdHJhY2sgb24gc3RhcnRpbmcgZHJhZy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIHN0YXJ0Q29vcmQ7XG4gIC8qKlxyXG4gICAqIEFuYWx5emVkIGluZm8gb24gc3RhcnRpbmcgZHJhZy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cclxuICAgKi9cblxuICB2YXIgc3RhcnRJbmZvO1xuICAvKipcclxuICAgKiBBbmFseXplZCBpbmZvIGJlaW5nIHVwZGF0ZWQgd2hpbGUgZHJhZ2dpbmcvc3dpcGluZy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIGN1cnJlbnRJbmZvO1xuICAvKipcclxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBzbGlkZXMgYXJlIGJlaW5nIGRyYWdnZWQgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG5cbiAgdmFyIGlzRHJhZ2dpbmc7XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIHNsaWRlciBkaXJlY3Rpb24gaXMgdmVydGljYWwgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG5cbiAgdmFyIGlzVmVydGljYWwgPSBTcGxpZGUub3B0aW9ucy5kaXJlY3Rpb24gPT09IFRUQjtcbiAgLyoqXHJcbiAgICogQXhpcyBmb3IgdGhlIGRpcmVjdGlvbi5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXG5cbiAgdmFyIGF4aXMgPSBpc1ZlcnRpY2FsID8gJ3knIDogJ3gnO1xuICAvKipcclxuICAgKiBEcmFnIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBEcmFnID0ge1xuICAgIC8qKlxyXG4gICAgICogV2hldGhlciBkcmFnZ2luZyBpcyBkaXNhYmxlZCBvciBub3QuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cbiAgICBkaXNhYmxlZDogZmFsc2UsXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBFbGVtZW50cyA9IENvbXBvbmVudHMuRWxlbWVudHM7XG4gICAgICB2YXIgdHJhY2sgPSBFbGVtZW50cy50cmFjaztcbiAgICAgIFNwbGlkZS5vbigndG91Y2hzdGFydCBtb3VzZWRvd24nLCBzdGFydCwgdHJhY2spLm9uKCd0b3VjaG1vdmUgbW91c2Vtb3ZlJywgbW92ZSwgdHJhY2ssIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pLm9uKCd0b3VjaGVuZCB0b3VjaGNhbmNlbCBtb3VzZWxlYXZlIG1vdXNldXAgZHJhZ2VuZCcsIGVuZCwgdHJhY2spLm9uKCdtb3VudGVkIHJlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFByZXZlbnQgZHJhZ2dpbmcgYW4gaW1hZ2Ugb3IgYW5jaG9yIGl0c2VsZi5cbiAgICAgICAgZWFjaChFbGVtZW50cy5saXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2ltZywgYScpLCBmdW5jdGlvbiAoZWxtKSB7XG4gICAgICAgICAgU3BsaWRlLm9mZignZHJhZ3N0YXJ0JywgZWxtKS5vbignZHJhZ3N0YXJ0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9LCBlbG0sIHtcbiAgICAgICAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkub24oJ21vdW50ZWQgdXBkYXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZGlzYWJsZWQgPSAhU3BsaWRlLm9wdGlvbnMuZHJhZztcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHRyYWNrIHN0YXJ0cyB0byBiZSBkcmFnZ2VkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fE1vdXNlRXZlbnR9IGUgLSBUb3VjaEV2ZW50IG9yIE1vdXNlRXZlbnQgb2JqZWN0LlxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHN0YXJ0KGUpIHtcbiAgICBpZiAoIURyYWcuZGlzYWJsZWQgJiYgIWlzRHJhZ2dpbmcpIHtcbiAgICAgIC8vIFRoZXNlIHByYW1zIGFyZSB1c2VkIHRvIGV2YWx1YXRlIHdoZXRoZXIgdGhlIHNsaWRlciBzaG91bGQgc3RhcnQgbW92aW5nLlxuICAgICAgaW5pdChlKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBwYXJhbWV0ZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fE1vdXNlRXZlbnR9IGUgLSBUb3VjaEV2ZW50IG9yIE1vdXNlRXZlbnQgb2JqZWN0LlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5pdChlKSB7XG4gICAgc3RhcnRDb29yZCA9IFRyYWNrLnRvQ29vcmQoVHJhY2sucG9zaXRpb24pO1xuICAgIHN0YXJ0SW5mbyA9IGFuYWx5emUoZSwge30pO1xuICAgIGN1cnJlbnRJbmZvID0gc3RhcnRJbmZvO1xuICB9XG4gIC8qKlxyXG4gICAqIENhbGxlZCB3aGlsZSB0aGUgdHJhY2sgYmVpbmcgZHJhZ2dlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudHxNb3VzZUV2ZW50fSBlIC0gVG91Y2hFdmVudCBvciBNb3VzZUV2ZW50IG9iamVjdC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG1vdmUoZSkge1xuICAgIGlmIChzdGFydEluZm8pIHtcbiAgICAgIGN1cnJlbnRJbmZvID0gYW5hbHl6ZShlLCBzdGFydEluZm8pO1xuXG4gICAgICBpZiAoaXNEcmFnZ2luZykge1xuICAgICAgICBpZiAoZS5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFTcGxpZGUuaXMoRkFERSkpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSBzdGFydENvb3JkW2F4aXNdICsgY3VycmVudEluZm8ub2Zmc2V0W2F4aXNdO1xuICAgICAgICAgIFRyYWNrLnRyYW5zbGF0ZShyZXNpc3QocG9zaXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNob3VsZE1vdmUoY3VycmVudEluZm8pKSB7XG4gICAgICAgICAgU3BsaWRlLmVtaXQoJ2RyYWcnLCBzdGFydEluZm8pO1xuICAgICAgICAgIGlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgIFRyYWNrLmNhbmNlbCgpOyAvLyBUaGVzZSBwYXJhbXMgYXJlIGFjdHVhbCBkcmFnIGRhdGEuXG5cbiAgICAgICAgICBpbml0KGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIERldGVybWluZSB3aGV0aGVyIHRvIHN0YXJ0IG1vdmluZyB0aGUgdHJhY2sgb3Igbm90IGJ5IGRyYWcgYW5nbGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5mbyAtIEFuIGluZm9ybWF0aW9uIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgdHJhY2sgc2hvdWxkIGJlIG1vdmVkIG9yIGZhbHNlIGlmIG5vdC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHNob3VsZE1vdmUoX3JlZikge1xuICAgIHZhciBvZmZzZXQgPSBfcmVmLm9mZnNldDtcblxuICAgIGlmIChTcGxpZGUuU3RhdGUuaXMoTU9WSU5HKSAmJiBTcGxpZGUub3B0aW9ucy53YWl0Rm9yVHJhbnNpdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbihkcmFnX2FicyhvZmZzZXQueSkgLyBkcmFnX2FicyhvZmZzZXQueCkpICogMTgwIC8gTWF0aC5QSTtcblxuICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICBhbmdsZSA9IDkwIC0gYW5nbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuZ2xlIDwgU3BsaWRlLm9wdGlvbnMuZHJhZ0FuZ2xlVGhyZXNob2xkO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlc2lzdCBkcmFnZ2luZyB0aGUgdHJhY2sgb24gdGhlIGZpcnN0L2xhc3QgcGFnZSBiZWNhdXNlIHRoZXJlIGlzIG5vIG1vcmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb24gLSBBIHBvc2l0aW9uIGJlaW5nIGFwcGxpZWQgdG8gdGhlIHRyYWNrLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSAtIEFkanVzdGVkIHBvc2l0aW9uLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcmVzaXN0KHBvc2l0aW9uKSB7XG4gICAgaWYgKFNwbGlkZS5pcyhTTElERSkpIHtcbiAgICAgIHZhciBzaWduID0gVHJhY2suc2lnbjtcblxuICAgICAgdmFyIF9zdGFydCA9IHNpZ24gKiBUcmFjay50cmltKFRyYWNrLnRvUG9zaXRpb24oMCkpO1xuXG4gICAgICB2YXIgX2VuZCA9IHNpZ24gKiBUcmFjay50cmltKFRyYWNrLnRvUG9zaXRpb24oQ29udHJvbGxlci5lZGdlSW5kZXgpKTtcblxuICAgICAgcG9zaXRpb24gKj0gc2lnbjtcblxuICAgICAgaWYgKHBvc2l0aW9uIDwgX3N0YXJ0KSB7XG4gICAgICAgIHBvc2l0aW9uID0gX3N0YXJ0IC0gRlJJQ1RJT05fUkVEVUNFUiAqIE1hdGgubG9nKF9zdGFydCAtIHBvc2l0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPiBfZW5kKSB7XG4gICAgICAgIHBvc2l0aW9uID0gX2VuZCArIEZSSUNUSU9OX1JFRFVDRVIgKiBNYXRoLmxvZyhwb3NpdGlvbiAtIF9lbmQpO1xuICAgICAgfVxuXG4gICAgICBwb3NpdGlvbiAqPSBzaWduO1xuICAgIH1cblxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfVxuICAvKipcclxuICAgKiBDYWxsZWQgd2hlbiBkcmFnZ2luZyBlbmRzLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5kKCkge1xuICAgIHN0YXJ0SW5mbyA9IG51bGw7XG5cbiAgICBpZiAoaXNEcmFnZ2luZykge1xuICAgICAgU3BsaWRlLmVtaXQoJ2RyYWdnZWQnLCBjdXJyZW50SW5mbyk7XG4gICAgICBnbyhjdXJyZW50SW5mbyk7XG4gICAgICBpc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEdvIHRvIHRoZSBzbGlkZSBkZXRlcm1pbmVkIGJ5IHRoZSBhbmFseXplZCBkYXRhLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGluZm8gLSBBbiBpbmZvIG9iamVjdC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdvKGluZm8pIHtcbiAgICB2YXIgdmVsb2NpdHkgPSBpbmZvLnZlbG9jaXR5W2F4aXNdO1xuICAgIHZhciBhYnNWID0gZHJhZ19hYnModmVsb2NpdHkpO1xuXG4gICAgaWYgKGFic1YgPiAwKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgICAgdmFyIGluZGV4ID0gU3BsaWRlLmluZGV4O1xuICAgICAgdmFyIHNpZ24gPSB2ZWxvY2l0eSA8IDAgPyAtMSA6IDE7XG4gICAgICB2YXIgZGVzdEluZGV4ID0gaW5kZXg7XG5cbiAgICAgIGlmICghU3BsaWRlLmlzKEZBREUpKSB7XG4gICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IFRyYWNrLnBvc2l0aW9uO1xuXG4gICAgICAgIGlmIChhYnNWID4gb3B0aW9ucy5mbGlja1ZlbG9jaXR5VGhyZXNob2xkICYmIGRyYWdfYWJzKGluZm8ub2Zmc2V0W2F4aXNdKSA8IG9wdGlvbnMuc3dpcGVEaXN0YW5jZVRocmVzaG9sZCkge1xuICAgICAgICAgIGRlc3RpbmF0aW9uICs9IHNpZ24gKiBNYXRoLm1pbihhYnNWICogb3B0aW9ucy5mbGlja1Bvd2VyLCBDb21wb25lbnRzLkxheW91dC5zaXplICogKG9wdGlvbnMuZmxpY2tNYXhQYWdlcyB8fCAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0SW5kZXggPSBUcmFjay50b0luZGV4KGRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIC8qXHJcbiAgICAgICAqIERvIG5vdCBhbGxvdyB0aGUgdHJhY2sgdG8gZ28gdG8gYSBwcmV2aW91cyBwb3NpdGlvbiBpZiB0aGVyZSBpcyBlbm91Z2ggdmVsb2NpdHkuXHJcbiAgICAgICAqIEFsd2F5cyB1c2UgdGhlIGFkamFjZW50IGluZGV4IGZvciB0aGUgZmFkZSBtb2RlLlxyXG4gICAgICAgKi9cblxuXG4gICAgICBpZiAoZGVzdEluZGV4ID09PSBpbmRleCAmJiBhYnNWID4gTUlOX1ZFTE9DSVRZKSB7XG4gICAgICAgIGRlc3RJbmRleCA9IGluZGV4ICsgc2lnbiAqIFRyYWNrLnNpZ247XG4gICAgICB9XG5cbiAgICAgIGlmIChTcGxpZGUuaXMoU0xJREUpKSB7XG4gICAgICAgIGRlc3RJbmRleCA9IGJldHdlZW4oZGVzdEluZGV4LCAwLCBDb250cm9sbGVyLmVkZ2VJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIENvbnRyb2xsZXIuZ28oZGVzdEluZGV4LCBvcHRpb25zLmlzTmF2aWdhdGlvbik7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEFuYWx5emUgdGhlIGdpdmVuIGV2ZW50IG9iamVjdCBhbmQgcmV0dXJuIGltcG9ydGFudCBpbmZvcm1hdGlvbiBmb3IgaGFuZGxpbmcgc3dpcGUgYmVoYXZpb3IuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50fSAgIGUgICAgICAgICAgLSBUb3VjaCBvciBNb3VzZSBldmVudCBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9ICBzdGFydEluZm8gIC0gSW5mb3JtYXRpb24gYW5hbHl6ZWQgb24gc3RhcnQgZm9yIGNhbGN1bGF0aW5nIGRpZmZlcmVuY2UgZnJvbSB0aGUgY3VycmVudCBvbmUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgYW5hbHl6ZWQgaW5mb3JtYXRpb24sIHN1Y2ggYXMgb2Zmc2V0LCB2ZWxvY2l0eSwgZXRjLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYW5hbHl6ZShlLCBzdGFydEluZm8pIHtcbiAgICB2YXIgdGltZVN0YW1wID0gZS50aW1lU3RhbXAsXG4gICAgICAgIHRvdWNoZXMgPSBlLnRvdWNoZXM7XG5cbiAgICB2YXIgX3JlZjIgPSB0b3VjaGVzID8gdG91Y2hlc1swXSA6IGUsXG4gICAgICAgIGNsaWVudFggPSBfcmVmMi5jbGllbnRYLFxuICAgICAgICBjbGllbnRZID0gX3JlZjIuY2xpZW50WTtcblxuICAgIHZhciBfcmVmMyA9IHN0YXJ0SW5mby50byB8fCB7fSxcbiAgICAgICAgX3JlZjMkeCA9IF9yZWYzLngsXG4gICAgICAgIGZyb21YID0gX3JlZjMkeCA9PT0gdm9pZCAwID8gY2xpZW50WCA6IF9yZWYzJHgsXG4gICAgICAgIF9yZWYzJHkgPSBfcmVmMy55LFxuICAgICAgICBmcm9tWSA9IF9yZWYzJHkgPT09IHZvaWQgMCA/IGNsaWVudFkgOiBfcmVmMyR5O1xuXG4gICAgdmFyIHN0YXJ0VGltZSA9IHN0YXJ0SW5mby50aW1lIHx8IDA7XG4gICAgdmFyIG9mZnNldCA9IHtcbiAgICAgIHg6IGNsaWVudFggLSBmcm9tWCxcbiAgICAgIHk6IGNsaWVudFkgLSBmcm9tWVxuICAgIH07XG4gICAgdmFyIGR1cmF0aW9uID0gdGltZVN0YW1wIC0gc3RhcnRUaW1lO1xuICAgIHZhciB2ZWxvY2l0eSA9IHtcbiAgICAgIHg6IG9mZnNldC54IC8gZHVyYXRpb24sXG4gICAgICB5OiBvZmZzZXQueSAvIGR1cmF0aW9uXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgdG86IHtcbiAgICAgICAgeDogY2xpZW50WCxcbiAgICAgICAgeTogY2xpZW50WVxuICAgICAgfSxcbiAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgdGltZTogdGltZVN0YW1wLFxuICAgICAgdmVsb2NpdHk6IHZlbG9jaXR5XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBEcmFnO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9jbGljay9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGhhbmRsaW5nIGEgY2xpY2sgZXZlbnQuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGhhbmRsaW5nIGEgY2xpY2sgZXZlbnQuXHJcbiAqIENsaWNrIHNob3VsZCBiZSBkaXNhYmxlZCBkdXJpbmcgZHJhZy9zd2lwZS5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjbGljayA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzKSB7XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgY2xpY2sgaXMgZGlzYWJsZWQgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXG4gIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xuICAvKipcclxuICAgKiBDbGljayBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgQ2xpY2sgPSB7XG4gICAgLyoqXHJcbiAgICAgKiBNb3VudCBvbmx5IHdoZW4gdGhlIGRyYWcgaXMgYWN0aXZhdGVkIGFuZCB0aGUgc2xpZGUgdHlwZSBpcyBub3QgXCJmYWRlXCIuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cbiAgICByZXF1aXJlZDogU3BsaWRlLm9wdGlvbnMuZHJhZyxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgU3BsaWRlLm9uKCdjbGljaycsIG9uQ2xpY2ssIENvbXBvbmVudHMuRWxlbWVudHMudHJhY2ssIHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfSkub24oJ2RyYWcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICAgIH0pLm9uKCdkcmFnZ2VkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZsYWcgaXMgcmVsZWFzZWQgYWZ0ZXIgdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQ2FsbGVkIHdoZW4gYSB0cmFjayBlbGVtZW50IGlzIGNsaWNrZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0V2ZW50fSBlIC0gQSBjbGljayBldmVudC5cclxuICAgKi9cblxuICBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBDbGljaztcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvYXV0b3BsYXkvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBwbGF5aW5nIHNsaWRlcyBhdXRvbWF0aWNhbGx5LlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuLyoqXHJcbiAqIFNldCBvZiBwYXVzZSBmbGFncy5cclxuICovXG5cbnZhciBQQVVTRV9GTEFHUyA9IHtcbiAgSE9WRVI6IDEsXG4gIEZPQ1VTOiAyLFxuICBNQU5VQUw6IDNcbn07XG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgcGxheWluZyBzbGlkZXMgYXV0b21hdGljYWxseS5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgICAtIEEgY29tcG9uZW50IG5hbWUgYXMgYSBsb3dlcmNhc2Ugc3RyaW5nLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGF1dG9wbGF5ID0gKGZ1bmN0aW9uIChTcGxpZGUsIENvbXBvbmVudHMsIG5hbWUpIHtcbiAgLyoqXHJcbiAgICogU3RvcmUgcGF1c2UgZmxhZ3MuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICovXG4gIHZhciBmbGFncyA9IFtdO1xuICAvKipcclxuICAgKiBTdG9yZSBhbiBpbnRlcnZhbCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fTtcclxuICAgKi9cblxuICB2YXIgaW50ZXJ2YWw7XG4gIC8qKlxyXG4gICAqIEtlZXAgdGhlIEVsZW1lbnRzIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICovXG5cbiAgdmFyIEVsZW1lbnRzID0gQ29tcG9uZW50cy5FbGVtZW50cztcbiAgLyoqXHJcbiAgICogQXV0b3BsYXkgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIEF1dG9wbGF5ID0ge1xuICAgIC8qKlxyXG4gICAgICogUmVxdWlyZWQgb25seSB3aGVuIHRoZSBhdXRvcGxheSBvcHRpb24gaXMgdHJ1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xuICAgIHJlcXVpcmVkOiBTcGxpZGUub3B0aW9ucy5hdXRvcGxheSxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICogTm90ZSB0aGF0IGF1dG9wbGF5IHN0YXJ0cyBvbmx5IGlmIHRoZXJlIGFyZSBzbGlkZXMgb3ZlciBwZXJQYWdlIG51bWJlci5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG5cbiAgICAgIGlmIChFbGVtZW50cy5zbGlkZXMubGVuZ3RoID4gb3B0aW9ucy5wZXJQYWdlKSB7XG4gICAgICAgIGludGVydmFsID0gY3JlYXRlSW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIFNwbGlkZS5nbygnPicpO1xuICAgICAgICB9LCBvcHRpb25zLmludGVydmFsLCBmdW5jdGlvbiAocmF0ZSkge1xuICAgICAgICAgIFNwbGlkZS5lbWl0KG5hbWUgKyBcIjpwbGF5aW5nXCIsIHJhdGUpO1xuXG4gICAgICAgICAgaWYgKEVsZW1lbnRzLmJhcikge1xuICAgICAgICAgICAgYXBwbHlTdHlsZShFbGVtZW50cy5iYXIsIHtcbiAgICAgICAgICAgICAgd2lkdGg6IHJhdGUgKiAxMDAgKyBcIiVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYmluZCgpO1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBhdXRvcGxheS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZmxhZyAtIEEgcGF1c2UgZmxhZyB0byBiZSByZW1vdmVkLlxyXG4gICAgICovXG4gICAgcGxheTogZnVuY3Rpb24gcGxheShmbGFnKSB7XG4gICAgICBpZiAoZmxhZyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGZsYWcgPSAwO1xuICAgICAgfVxuXG4gICAgICBmbGFncyA9IGZsYWdzLmZpbHRlcihmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZiAhPT0gZmxhZztcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWZsYWdzLmxlbmd0aCkge1xuICAgICAgICBTcGxpZGUuZW1pdChuYW1lICsgXCI6cGxheVwiKTtcbiAgICAgICAgaW50ZXJ2YWwucGxheShTcGxpZGUub3B0aW9ucy5yZXNldFByb2dyZXNzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBQYXVzZSBhdXRvcGxheS5cclxuICAgICAqIE5vdGUgdGhhdCBBcnJheS5pbmNsdWRlcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmbGFnIC0gQSBwYXVzZSBmbGFnIHRvIGJlIGFkZGVkLlxyXG4gICAgICovXG4gICAgcGF1c2U6IGZ1bmN0aW9uIHBhdXNlKGZsYWcpIHtcbiAgICAgIGlmIChmbGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgZmxhZyA9IDA7XG4gICAgICB9XG5cbiAgICAgIGludGVydmFsLnBhdXNlKCk7XG5cbiAgICAgIGlmIChmbGFncy5pbmRleE9mKGZsYWcpID09PSAtMSkge1xuICAgICAgICBmbGFncy5wdXNoKGZsYWcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxhZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIFNwbGlkZS5lbWl0KG5hbWUgKyBcIjpwYXVzZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIExpc3RlbiBzb21lIGV2ZW50cy5cclxuICAgKi9cblxuICBmdW5jdGlvbiBiaW5kKCkge1xuICAgIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gICAgdmFyIHNpYmxpbmcgPSBTcGxpZGUuc2libGluZztcbiAgICB2YXIgZWxtcyA9IFtTcGxpZGUucm9vdCwgc2libGluZyA/IHNpYmxpbmcucm9vdCA6IG51bGxdO1xuXG4gICAgaWYgKG9wdGlvbnMucGF1c2VPbkhvdmVyKSB7XG4gICAgICBzd2l0Y2hPbihlbG1zLCAnbW91c2VsZWF2ZScsIFBBVVNFX0ZMQUdTLkhPVkVSLCB0cnVlKTtcbiAgICAgIHN3aXRjaE9uKGVsbXMsICdtb3VzZWVudGVyJywgUEFVU0VfRkxBR1MuSE9WRVIsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wYXVzZU9uRm9jdXMpIHtcbiAgICAgIHN3aXRjaE9uKGVsbXMsICdmb2N1c291dCcsIFBBVVNFX0ZMQUdTLkZPQ1VTLCB0cnVlKTtcbiAgICAgIHN3aXRjaE9uKGVsbXMsICdmb2N1c2luJywgUEFVU0VfRkxBR1MuRk9DVVMsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoRWxlbWVudHMucGxheSkge1xuICAgICAgU3BsaWRlLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTmVlZCB0byBiZSByZW1vdmVkIGEgZm9jdXMgZmxhZyBhdCBmaXJzdC5cbiAgICAgICAgQXV0b3BsYXkucGxheShQQVVTRV9GTEFHUy5GT0NVUyk7XG4gICAgICAgIEF1dG9wbGF5LnBsYXkoUEFVU0VfRkxBR1MuTUFOVUFMKTtcbiAgICAgIH0sIEVsZW1lbnRzLnBsYXkpO1xuICAgIH1cblxuICAgIGlmIChFbGVtZW50cy5wYXVzZSkge1xuICAgICAgc3dpdGNoT24oW0VsZW1lbnRzLnBhdXNlXSwgJ2NsaWNrJywgUEFVU0VfRkxBR1MuTUFOVUFMLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgU3BsaWRlLm9uKCdtb3ZlIHJlZnJlc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBBdXRvcGxheS5wbGF5KCk7XG4gICAgfSkgLy8gUmV3aW5kIHRoZSB0aW1lci5cbiAgICAub24oJ2Rlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICBBdXRvcGxheS5wYXVzZSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFBsYXkgb3IgcGF1c2Ugb24gdGhlIGdpdmVuIGV2ZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50W119IGVsbXMgIC0gRWxlbWVudHMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgIGV2ZW50IC0gQW4gZXZlbnQgbmFtZSBvciBuYW1lcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgZmxhZyAgLSBBIHBhdXNlIGZsYWcgZGVmaW5lZCBvbiB0aGUgdG9wLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICBwbGF5ICAtIERldGVybWluZSB3aGV0aGVyIHRvIHBsYXkgb3IgcGF1c2UuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBzd2l0Y2hPbihlbG1zLCBldmVudCwgZmxhZywgcGxheSkge1xuICAgIGVsbXMuZm9yRWFjaChmdW5jdGlvbiAoZWxtKSB7XG4gICAgICBTcGxpZGUub24oZXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQXV0b3BsYXlbcGxheSA/ICdwbGF5JyA6ICdwYXVzZSddKGZsYWcpO1xuICAgICAgfSwgZWxtKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBBdXRvcGxheTtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvY292ZXIvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBjaGFuZ2UgYW4gaW1nIGVsZW1lbnQgdG8gYmFja2dyb3VuZCBpbWFnZSBvZiBpdHMgd3JhcHBlci5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgY2hhbmdlIGFuIGltZyBlbGVtZW50IHRvIGJhY2tncm91bmQgaW1hZ2Ugb2YgaXRzIHdyYXBwZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBjb3ZlciA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzKSB7XG4gIC8qKlxyXG4gICAqIEhvbGQgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG4gIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gIC8qKlxyXG4gICAqIENvdmVyIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBDb3ZlciA9IHtcbiAgICAvKipcclxuICAgICAqIFJlcXVpcmVkIG9ubHkgd2hlbiBcImNvdmVyXCIgb3B0aW9uIGlzIHRydWUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cbiAgICByZXF1aXJlZDogb3B0aW9ucy5jb3ZlcixcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgU3BsaWRlLm9uKCdsYXp5bG9hZDpsb2FkZWQnLCBmdW5jdGlvbiAoaW1nKSB7XG4gICAgICAgIGNvdmVyKGltZywgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgICBTcGxpZGUub24oJ21vdW50ZWQgdXBkYXRlZCByZWZyZXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXBwbHkoZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveS5cclxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBhcHBseSh0cnVlKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEFwcGx5IFwiY292ZXJcIiB0byBhbGwgc2xpZGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB1bmNvdmVyIC0gSWYgdHJ1ZSwgXCJjb3ZlclwiIHdpbGwgYmUgY2xlYXIuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gYXBwbHkodW5jb3Zlcikge1xuICAgIENvbXBvbmVudHMuRWxlbWVudHMuZWFjaChmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgIHZhciBpbWcgPSBjaGlsZChTbGlkZS5zbGlkZSwgJ0lNRycpIHx8IGNoaWxkKFNsaWRlLmNvbnRhaW5lciwgJ0lNRycpO1xuXG4gICAgICBpZiAoaW1nICYmIGltZy5zcmMpIHtcbiAgICAgICAgY292ZXIoaW1nLCB1bmNvdmVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBTZXQgYmFja2dyb3VuZCBpbWFnZSBvZiB0aGUgcGFyZW50IGVsZW1lbnQsIHVzaW5nIHNvdXJjZSBvZiB0aGUgZ2l2ZW4gaW1hZ2UgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gaW1nICAgICAtIEFuIGltYWdlIGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtib29sZWFufSB1bmNvdmVyIC0gUmVzZXQgXCJjb3ZlclwiLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gY292ZXIoaW1nLCB1bmNvdmVyKSB7XG4gICAgYXBwbHlTdHlsZShpbWcucGFyZW50RWxlbWVudCwge1xuICAgICAgYmFja2dyb3VuZDogdW5jb3ZlciA/ICcnIDogXCJjZW50ZXIvY292ZXIgbm8tcmVwZWF0IHVybChcXFwiXCIgKyBpbWcuc3JjICsgXCJcXFwiKVwiXG4gICAgfSk7XG4gICAgYXBwbHlTdHlsZShpbWcsIHtcbiAgICAgIGRpc3BsYXk6IHVuY292ZXIgPyAnJyA6ICdub25lJ1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIENvdmVyO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9hcnJvd3MvcGF0aC5qc1xuLyoqXHJcbiAqIEV4cG9ydCB2ZWN0b3IgcGF0aCBmb3IgYW4gYXJyb3cuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuLyoqXHJcbiAqIE5hbWVzcGFjZSBkZWZpbml0aW9uIGZvciBTVkcgZWxlbWVudC5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG52YXIgWE1MX05BTUVfU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuLyoqXHJcbiAqIFRoZSBhcnJvdyB2ZWN0b3IgcGF0aC5cclxuICpcclxuICogQHR5cGUge251bWJlcn1cclxuICovXG5cbnZhciBQQVRIID0gJ20xNS41IDAuOTMyLTQuMyA0LjM4IDE0LjUgMTQuNi0xNC41IDE0LjUgNC4zIDQuNCAxNC42LTE0LjYgNC40LTQuMy00LjQtNC40LTE0LjYtMTQuNnonO1xuLyoqXHJcbiAqIFNWRyB3aWR0aCBhbmQgaGVpZ2h0LlxyXG4gKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKi9cblxudmFyIFNJWkUgPSA0MDtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2Fycm93cy9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGFwcGVuZGluZyBwcmV2L25leHQgYXJyb3dzLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgYXBwZW5kaW5nIHByZXYvbmV4dCBhcnJvd3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgICAgLSBBIGNvbXBvbmVudCBuYW1lIGFzIGEgbG93ZXJjYXNlIHN0cmluZy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBhcnJvd3MgPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cywgbmFtZSkge1xuICAvKipcclxuICAgKiBQcmV2aW91cyBhcnJvdyBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR8dW5kZWZpbmVkfVxyXG4gICAqL1xuICB2YXIgcHJldjtcbiAgLyoqXHJcbiAgICogTmV4dCBhcnJvdyBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR8dW5kZWZpbmVkfVxyXG4gICAqL1xuXG4gIHZhciBuZXh0O1xuICAvKipcclxuICAgKiBTdG9yZSB0aGUgY2xhc3MgbGlzdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIGNsYXNzZXMgPSBTcGxpZGUuY2xhc3NlcztcbiAgLyoqXHJcbiAgICogSG9sZCB0aGUgcm9vdCBlbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge0VsZW1lbnR9XHJcbiAgICovXG5cbiAgdmFyIHJvb3QgPSBTcGxpZGUucm9vdDtcbiAgLyoqXHJcbiAgICogV2hldGhlciBhcnJvd3MgYXJlIGNyZWF0ZWQgcHJvZ3JhbW1hdGljYWxseSBvciBub3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cblxuICB2YXIgY3JlYXRlZDtcbiAgLyoqXHJcbiAgICogSG9sZCB0aGUgRWxlbWVudHMgY29tcG9uZW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgRWxlbWVudHMgPSBDb21wb25lbnRzLkVsZW1lbnRzO1xuICAvKipcclxuICAgKiBBcnJvd3MgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIEFycm93cyA9IHtcbiAgICAvKipcclxuICAgICAqIFJlcXVpcmVkIHdoZW4gdGhlIGFycm93cyBvcHRpb24gaXMgdHJ1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xuICAgIHJlcXVpcmVkOiBTcGxpZGUub3B0aW9ucy5hcnJvd3MsXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIC8vIEF0dGVtcHQgdG8gZ2V0IGFycm93cyBmcm9tIEhUTUwgc291cmNlLlxuICAgICAgcHJldiA9IEVsZW1lbnRzLmFycm93cy5wcmV2O1xuICAgICAgbmV4dCA9IEVsZW1lbnRzLmFycm93cy5uZXh0OyAvLyBJZiBhcnJvd3Mgd2VyZSBub3QgZm91bmQgaW4gSFRNTCwgbGV0J3MgZ2VuZXJhdGUgdGhlbS5cblxuICAgICAgaWYgKCghcHJldiB8fCAhbmV4dCkgJiYgU3BsaWRlLm9wdGlvbnMuYXJyb3dzKSB7XG4gICAgICAgIHByZXYgPSBjcmVhdGVBcnJvdyh0cnVlKTtcbiAgICAgICAgbmV4dCA9IGNyZWF0ZUFycm93KGZhbHNlKTtcbiAgICAgICAgY3JlYXRlZCA9IHRydWU7XG4gICAgICAgIGFwcGVuZEFycm93cygpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldiAmJiBuZXh0KSB7XG4gICAgICAgIGJpbmQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcnJvd3MgPSB7XG4gICAgICAgIHByZXY6IHByZXYsXG4gICAgICAgIG5leHQ6IG5leHRcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFmdGVyIGFsbCBjb21wb25lbnRzIGFyZSBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIFNwbGlkZS5lbWl0KG5hbWUgKyBcIjptb3VudGVkXCIsIHByZXYsIG5leHQpO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kuXHJcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgcmVtb3ZlQXR0cmlidXRlKFtwcmV2LCBuZXh0XSwgJ2Rpc2FibGVkJyk7XG5cbiAgICAgIGlmIChjcmVhdGVkKSB7XG4gICAgICAgIGRvbV9yZW1vdmUocHJldi5wYXJlbnRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIExpc3RlbiB0byBuYXRpdmUgYW5kIGN1c3RvbSBldmVudHMuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gYmluZCgpIHtcbiAgICBTcGxpZGUub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgU3BsaWRlLmdvKCc8Jyk7XG4gICAgfSwgcHJldikub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgU3BsaWRlLmdvKCc+Jyk7XG4gICAgfSwgbmV4dCkub24oJ21vdW50ZWQgbW92ZSB1cGRhdGVkIHJlZnJlc2gnLCB1cGRhdGVEaXNhYmxlZCk7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIGEgZGlzYWJsZWQgYXR0cmlidXRlLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gdXBkYXRlRGlzYWJsZWQoKSB7XG4gICAgdmFyIF9Db21wb25lbnRzJENvbnRyb2xsZSA9IENvbXBvbmVudHMuQ29udHJvbGxlcixcbiAgICAgICAgcHJldkluZGV4ID0gX0NvbXBvbmVudHMkQ29udHJvbGxlLnByZXZJbmRleCxcbiAgICAgICAgbmV4dEluZGV4ID0gX0NvbXBvbmVudHMkQ29udHJvbGxlLm5leHRJbmRleDtcbiAgICB2YXIgaXNFbm91Z2ggPSBTcGxpZGUubGVuZ3RoID4gU3BsaWRlLm9wdGlvbnMucGVyUGFnZSB8fCBTcGxpZGUuaXMoTE9PUCk7XG4gICAgcHJldi5kaXNhYmxlZCA9IHByZXZJbmRleCA8IDAgfHwgIWlzRW5vdWdoO1xuICAgIG5leHQuZGlzYWJsZWQgPSBuZXh0SW5kZXggPCAwIHx8ICFpc0Vub3VnaDtcbiAgICBTcGxpZGUuZW1pdChuYW1lICsgXCI6dXBkYXRlZFwiLCBwcmV2LCBuZXh0LCBwcmV2SW5kZXgsIG5leHRJbmRleCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgd3JhcHBlciBlbGVtZW50IGFuZCBhcHBlbmQgYXJyb3dzLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gYXBwZW5kQXJyb3dzKCkge1xuICAgIHZhciB3cmFwcGVyID0gY3JlYXRlKCdkaXYnLCB7XG4gICAgICBcImNsYXNzXCI6IGNsYXNzZXMuYXJyb3dzXG4gICAgfSk7XG4gICAgYXBwZW5kKHdyYXBwZXIsIHByZXYpO1xuICAgIGFwcGVuZCh3cmFwcGVyLCBuZXh0KTtcbiAgICB2YXIgc2xpZGVyID0gRWxlbWVudHMuc2xpZGVyO1xuICAgIHZhciBwYXJlbnQgPSBTcGxpZGUub3B0aW9ucy5hcnJvd3MgPT09ICdzbGlkZXInICYmIHNsaWRlciA/IHNsaWRlciA6IHJvb3Q7XG4gICAgYmVmb3JlKHdyYXBwZXIsIHBhcmVudC5maXJzdEVsZW1lbnRDaGlsZCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGFuIGFycm93IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHByZXYgLSBEZXRlcm1pbmUgdG8gY3JlYXRlIGEgcHJldiBhcnJvdyBvciBuZXh0IGFycm93LlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWxlbWVudH0gLSBBIGNyZWF0ZWQgYXJyb3cgZWxlbWVudC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycm93KHByZXYpIHtcbiAgICB2YXIgYXJyb3cgPSBcIjxidXR0b24gY2xhc3M9XFxcIlwiICsgY2xhc3Nlcy5hcnJvdyArIFwiIFwiICsgKHByZXYgPyBjbGFzc2VzLnByZXYgOiBjbGFzc2VzLm5leHQpICsgXCJcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCI+XCIgKyAoXCI8c3ZnIHhtbG5zPVxcXCJcIiArIFhNTF9OQU1FX1NQQUNFICsgXCJcXFwiXFx0dmlld0JveD1cXFwiMCAwIFwiICsgU0laRSArIFwiIFwiICsgU0laRSArIFwiXFxcIlxcdHdpZHRoPVxcXCJcIiArIFNJWkUgKyBcIlxcXCJcXHRoZWlnaHQ9XFxcIlwiICsgU0laRSArIFwiXFxcIj5cIikgKyAoXCI8cGF0aCBkPVxcXCJcIiArIChTcGxpZGUub3B0aW9ucy5hcnJvd1BhdGggfHwgUEFUSCkgKyBcIlxcXCIgLz5cIik7XG4gICAgcmV0dXJuIGRvbWlmeShhcnJvdyk7XG4gIH1cblxuICByZXR1cm4gQXJyb3dzO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9wYWdpbmF0aW9uL2luZGV4LmpzXG4vKipcclxuICogVGhlIGNvbXBvbmVudCBmb3IgaGFuZGxpbmcgcGFnaW5hdGlvblxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuLyoqXHJcbiAqIFRoZSBldmVudCBuYW1lIGZvciB1cGRhdGluZyBzb21lIGF0dHJpYnV0ZXMgb2YgcGFnaW5hdGlvbiBub2Rlcy5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBBVFRSSUJVVEVTX1VQREFURV9FVkVOVCA9ICdtb3ZlLnBhZ2UnO1xuLyoqXHJcbiAqIFRoZSBldmVudCBuYW1lIGZvciByZWNyZWF0aW5nIHBhZ2luYXRpb24uXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgVVBEQVRFX0VWRU5UID0gJ3VwZGF0ZWQucGFnZSByZWZyZXNoLnBhZ2UnO1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGhhbmRsaW5nIHBhZ2luYXRpb25cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAgICAgLSBBIFNwbGlkZSBpbnN0YW5jZS5cclxuICogQHBhcmFtIHtPYmplY3R9IENvbXBvbmVudHMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb21wb25lbnRzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgICAgICAtIEEgY29tcG9uZW50IG5hbWUgYXMgYSBsb3dlcmNhc2Ugc3RyaW5nLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHBhZ2luYXRpb24gPSAoZnVuY3Rpb24gKFNwbGlkZSwgQ29tcG9uZW50cywgbmFtZSkge1xuICAvKipcclxuICAgKiBTdG9yZSBhbGwgZGF0YSBmb3IgcGFnaW5hdGlvbi5cclxuICAgKiAtIGxpc3Q6IEEgbGlzdCBlbGVtZW50LlxyXG4gICAqIC0gaXRlbXM6IEFuIGFycmF5IHRoYXQgY29udGFpbnMgb2JqZWN0cyhsaSwgYnV0dG9uLCBpbmRleCwgcGFnZSkuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuICB2YXIgZGF0YSA9IHt9O1xuICAvKipcclxuICAgKiBIb2xkIHRoZSBFbGVtZW50cyBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBFbGVtZW50cyA9IENvbXBvbmVudHMuRWxlbWVudHM7XG4gIC8qKlxyXG4gICAqIFBhZ2luYXRpb24gY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIFBhZ2luYXRpb24gPSB7XG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICB2YXIgcGFnaW5hdGlvbiA9IFNwbGlkZS5vcHRpb25zLnBhZ2luYXRpb247XG5cbiAgICAgIGlmIChwYWdpbmF0aW9uKSB7XG4gICAgICAgIGRhdGEgPSBjcmVhdGVQYWdpbmF0aW9uKCk7XG4gICAgICAgIHZhciBzbGlkZXIgPSBFbGVtZW50cy5zbGlkZXI7XG4gICAgICAgIHZhciBwYXJlbnQgPSBwYWdpbmF0aW9uID09PSAnc2xpZGVyJyAmJiBzbGlkZXIgPyBzbGlkZXIgOiBTcGxpZGUucm9vdDtcbiAgICAgICAgYXBwZW5kKHBhcmVudCwgZGF0YS5saXN0KTtcbiAgICAgICAgU3BsaWRlLm9uKEFUVFJJQlVURVNfVVBEQVRFX0VWRU5ULCB1cGRhdGVBdHRyaWJ1dGVzKTtcbiAgICAgIH1cblxuICAgICAgU3BsaWRlLm9mZihVUERBVEVfRVZFTlQpLm9uKFVQREFURV9FVkVOVCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBQYWdpbmF0aW9uLmRlc3Ryb3koKTtcblxuICAgICAgICBpZiAoU3BsaWRlLm9wdGlvbnMucGFnaW5hdGlvbikge1xuICAgICAgICAgIFBhZ2luYXRpb24ubW91bnQoKTtcbiAgICAgICAgICBQYWdpbmF0aW9uLm1vdW50ZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFmdGVyIGFsbCBjb21wb25lbnRzIGFyZSBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIGlmIChTcGxpZGUub3B0aW9ucy5wYWdpbmF0aW9uKSB7XG4gICAgICAgIHZhciBpbmRleCA9IFNwbGlkZS5pbmRleDtcbiAgICAgICAgU3BsaWRlLmVtaXQobmFtZSArIFwiOm1vdW50ZWRcIiwgZGF0YSwgdGhpcy5nZXRJdGVtKGluZGV4KSk7XG4gICAgICAgIHVwZGF0ZUF0dHJpYnV0ZXMoaW5kZXgsIC0xKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95IHRoZSBwYWdpbmF0aW9uLlxyXG4gICAgICogQmUgYXdhcmUgdGhhdCBub2RlLnJlbW92ZSgpIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUuXHJcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgZG9tX3JlbW92ZShkYXRhLmxpc3QpO1xuXG4gICAgICBpZiAoZGF0YS5pdGVtcykge1xuICAgICAgICBkYXRhLml0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBTcGxpZGUub2ZmKCdjbGljaycsIGl0ZW0uYnV0dG9uKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIERvIG5vdCByZW1vdmUgVVBEQVRFX0VWRU5UIHRvIHJlY3JlYXRlIHBhZ2luYXRpb24gaWYgbmVlZGVkLlxuXG5cbiAgICAgIFNwbGlkZS5vZmYoQVRUUklCVVRFU19VUERBVEVfRVZFTlQpO1xuICAgICAgZGF0YSA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiBhbiBpdGVtIGJ5IGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIEEgc2xpZGUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fHVuZGVmaW5lZH0gLSBBbiBpdGVtIG9iamVjdCBvbiBzdWNjZXNzIG9yIHVuZGVmaW5lZCBvbiBmYWlsdXJlLlxyXG4gICAgICovXG4gICAgZ2V0SXRlbTogZnVuY3Rpb24gZ2V0SXRlbShpbmRleCkge1xuICAgICAgcmV0dXJuIGRhdGEuaXRlbXNbQ29tcG9uZW50cy5Db250cm9sbGVyLnRvUGFnZShpbmRleCldO1xuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIFJldHVybiBvYmplY3QgY29udGFpbmluZyBwYWdpbmF0aW9uIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSAtIFBhZ2luYXRpb24gZGF0YSBpbmNsdWRpbmcgbGlzdCBhbmQgaXRlbXMuXHJcbiAgICAgKi9cbiAgICBnZXQgZGF0YSgpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICB9O1xuICAvKipcclxuICAgKiBVcGRhdGUgYXR0cmlidXRlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAgICAgLSBBY3RpdmUgaW5kZXguXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHByZXZJbmRleCAtIFByZXYgaW5kZXguXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gdXBkYXRlQXR0cmlidXRlcyhpbmRleCwgcHJldkluZGV4KSB7XG4gICAgdmFyIHByZXYgPSBQYWdpbmF0aW9uLmdldEl0ZW0ocHJldkluZGV4KTtcbiAgICB2YXIgY3VyciA9IFBhZ2luYXRpb24uZ2V0SXRlbShpbmRleCk7XG4gICAgdmFyIGFjdGl2ZSA9IFNUQVRVU19DTEFTU0VTLmFjdGl2ZTtcblxuICAgIGlmIChwcmV2KSB7XG4gICAgICByZW1vdmVDbGFzcyhwcmV2LmJ1dHRvbiwgYWN0aXZlKTtcbiAgICB9XG5cbiAgICBpZiAoY3Vycikge1xuICAgICAgYWRkQ2xhc3MoY3Vyci5idXR0b24sIGFjdGl2ZSk7XG4gICAgfVxuXG4gICAgU3BsaWRlLmVtaXQobmFtZSArIFwiOnVwZGF0ZWRcIiwgZGF0YSwgcHJldiwgY3Vycik7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgd3JhcHBlciBhbmQgYnV0dG9uIGVsZW1lbnRzLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSAtIEFuIG9iamVjdCBjb250YWlucyBhbGwgZGF0YS5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhZ2luYXRpb24oKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICB2YXIgY2xhc3NlcyA9IFNwbGlkZS5jbGFzc2VzO1xuICAgIHZhciBsaXN0ID0gY3JlYXRlKCd1bCcsIHtcbiAgICAgIFwiY2xhc3NcIjogY2xhc3Nlcy5wYWdpbmF0aW9uXG4gICAgfSk7XG4gICAgdmFyIGl0ZW1zID0gRWxlbWVudHMuZ2V0U2xpZGVzKGZhbHNlKS5maWx0ZXIoZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5mb2N1cyAhPT0gZmFsc2UgfHwgU2xpZGUuaW5kZXggJSBvcHRpb25zLnBlclBhZ2UgPT09IDA7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChTbGlkZSwgcGFnZSkge1xuICAgICAgdmFyIGxpID0gY3JlYXRlKCdsaScsIHt9KTtcbiAgICAgIHZhciBidXR0b24gPSBjcmVhdGUoJ2J1dHRvbicsIHtcbiAgICAgICAgXCJjbGFzc1wiOiBjbGFzc2VzLnBhZ2UsXG4gICAgICAgIHR5cGU6ICdidXR0b24nXG4gICAgICB9KTtcbiAgICAgIGFwcGVuZChsaSwgYnV0dG9uKTtcbiAgICAgIGFwcGVuZChsaXN0LCBsaSk7XG4gICAgICBTcGxpZGUub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBTcGxpZGUuZ28oXCI+XCIgKyBwYWdlKTtcbiAgICAgIH0sIGJ1dHRvbik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaTogbGksXG4gICAgICAgIGJ1dHRvbjogYnV0dG9uLFxuICAgICAgICBwYWdlOiBwYWdlLFxuICAgICAgICBTbGlkZXM6IEVsZW1lbnRzLmdldFNsaWRlc0J5UGFnZShwYWdlKVxuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGlzdDogbGlzdCxcbiAgICAgIGl0ZW1zOiBpdGVtc1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gUGFnaW5hdGlvbjtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvbGF6eWxvYWQvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBsb2FkaW5nIHNsaWRlciBpbWFnZXMgbGF6aWx5LlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuXG4vKipcclxuICogVGhlIG5hbWUgZm9yIGEgZGF0YSBhdHRyaWJ1dGUgb2Ygc3JjLlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIFNSQ19EQVRBX05BTUUgPSAnZGF0YS1zcGxpZGUtbGF6eSc7XG4vKipcclxuICogVGhlIG5hbWUgZm9yIGEgZGF0YSBhdHRyaWJ1dGUgb2Ygc3Jjc2V0LlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIFNSQ1NFVF9EQVRBX05BTUUgPSAnZGF0YS1zcGxpZGUtbGF6eS1zcmNzZXQnO1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGxvYWRpbmcgc2xpZGVyIGltYWdlcyBsYXppbHkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3BsaWRlfSBTcGxpZGUgICAgIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBDb21wb25lbnRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgY29tcG9uZW50cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAgICAgLSBBIGNvbXBvbmVudCBuYW1lIGFzIGEgbG93ZXJjYXNlIHN0cmluZy5cclxuICpcclxuICogQHJldHVybiB7T2JqZWN0fSAtIFRoZSBjb21wb25lbnQgb2JqZWN0LlxyXG4gKi9cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBsYXp5bG9hZCA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzLCBuYW1lKSB7XG4gIC8qKlxyXG4gICAqIE5leHQgaW5kZXggZm9yIHNlcXVlbnRpYWwgbG9hZGluZy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXG4gIHZhciBuZXh0SW5kZXg7XG4gIC8qKlxyXG4gICAqIFN0b3JlIG9iamVjdHMgY29udGFpbmluZyBhbiBpbWcgZWxlbWVudCBhbmQgYSBTbGlkZSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0W119XHJcbiAgICovXG5cbiAgdmFyIGltYWdlcztcbiAgLyoqXHJcbiAgICogU3RvcmUgdGhlIG9wdGlvbnMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBvcHRpb25zID0gU3BsaWRlLm9wdGlvbnM7XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gbG9hZCBpbWFnZXMgc2VxdWVudGlhbGx5IG9yIG5vdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xuXG4gIHZhciBpc1NlcXVlbnRpYWwgPSBvcHRpb25zLmxhenlMb2FkID09PSAnc2VxdWVudGlhbCc7XG4gIC8qKlxyXG4gICAqIExhenlsb2FkIGNvbXBvbmVudCBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xuXG4gIHZhciBMYXp5bG9hZCA9IHtcbiAgICAvKipcclxuICAgICAqIE1vdW50IG9ubHkgd2hlbiB0aGUgbGF6eWxvYWQgb3B0aW9uIGlzIHByb3ZpZGVkLlxyXG4gICAgICpcclxuICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICovXG4gICAgcmVxdWlyZWQ6IG9wdGlvbnMubGF6eUxvYWQsXG5cbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIFNwbGlkZS5vbignbW91bnRlZCByZWZyZXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpbml0KCk7XG4gICAgICAgIENvbXBvbmVudHMuRWxlbWVudHMuZWFjaChmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgICAgICBlYWNoKFNsaWRlLnNsaWRlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbXCIgKyBTUkNfREFUQV9OQU1FICsgXCJdLCBbXCIgKyBTUkNTRVRfREFUQV9OQU1FICsgXCJdXCIpLCBmdW5jdGlvbiAoaW1nKSB7XG4gICAgICAgICAgICBpZiAoIWltZy5zcmMgJiYgIWltZy5zcmNzZXQpIHtcbiAgICAgICAgICAgICAgaW1hZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGltZzogaW1nLFxuICAgICAgICAgICAgICAgIFNsaWRlOiBTbGlkZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXBwbHlTdHlsZShpbWcsIHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpc1NlcXVlbnRpYWwpIHtcbiAgICAgICAgICBsb2FkTmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFpc1NlcXVlbnRpYWwpIHtcbiAgICAgICAgU3BsaWRlLm9uKFwibW91bnRlZCByZWZyZXNoIG1vdmVkLlwiICsgbmFtZSwgY2hlY2spO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kuXHJcbiAgICAgKi9cbiAgICBkZXN0cm95OiBpbml0XG4gIH07XG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgcGFyYW1ldGVycy5cclxuICAgKi9cblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIGltYWdlcyA9IFtdO1xuICAgIG5leHRJbmRleCA9IDA7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2hlY2sgaG93IGNsb3NlIGVhY2ggaW1hZ2UgaXMgZnJvbSB0aGUgYWN0aXZlIHNsaWRlIGFuZFxyXG4gICAqIGRldGVybWluZSB3aGV0aGVyIHRvIHN0YXJ0IGxvYWRpbmcgb3Igbm90LCBhY2NvcmRpbmcgdG8gdGhlIGRpc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gQ3VycmVudCBpbmRleC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGNoZWNrKGluZGV4KSB7XG4gICAgaW5kZXggPSBpc05hTihpbmRleCkgPyBTcGxpZGUuaW5kZXggOiBpbmRleDtcbiAgICBpbWFnZXMgPSBpbWFnZXMuZmlsdGVyKGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgaWYgKGltYWdlLlNsaWRlLmlzV2l0aGluKGluZGV4LCBvcHRpb25zLnBlclBhZ2UgKiAob3B0aW9ucy5wcmVsb2FkUGFnZXMgKyAxKSkpIHtcbiAgICAgICAgbG9hZChpbWFnZS5pbWcsIGltYWdlLlNsaWRlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTsgLy8gVW5iaW5kIGlmIGFsbCBpbWFnZXMgYXJlIGxvYWRlZC5cblxuICAgIGlmICghaW1hZ2VzWzBdKSB7XG4gICAgICBTcGxpZGUub2ZmKFwibW92ZWQuXCIgKyBuYW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogU3RhcnQgbG9hZGluZyBhbiBpbWFnZS5cclxuICAgKiBDcmVhdGluZyBhIGNsb25lIG9mIHRoZSBpbWFnZSBlbGVtZW50IHNpbmNlIHNldHRpbmcgc3JjIGF0dHJpYnV0ZSBkaXJlY3RseSB0byBpdFxyXG4gICAqIG9mdGVuIG9jY3VycyAnaGl0Y2gnLCBibG9ja2luZyBzb21lIG90aGVyIHByb2Nlc3NlcyBvZiBhIGJyb3dzZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGltZyAgIC0gQW4gaW1hZ2UgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gIFNsaWRlIC0gQSBTbGlkZSBvYmplY3QuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBsb2FkKGltZywgU2xpZGUpIHtcbiAgICBhZGRDbGFzcyhTbGlkZS5zbGlkZSwgU1RBVFVTX0NMQVNTRVMubG9hZGluZyk7XG4gICAgdmFyIHNwaW5uZXIgPSBjcmVhdGUoJ3NwYW4nLCB7XG4gICAgICBcImNsYXNzXCI6IFNwbGlkZS5jbGFzc2VzLnNwaW5uZXJcbiAgICB9KTtcbiAgICBhcHBlbmQoaW1nLnBhcmVudEVsZW1lbnQsIHNwaW5uZXIpO1xuXG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGxvYWRlZChpbWcsIHNwaW5uZXIsIFNsaWRlLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIGltZy5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgbG9hZGVkKGltZywgc3Bpbm5lciwgU2xpZGUsIHRydWUpO1xuICAgIH07XG5cbiAgICBzZXRBdHRyaWJ1dGUoaW1nLCAnc3Jjc2V0JywgZ2V0QXR0cmlidXRlKGltZywgU1JDU0VUX0RBVEFfTkFNRSkgfHwgJycpO1xuICAgIHNldEF0dHJpYnV0ZShpbWcsICdzcmMnLCBnZXRBdHRyaWJ1dGUoaW1nLCBTUkNfREFUQV9OQU1FKSB8fCAnJyk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3RhcnQgbG9hZGluZyBhIG5leHQgaW1hZ2UgaW4gaW1hZ2VzIGFycmF5LlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbG9hZE5leHQoKSB7XG4gICAgaWYgKG5leHRJbmRleCA8IGltYWdlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBpbWFnZSA9IGltYWdlc1tuZXh0SW5kZXhdO1xuICAgICAgbG9hZChpbWFnZS5pbWcsIGltYWdlLlNsaWRlKTtcbiAgICB9XG5cbiAgICBuZXh0SW5kZXgrKztcbiAgfVxuICAvKipcclxuICAgKiBDYWxsZWQganVzdCBhZnRlciB0aGUgaW1hZ2Ugd2FzIGxvYWRlZCBvciBsb2FkaW5nIHdhcyBhYm9ydGVkIGJ5IHNvbWUgZXJyb3IuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGltZyAgICAgLSBBbiBpbWFnZSBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc3Bpbm5lciAtIEEgc3Bpbm5lciBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSAgU2xpZGUgICAtIEEgU2xpZGUgb2JqZWN0LlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXJyb3IgICAtIFRydWUgaWYgdGhlIGltYWdlIHdhcyBsb2FkZWQgc3VjY2Vzc2Z1bGx5IG9yIGZhbHNlIG9uIGVycm9yLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbG9hZGVkKGltZywgc3Bpbm5lciwgU2xpZGUsIGVycm9yKSB7XG4gICAgcmVtb3ZlQ2xhc3MoU2xpZGUuc2xpZGUsIFNUQVRVU19DTEFTU0VTLmxvYWRpbmcpO1xuXG4gICAgaWYgKCFlcnJvcikge1xuICAgICAgZG9tX3JlbW92ZShzcGlubmVyKTtcbiAgICAgIGFwcGx5U3R5bGUoaW1nLCB7XG4gICAgICAgIGRpc3BsYXk6ICcnXG4gICAgICB9KTtcbiAgICAgIFNwbGlkZS5lbWl0KG5hbWUgKyBcIjpsb2FkZWRcIiwgaW1nKS5lbWl0KCdyZXNpemUnKTtcbiAgICB9XG5cbiAgICBpZiAoaXNTZXF1ZW50aWFsKSB7XG4gICAgICBsb2FkTmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBMYXp5bG9hZDtcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbnN0YW50cy9hMTF5LmpzXG4vKipcclxuICogRXhwb3J0IGFyaWEgYXR0cmlidXRlIG5hbWVzLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cbi8qKlxyXG4gKiBBdHRyaWJ1dGUgbmFtZSBmb3IgYXJpYS1jdXJyZW50LlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cbnZhciBBUklBX0NVUlJFTlJUID0gJ2FyaWEtY3VycmVudCc7XG4vKipcclxuICogQXR0cmlidXRlIG5hbWUgZm9yIGFyaWEtY29udHJvbC5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBBUklBX0NPTlRST0xTID0gJ2FyaWEtY29udHJvbHMnO1xuLyoqXHJcbiAqIEF0dHJpYnV0ZSBuYW1lIGZvciBhcmlhLWNvbnRyb2wuXHJcbiAqXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xuXG52YXIgQVJJQV9MQUJFTCA9ICdhcmlhLWxhYmVsJztcbi8qKlxyXG4gKiBBdHRyaWJ1dGUgbmFtZSBmb3IgYXJpYS1sYWJlbGxlZGJ5LlxyXG4gKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIEFSSUFfTEFCRUxMRURCWSA9ICdhcmlhLWxhYmVsbGVkYnknO1xuLyoqXHJcbiAqIEF0dHJpYnV0ZSBuYW1lIGZvciBhcmlhLWhpZGRlbi5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBBUklBX0hJRERFTiA9ICdhcmlhLWhpZGRlbic7XG4vKipcclxuICogQXR0cmlidXRlIG5hbWUgZm9yIHRhYi1pbmRleC5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBUQUJfSU5ERVggPSAndGFiaW5kZXgnO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMva2V5Ym9hcmQvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyBzbGlkZXMgdmlhIGtleWJvYXJkLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgIE5hb3Rvc2hpIEZ1aml0YVxyXG4gKiBAY29weXJpZ2h0IE5hb3Rvc2hpIEZ1aml0YS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICovXG5cblxuLyoqXHJcbiAqIE1hcCBhIGtleSB0byBhIHNsaWRlIGNvbnRyb2wuXHJcbiAqXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqL1xuXG52YXIgS0VZX01BUCA9IHtcbiAgbHRyOiB7XG4gICAgQXJyb3dMZWZ0OiAnPCcsXG4gICAgQXJyb3dSaWdodDogJz4nLFxuICAgIC8vIEZvciBJRS5cbiAgICBMZWZ0OiAnPCcsXG4gICAgUmlnaHQ6ICc+J1xuICB9LFxuICBydGw6IHtcbiAgICBBcnJvd0xlZnQ6ICc+JyxcbiAgICBBcnJvd1JpZ2h0OiAnPCcsXG4gICAgLy8gRm9yIElFLlxuICAgIExlZnQ6ICc+JyxcbiAgICBSaWdodDogJzwnXG4gIH0sXG4gIHR0Yjoge1xuICAgIEFycm93VXA6ICc8JyxcbiAgICBBcnJvd0Rvd246ICc+JyxcbiAgICAvLyBGb3IgSUUuXG4gICAgVXA6ICc8JyxcbiAgICBEb3duOiAnPidcbiAgfVxufTtcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBjb250cm9sbGluZyBzbGlkZXMgdmlhIGtleWJvYXJkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3Qga2V5Ym9hcmQgPSAoZnVuY3Rpb24gKFNwbGlkZSkge1xuICAvKipcclxuICAgKiBIb2xkIHRoZSB0YXJnZXQgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtFbGVtZW50fERvY3VtZW50fHVuZGVmaW5lZH1cclxuICAgKi9cbiAgdmFyIHRhcmdldDtcbiAgcmV0dXJuIHtcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuICAgICAqL1xuICAgIG1vdW50OiBmdW5jdGlvbiBtb3VudCgpIHtcbiAgICAgIFNwbGlkZS5vbignbW91bnRlZCB1cGRhdGVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgICAgICB2YXIgcm9vdCA9IFNwbGlkZS5yb290O1xuICAgICAgICB2YXIgbWFwID0gS0VZX01BUFtvcHRpb25zLmRpcmVjdGlvbl07XG4gICAgICAgIHZhciBrZXlib2FyZCA9IG9wdGlvbnMua2V5Ym9hcmQ7XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIFNwbGlkZS5vZmYoJ2tleWRvd24nLCB0YXJnZXQpO1xuICAgICAgICAgIHJlbW92ZUF0dHJpYnV0ZShyb290LCBUQUJfSU5ERVgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleWJvYXJkKSB7XG4gICAgICAgICAgaWYgKGtleWJvYXJkID09PSAnZm9jdXNlZCcpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHJvb3Q7XG4gICAgICAgICAgICBzZXRBdHRyaWJ1dGUocm9vdCwgVEFCX0lOREVYLCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgU3BsaWRlLm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChtYXBbZS5rZXldKSB7XG4gICAgICAgICAgICAgIFNwbGlkZS5nbyhtYXBbZS5rZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL2ExMXkvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBlbmhhbmNpbmcgYWNjZXNzaWJpbGl0eS5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIGVuaGFuY2luZyBhY2Nlc3NpYmlsaXR5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlICAgICAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gQ29tcG9uZW50cyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgYTExeSA9IChmdW5jdGlvbiAoU3BsaWRlLCBDb21wb25lbnRzKSB7XG4gIC8qKlxyXG4gICAqIEhvbGQgYSBpMThuIG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG4gIHZhciBpMThuID0gU3BsaWRlLmkxOG47XG4gIC8qKlxyXG4gICAqIEhvbGQgdGhlIEVsZW1lbnRzIGNvbXBvbmVudC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIEVsZW1lbnRzID0gQ29tcG9uZW50cy5FbGVtZW50cztcbiAgLyoqXHJcbiAgICogQWxsIGF0dHJpYnV0ZXMgcmVsYXRlZCB3aXRoIEExMXkuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7c3RyaW5nW119XHJcbiAgICovXG5cbiAgdmFyIGFsbEF0dHJpYnV0ZXMgPSBbQVJJQV9ISURERU4sIFRBQl9JTkRFWCwgQVJJQV9DT05UUk9MUywgQVJJQV9MQUJFTCwgQVJJQV9DVVJSRU5SVCwgJ3JvbGUnXTtcbiAgLyoqXHJcbiAgICogQTExeSBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgQTExeSA9IHtcbiAgICAvKipcclxuICAgICAqIFJlcXVpcmVkIG9ubHkgd2hlbiB0aGUgYWNjZXNzaWJpbGl0eSBvcHRpb24gaXMgdHJ1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAqL1xuICAgIHJlcXVpcmVkOiBTcGxpZGUub3B0aW9ucy5hY2Nlc3NpYmlsaXR5LFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICBTcGxpZGUub24oJ3Zpc2libGUnLCBmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgICAgdXBkYXRlU2xpZGUoU2xpZGUuc2xpZGUsIHRydWUpO1xuICAgICAgfSkub24oJ2hpZGRlbicsIGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgICB1cGRhdGVTbGlkZShTbGlkZS5zbGlkZSwgZmFsc2UpO1xuICAgICAgfSkub24oJ2Fycm93czptb3VudGVkJywgaW5pdEFycm93cykub24oJ2Fycm93czp1cGRhdGVkJywgdXBkYXRlQXJyb3dzKS5vbigncGFnaW5hdGlvbjptb3VudGVkJywgaW5pdFBhZ2luYXRpb24pLm9uKCdwYWdpbmF0aW9uOnVwZGF0ZWQnLCB1cGRhdGVQYWdpbmF0aW9uKS5vbigncmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlQXR0cmlidXRlKENvbXBvbmVudHMuQ2xvbmVzLmNsb25lcywgYWxsQXR0cmlidXRlcyk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKFNwbGlkZS5vcHRpb25zLmlzTmF2aWdhdGlvbikge1xuICAgICAgICBTcGxpZGUub24oJ25hdmlnYXRpb246bW91bnRlZCBuYXZpZ2F0aW9uOnVwZGF0ZWQnLCBpbml0TmF2aWdhdGlvbikub24oJ2FjdGl2ZScsIGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgICAgIHVwZGF0ZU5hdmlnYXRpb24oU2xpZGUsIHRydWUpO1xuICAgICAgICB9KS5vbignaW5hY3RpdmUnLCBmdW5jdGlvbiAoU2xpZGUpIHtcbiAgICAgICAgICB1cGRhdGVOYXZpZ2F0aW9uKFNsaWRlLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpbml0QXV0b3BsYXkoKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95LlxyXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBBcnJvd3MgPSBDb21wb25lbnRzLkFycm93cztcbiAgICAgIHZhciBhcnJvd3MgPSBBcnJvd3MgPyBBcnJvd3MuYXJyb3dzIDoge307XG4gICAgICByZW1vdmVBdHRyaWJ1dGUoRWxlbWVudHMuc2xpZGVzLmNvbmNhdChbYXJyb3dzLnByZXYsIGFycm93cy5uZXh0LCBFbGVtZW50cy5wbGF5LCBFbGVtZW50cy5wYXVzZV0pLCBhbGxBdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBzbGlkZSBhdHRyaWJ1dGVzIHdoZW4gaXQgZ2V0cyB2aXNpYmxlIG9yIGhpZGRlbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc2xpZGUgICAtIEEgc2xpZGUgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUgLSBUcnVlIHdoZW4gdGhlIHNsaWRlIGdldHMgdmlzaWJsZSwgb3IgZmFsc2Ugd2hlbiBoaWRkZW4uXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xpZGUoc2xpZGUsIHZpc2libGUpIHtcbiAgICBzZXRBdHRyaWJ1dGUoc2xpZGUsIEFSSUFfSElEREVOLCAhdmlzaWJsZSk7XG5cbiAgICBpZiAoU3BsaWRlLm9wdGlvbnMuc2xpZGVGb2N1cykge1xuICAgICAgc2V0QXR0cmlidXRlKHNsaWRlLCBUQUJfSU5ERVgsIHZpc2libGUgPyAwIDogLTEpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBJbml0aWFsaXplIGFycm93cyBpZiB0aGV5IGFyZSBhdmFpbGFibGUuXHJcbiAgICogQXBwZW5kIHNjcmVlbiByZWFkZXIgZWxlbWVudHMgYW5kIGFkZCBhcmlhLWNvbnRyb2xzIGF0dHJpYnV0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcHJldiAtIFByZXZpb3VzIGFycm93IGVsZW1lbnQuXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBuZXh0IC0gTmV4dCBhcnJvdyBlbGVtZW50LlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5pdEFycm93cyhwcmV2LCBuZXh0KSB7XG4gICAgdmFyIGNvbnRyb2xzID0gRWxlbWVudHMudHJhY2suaWQ7XG4gICAgc2V0QXR0cmlidXRlKHByZXYsIEFSSUFfQ09OVFJPTFMsIGNvbnRyb2xzKTtcbiAgICBzZXRBdHRyaWJ1dGUobmV4dCwgQVJJQV9DT05UUk9MUywgY29udHJvbHMpO1xuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhcnJvdyBhdHRyaWJ1dGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwcmV2ICAgICAgLSBQcmV2aW91cyBhcnJvdyBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gbmV4dCAgICAgIC0gTmV4dCBhcnJvdyBlbGVtZW50LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgcHJldkluZGV4IC0gUHJldmlvdXMgc2xpZGUgaW5kZXggb3IgLTEgd2hlbiB0aGVyZSBpcyBubyBwcmVjZWRlIHNsaWRlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgbmV4dEluZGV4IC0gTmV4dCBzbGlkZSBpbmRleCBvciAtMSB3aGVuIHRoZXJlIGlzIG5vIG5leHQgc2xpZGUuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiB1cGRhdGVBcnJvd3MocHJldiwgbmV4dCwgcHJldkluZGV4LCBuZXh0SW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBTcGxpZGUuaW5kZXg7XG4gICAgdmFyIHByZXZMYWJlbCA9IHByZXZJbmRleCA+IC0xICYmIGluZGV4IDwgcHJldkluZGV4ID8gaTE4bi5sYXN0IDogaTE4bi5wcmV2O1xuICAgIHZhciBuZXh0TGFiZWwgPSBuZXh0SW5kZXggPiAtMSAmJiBpbmRleCA+IG5leHRJbmRleCA/IGkxOG4uZmlyc3QgOiBpMThuLm5leHQ7XG4gICAgc2V0QXR0cmlidXRlKHByZXYsIEFSSUFfTEFCRUwsIHByZXZMYWJlbCk7XG4gICAgc2V0QXR0cmlidXRlKG5leHQsIEFSSUFfTEFCRUwsIG5leHRMYWJlbCk7XG4gIH1cbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBwYWdpbmF0aW9uIGlmIGl0J3MgYXZhaWxhYmxlLlxyXG4gICAqIEFwcGVuZCBhIHNjcmVlbiByZWFkZXIgZWxlbWVudCBhbmQgYWRkIGFyaWEtY29udHJvbHMvbGFiZWwgYXR0cmlidXRlIHRvIGVhY2ggaXRlbS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhICAgICAgIC0gRGF0YSBvYmplY3QgY29udGFpbmluZyBhbGwgaXRlbXMuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGl2ZUl0ZW0gLSBBbiBpbml0aWFsIGFjdGl2ZSBpdGVtLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5pdFBhZ2luYXRpb24oZGF0YSwgYWN0aXZlSXRlbSkge1xuICAgIGlmIChhY3RpdmVJdGVtKSB7XG4gICAgICBzZXRBdHRyaWJ1dGUoYWN0aXZlSXRlbS5idXR0b24sIEFSSUFfQ1VSUkVOUlQsIHRydWUpO1xuICAgIH1cblxuICAgIGRhdGEuaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBTcGxpZGUub3B0aW9ucztcbiAgICAgIHZhciB0ZXh0ID0gb3B0aW9ucy5mb2N1cyA9PT0gZmFsc2UgJiYgb3B0aW9ucy5wZXJQYWdlID4gMSA/IGkxOG4ucGFnZVggOiBpMThuLnNsaWRlWDtcbiAgICAgIHZhciBsYWJlbCA9IHNwcmludGYodGV4dCwgaXRlbS5wYWdlICsgMSk7XG4gICAgICB2YXIgYnV0dG9uID0gaXRlbS5idXR0b247XG4gICAgICB2YXIgY29udHJvbHMgPSBpdGVtLlNsaWRlcy5tYXAoZnVuY3Rpb24gKFNsaWRlKSB7XG4gICAgICAgIHJldHVybiBTbGlkZS5zbGlkZS5pZDtcbiAgICAgIH0pO1xuICAgICAgc2V0QXR0cmlidXRlKGJ1dHRvbiwgQVJJQV9DT05UUk9MUywgY29udHJvbHMuam9pbignICcpKTtcbiAgICAgIHNldEF0dHJpYnV0ZShidXR0b24sIEFSSUFfTEFCRUwsIGxhYmVsKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGUgcGFnaW5hdGlvbiBhdHRyaWJ1dGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9ICBkYXRhIC0gRGF0YSBvYmplY3QgY29udGFpbmluZyBhbGwgaXRlbXMuXHJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwcmV2IC0gQSBwcmV2aW91cyBhY3RpdmUgZWxlbWVudC5cclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGN1cnIgLSBBIGN1cnJlbnQgYWN0aXZlIGVsZW1lbnQuXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiB1cGRhdGVQYWdpbmF0aW9uKGRhdGEsIHByZXYsIGN1cnIpIHtcbiAgICBpZiAocHJldikge1xuICAgICAgcmVtb3ZlQXR0cmlidXRlKHByZXYuYnV0dG9uLCBBUklBX0NVUlJFTlJUKTtcbiAgICB9XG5cbiAgICBpZiAoY3Vycikge1xuICAgICAgc2V0QXR0cmlidXRlKGN1cnIuYnV0dG9uLCBBUklBX0NVUlJFTlJULCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBhdXRvcGxheSBidXR0b25zLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gaW5pdEF1dG9wbGF5KCkge1xuICAgIFsncGxheScsICdwYXVzZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbG0gPSBFbGVtZW50c1tuYW1lXTtcblxuICAgICAgaWYgKGVsbSkge1xuICAgICAgICBpZiAoIWlzQnV0dG9uKGVsbSkpIHtcbiAgICAgICAgICBzZXRBdHRyaWJ1dGUoZWxtLCAncm9sZScsICdidXR0b24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEF0dHJpYnV0ZShlbG0sIEFSSUFfQ09OVFJPTFMsIEVsZW1lbnRzLnRyYWNrLmlkKTtcbiAgICAgICAgc2V0QXR0cmlidXRlKGVsbSwgQVJJQV9MQUJFTCwgaTE4bltuYW1lXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBuYXZpZ2F0aW9uIHNsaWRlci5cclxuICAgKiBBZGQgYnV0dG9uIHJvbGUsIGFyaWEtbGFiZWwsIGFyaWEtY29udHJvbHMgdG8gc2xpZGUgZWxlbWVudHMgYW5kIGFwcGVuZCBzY3JlZW4gcmVhZGVyIHRleHQgdG8gdGhlbS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3BsaWRlfSBtYWluIC0gQSBtYWluIFNwbGlkZSBpbnN0YW5jZS5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGluaXROYXZpZ2F0aW9uKG1haW4pIHtcbiAgICBFbGVtZW50cy5lYWNoKGZ1bmN0aW9uIChTbGlkZSkge1xuICAgICAgdmFyIHNsaWRlID0gU2xpZGUuc2xpZGU7XG4gICAgICB2YXIgcmVhbEluZGV4ID0gU2xpZGUucmVhbEluZGV4O1xuXG4gICAgICBpZiAoIWlzQnV0dG9uKHNsaWRlKSkge1xuICAgICAgICBzZXRBdHRyaWJ1dGUoc2xpZGUsICdyb2xlJywgJ2J1dHRvbicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2xpZGVJbmRleCA9IHJlYWxJbmRleCA+IC0xID8gcmVhbEluZGV4IDogU2xpZGUuaW5kZXg7XG4gICAgICB2YXIgbGFiZWwgPSBzcHJpbnRmKGkxOG4uc2xpZGVYLCBzbGlkZUluZGV4ICsgMSk7XG4gICAgICB2YXIgbWFpblNsaWRlID0gbWFpbi5Db21wb25lbnRzLkVsZW1lbnRzLmdldFNsaWRlKHNsaWRlSW5kZXgpO1xuICAgICAgc2V0QXR0cmlidXRlKHNsaWRlLCBBUklBX0xBQkVMLCBsYWJlbCk7XG5cbiAgICAgIGlmIChtYWluU2xpZGUpIHtcbiAgICAgICAgc2V0QXR0cmlidXRlKHNsaWRlLCBBUklBX0NPTlRST0xTLCBtYWluU2xpZGUuc2xpZGUuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBuYXZpZ2F0aW9uIGF0dHJpYnV0ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gIFNsaWRlICAtIEEgdGFyZ2V0IFNsaWRlIG9iamVjdC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZSAtIFRydWUgaWYgdGhlIHNsaWRlIGlzIGFjdGl2ZSBvciBmYWxzZSBpZiBpbmFjdGl2ZS5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU5hdmlnYXRpb24oX3JlZiwgYWN0aXZlKSB7XG4gICAgdmFyIHNsaWRlID0gX3JlZi5zbGlkZTtcblxuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgIHNldEF0dHJpYnV0ZShzbGlkZSwgQVJJQV9DVVJSRU5SVCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZShzbGlkZSwgQVJJQV9DVVJSRU5SVCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGJ1dHRvbiBvciBub3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsbSAtIEFuIGVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVHJ1ZSBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBidXR0b24uXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBpc0J1dHRvbihlbG0pIHtcbiAgICByZXR1cm4gZWxtLnRhZ05hbWUgPT09ICdCVVRUT04nO1xuICB9XG5cbiAgcmV0dXJuIEExMXk7XG59KTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9qcy9jb21wb25lbnRzL3N5bmMvaW5kZXguanNcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBzeW5jaHJvbml6aW5nIGEgc2xpZGVyIHdpdGggYW5vdGhlci5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cbi8qKlxyXG4gKiBUaGUgZXZlbnQgbmFtZSBmb3Igc3luYy5cclxuICpcclxuICogQHR5cGUge3N0cmluZ31cclxuICovXG5cbnZhciBTWU5DX0VWRU5UID0gJ21vdmUuc3luYyc7XG4vKipcclxuICogVGhlIGV2ZW50IG5hbWVzIGZvciBjbGljayBuYXZpZ2F0aW9uLlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cblxudmFyIENMSUNLX0VWRU5UUyA9ICdtb3VzZXVwIHRvdWNoZW5kJztcbi8qKlxyXG4gKiBUaGUga2V5cyBmb3IgdHJpZ2dlcmluZyB0aGUgbmF2aWdhdGlvbiBidXR0b24uXHJcbiAqXHJcbiAqIEB0eXBlIHtTdHJpbmdbXX1cclxuICovXG5cbnZhciBUUklHR0VSX0tFWVMgPSBbJyAnLCAnRW50ZXInLCAnU3BhY2ViYXInXTtcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciBzeW5jaHJvbml6aW5nIGEgc2xpZGVyIHdpdGggYW5vdGhlci5cclxuICpcclxuICogQHBhcmFtIHtTcGxpZGV9IFNwbGlkZSAtIEEgU3BsaWRlIGluc3RhbmNlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtPYmplY3R9IC0gVGhlIGNvbXBvbmVudCBvYmplY3QuXHJcbiAqL1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IHN5bmMgPSAoZnVuY3Rpb24gKFNwbGlkZSkge1xuICAvKipcclxuICAgKiBLZWVwIHRoZSBzaWJsaW5nIFNwbGlkZSBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtTcGxpZGV9XHJcbiAgICovXG4gIHZhciBzaWJsaW5nID0gU3BsaWRlLnNpYmxpbmc7XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdGhlIHNpYmxpbmcgc2xpZGVyIGlzIG5hdmlnYXRpb24gb3Igbm90LlxyXG4gICAqXHJcbiAgICogQHR5cGUge1NwbGlkZXxib29sZWFufVxyXG4gICAqL1xuXG4gIHZhciBpc05hdmlnYXRpb24gPSBzaWJsaW5nICYmIHNpYmxpbmcub3B0aW9ucy5pc05hdmlnYXRpb247XG4gIC8qKlxyXG4gICAqIExheW91dCBjb21wb25lbnQgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgU3luYyA9IHtcbiAgICAvKipcclxuICAgICAqIFJlcXVpcmVkIG9ubHkgd2hlbiB0aGUgc3ViIHNsaWRlciBpcyBhdmFpbGFibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cbiAgICByZXF1aXJlZDogISFzaWJsaW5nLFxuXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAgKi9cbiAgICBtb3VudDogZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgICBzeW5jTWFpbigpO1xuICAgICAgc3luY1NpYmxpbmcoKTtcblxuICAgICAgaWYgKGlzTmF2aWdhdGlvbikge1xuICAgICAgICBiaW5kKCk7XG4gICAgICAgIFNwbGlkZS5vbigncmVmcmVzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGJpbmQoKTtcbiAgICAgICAgICAgIHNpYmxpbmcuZW1pdCgnbmF2aWdhdGlvbjp1cGRhdGVkJywgU3BsaWRlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFmdGVyIGFsbCBjb21wb25lbnRzIGFyZSBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICAgIGlmIChpc05hdmlnYXRpb24pIHtcbiAgICAgICAgc2libGluZy5lbWl0KCduYXZpZ2F0aW9uOm1vdW50ZWQnLCBTcGxpZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogTGlzdGVuIHRoZSBwcmltYXJ5IHNsaWRlciBldmVudCB0byBtb3ZlIHNlY29uZGFyeSBvbmUuXHJcbiAgICogTXVzdCB1bmJpbmQgYSBoYW5kbGVyIGF0IGZpcnN0IHRvIGF2b2lkIGluZmluaXRlIGxvb3AuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gc3luY01haW4oKSB7XG4gICAgU3BsaWRlLm9uKFNZTkNfRVZFTlQsIGZ1bmN0aW9uIChuZXdJbmRleCwgcHJldkluZGV4LCBkZXN0SW5kZXgpIHtcbiAgICAgIHNpYmxpbmcub2ZmKFNZTkNfRVZFTlQpLmdvKHNpYmxpbmcuaXMoTE9PUCkgPyBkZXN0SW5kZXggOiBuZXdJbmRleCwgZmFsc2UpO1xuICAgICAgc3luY1NpYmxpbmcoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBMaXN0ZW4gdGhlIHNlY29uZGFyeSBzbGlkZXIgZXZlbnQgdG8gbW92ZSBwcmltYXJ5IG9uZS5cclxuICAgKiBNdXN0IHVuYmluZCBhIGhhbmRsZXIgYXQgZmlyc3QgdG8gYXZvaWQgaW5maW5pdGUgbG9vcC5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN5bmNTaWJsaW5nKCkge1xuICAgIHNpYmxpbmcub24oU1lOQ19FVkVOVCwgZnVuY3Rpb24gKG5ld0luZGV4LCBwcmV2SW5kZXgsIGRlc3RJbmRleCkge1xuICAgICAgU3BsaWRlLm9mZihTWU5DX0VWRU5UKS5nbyhTcGxpZGUuaXMoTE9PUCkgPyBkZXN0SW5kZXggOiBuZXdJbmRleCwgZmFsc2UpO1xuICAgICAgc3luY01haW4oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBMaXN0ZW4gc29tZSBldmVudHMgb24gZWFjaCBzbGlkZS5cclxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGJpbmQoKSB7XG4gICAgc2libGluZy5Db21wb25lbnRzLkVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBzbGlkZSA9IF9yZWYuc2xpZGUsXG4gICAgICAgICAgaW5kZXggPSBfcmVmLmluZGV4O1xuXG4gICAgICAvKlxyXG4gICAgICAgKiBMaXN0ZW4gbW91c2V1cCBhbmQgdG91Y2hlbmQgZXZlbnRzIHRvIGhhbmRsZSBjbGljay5cclxuICAgICAgICovXG4gICAgICBTcGxpZGUub2ZmKENMSUNLX0VWRU5UUywgc2xpZGUpLm9uKENMSUNLX0VWRU5UUywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy8gSWdub3JlIGEgbWlkZGxlIG9yIHJpZ2h0IGNsaWNrLlxuICAgICAgICBpZiAoIWUuYnV0dG9uIHx8IGUuYnV0dG9uID09PSAwKSB7XG4gICAgICAgICAgbW92ZVNpYmxpbmcoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9LCBzbGlkZSk7XG4gICAgICAvKlxyXG4gICAgICAgKiBTdWJzY3JpYmUga2V5dXAgdG8gaGFuZGxlIEVudGVyIGFuZCBTcGFjZSBrZXkuXHJcbiAgICAgICAqIE5vdGUgdGhhdCBBcnJheS5pbmNsdWRlcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IElFLlxyXG4gICAgICAgKi9cblxuICAgICAgU3BsaWRlLm9mZigna2V5dXAnLCBzbGlkZSkub24oJ2tleXVwJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKFRSSUdHRVJfS0VZUy5pbmRleE9mKGUua2V5KSA+IC0xKSB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIG1vdmVTaWJsaW5nKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfSwgc2xpZGUsIHtcbiAgICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIHNpYmxpbmcgdG8gdGhlIGdpdmVuIGluZGV4LlxyXG4gICAqIE5lZWQgdG8gY2hlY2sgXCJJRExFXCIgc3RhdHVzIGJlY2F1c2Ugc2xpZGVzIGNhbiBiZSBtb3ZpbmcgYnkgRHJhZyBjb21wb25lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUYXJnZXQgaW5kZXguXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBtb3ZlU2libGluZyhpbmRleCkge1xuICAgIGlmIChTcGxpZGUuU3RhdGUuaXMoSURMRSkpIHtcbiAgICAgIHNpYmxpbmcuZ28oaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBTeW5jO1xufSk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvanMvY29tcG9uZW50cy9icmVha3BvaW50cy9pbmRleC5qc1xuLyoqXHJcbiAqIFRoZSBjb21wb25lbnQgZm9yIHVwZGF0aW5nIG9wdGlvbnMgYWNjb3JkaW5nIHRvIGEgY3VycmVudCB3aW5kb3cgd2lkdGguXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG4vKipcclxuICogSW50ZXJ2YWwgdGltZSBmb3IgdGhyb3R0bGUuXHJcbiAqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqL1xuXG52YXIgVEhST1RUTEUgPSA1MDtcbi8qKlxyXG4gKiBUaGUgY29tcG9uZW50IGZvciB1cGRhdGluZyBvcHRpb25zIGFjY29yZGluZyB0byBhIGN1cnJlbnQgd2luZG93IHdpZHRoLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1NwbGlkZX0gU3BsaWRlIC0gQSBTcGxpZGUgaW5zdGFuY2UuXHJcbiAqXHJcbiAqIEByZXR1cm4ge09iamVjdH0gLSBUaGUgY29tcG9uZW50IG9iamVjdC5cclxuICovXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgYnJlYWtwb2ludHMgPSAoZnVuY3Rpb24gKFNwbGlkZSkge1xuICAvKipcclxuICAgKiBTdG9yZSBicmVha3BvaW50cy5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R8Ym9vbGVhbn1cclxuICAgKi9cbiAgdmFyIGJyZWFrcG9pbnRzID0gU3BsaWRlLm9wdGlvbnMuYnJlYWtwb2ludHM7XG4gIC8qKlxyXG4gICAqIFRoZSBjaGVjayBmdW5jdGlvbiB3aG9zZSBmcmVxdWVuY3kgb2YgY2FsbCBpcyByZWR1Y2VkLlxyXG4gICAqXHJcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAqL1xuXG4gIHZhciB0aHJvdHRsZWRDaGVjayA9IHRocm90dGxlKGNoZWNrLCBUSFJPVFRMRSk7XG4gIC8qKlxyXG4gICAqIEtlZXAgaW5pdGlhbCBvcHRpb25zLlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdH1cclxuICAgKi9cblxuICB2YXIgaW5pdGlhbE9wdGlvbnM7XG4gIC8qKlxyXG4gICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgb2JqZWN0cyBvZiBwb2ludCBhbmQgTWVkaWFRdWVyeUxpc3QuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7T2JqZWN0W119XHJcbiAgICovXG5cbiAgdmFyIG1hcCA9IFtdO1xuICAvKipcclxuICAgKiBIb2xkIHRoZSBwcmV2aW91cyBicmVha3BvaW50LlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcnx1bmRlZmluZWR9XHJcbiAgICovXG5cbiAgdmFyIHByZXZQb2ludDtcbiAgLyoqXHJcbiAgICogQnJlYWtwb2ludHMgY29tcG9uZW50IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICovXG5cbiAgdmFyIEJyZWFrcG9pbnRzID0ge1xuICAgIC8qKlxyXG4gICAgICogUmVxdWlyZWQgb25seSB3aGVuIHRoZSBicmVha3BvaW50cyBkZWZpbml0aW9uIGlzIHByb3ZpZGVkIGFuZCBicm93c2VyIHN1cHBvcnRzIG1hdGNoTWVkaWEuXHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cbiAgICByZXF1aXJlZDogYnJlYWtwb2ludHMgJiYgbWF0Y2hNZWRpYSxcblxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxyXG4gICAgICovXG4gICAgbW91bnQ6IGZ1bmN0aW9uIG1vdW50KCkge1xuICAgICAgbWFwID0gT2JqZWN0LmtleXMoYnJlYWtwb2ludHMpLnNvcnQoZnVuY3Rpb24gKG4sIG0pIHtcbiAgICAgICAgcmV0dXJuICtuIC0gK207XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgICAgIG1xbDogbWF0Y2hNZWRpYShcIihtYXgtd2lkdGg6XCIgKyBwb2ludCArIFwicHgpXCIpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIC8qXHJcbiAgICAgICAqIFRvIGtlZXAgbW9uaXRvcmluZyByZXNpemUgZXZlbnQgYWZ0ZXIgZGVzdHJ1Y3Rpb24gd2l0aG91dCBcImNvbXBsZXRlbHlcIixcclxuICAgICAgICogdXNlIG5hdGl2ZSBhZGRFdmVudExpc3RlbmVyIGluc3RlYWQgb2YgU3BsaWRlLm9uLlxyXG4gICAgICAgKi9cblxuICAgICAgdGhpcy5kZXN0cm95KHRydWUpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhyb3R0bGVkQ2hlY2spOyAvLyBLZWVwIGluaXRpYWwgb3B0aW9ucyB0byBhcHBseSB0aGVtIHdoZW4gbm8gYnJlYWtwb2ludCBtYXRjaGVzLlxuXG4gICAgICBpbml0aWFsT3B0aW9ucyA9IFNwbGlkZS5vcHRpb25zO1xuICAgICAgY2hlY2soKTtcbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcGxldGVseSAtIFdoZXRoZXIgdG8gZGVzdHJveSBTcGxpZGUgY29tcGxldGVseS5cclxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koY29tcGxldGVseSkge1xuICAgICAgaWYgKGNvbXBsZXRlbHkpIHtcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhyb3R0bGVkQ2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQ2hlY2sgdGhlIGJyZWFrcG9pbnQuXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gY2hlY2soKSB7XG4gICAgdmFyIHBvaW50ID0gZ2V0UG9pbnQoKTtcblxuICAgIGlmIChwb2ludCAhPT0gcHJldlBvaW50KSB7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludDtcbiAgICAgIHZhciBTdGF0ZSA9IFNwbGlkZS5TdGF0ZTtcbiAgICAgIHZhciBvcHRpb25zID0gYnJlYWtwb2ludHNbcG9pbnRdIHx8IGluaXRpYWxPcHRpb25zO1xuICAgICAgdmFyIGRlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICAgIGlmIChkZXN0cm95KSB7XG4gICAgICAgIFNwbGlkZS5vcHRpb25zID0gaW5pdGlhbE9wdGlvbnM7XG4gICAgICAgIFNwbGlkZS5kZXN0cm95KGRlc3Ryb3kgPT09ICdjb21wbGV0ZWx5Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoU3RhdGUuaXMoREVTVFJPWUVEKSkge1xuICAgICAgICAgIFNwbGlkZS5tb3VudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgU3BsaWRlLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGJyZWFrcG9pbnQgbWF0Y2hpbmcgY3VycmVudCB3aW5kb3cgd2lkdGguXHJcbiAgICogTm90ZSB0aGF0IEFycmF5LnByb3RvdHlwZS5maW5kIGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ8c3RyaW5nfSAtIEEgYnJlYWtwb2ludCBhcyBudW1iZXIgb3Igc3RyaW5nLiAtMSBpZiBubyBwb2ludCBtYXRjaGVzLlxyXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0UG9pbnQoKSB7XG4gICAgdmFyIGl0ZW0gPSBtYXAuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5tcWwubWF0Y2hlcztcbiAgICB9KVswXTtcbiAgICByZXR1cm4gaXRlbSA/IGl0ZW0ucG9pbnQgOiAtMTtcbiAgfVxuXG4gIHJldHVybiBCcmVha3BvaW50cztcbn0pO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2pzL2NvbXBvbmVudHMvaW5kZXguanNcbi8qKlxyXG4gKiBFeHBvcnQgY29tcG9uZW50cy5cclxuICpcclxuICogQGF1dGhvciAgICBOYW90b3NoaSBGdWppdGFcclxuICogQGNvcHlyaWdodCBOYW90b3NoaSBGdWppdGEuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBDT01QTEVURSA9IHtcbiAgT3B0aW9uczogb3B0aW9ucyxcbiAgQnJlYWtwb2ludHM6IGJyZWFrcG9pbnRzLFxuICBDb250cm9sbGVyOiBjb250cm9sbGVyLFxuICBFbGVtZW50czogY29tcG9uZW50c19lbGVtZW50cyxcbiAgVHJhY2s6IHRyYWNrLFxuICBDbG9uZXM6IGNsb25lcyxcbiAgTGF5b3V0OiBsYXlvdXQsXG4gIERyYWc6IGRyYWcsXG4gIENsaWNrOiBjbGljayxcbiAgQXV0b3BsYXk6IGF1dG9wbGF5LFxuICBDb3ZlcjogY292ZXIsXG4gIEFycm93czogYXJyb3dzLFxuICBQYWdpbmF0aW9uOiBwYWdpbmF0aW9uLFxuICBMYXp5TG9hZDogbGF6eWxvYWQsXG4gIEtleWJvYXJkOiBrZXlib2FyZCxcbiAgU3luYzogc3luYyxcbiAgQTExeTogYTExeVxufTtcbnZhciBMSUdIVCA9IHtcbiAgT3B0aW9uczogb3B0aW9ucyxcbiAgQ29udHJvbGxlcjogY29udHJvbGxlcixcbiAgRWxlbWVudHM6IGNvbXBvbmVudHNfZWxlbWVudHMsXG4gIFRyYWNrOiB0cmFjayxcbiAgQ2xvbmVzOiBjbG9uZXMsXG4gIExheW91dDogbGF5b3V0LFxuICBEcmFnOiBkcmFnLFxuICBDbGljazogY2xpY2ssXG4gIEFycm93czogYXJyb3dzLFxuICBQYWdpbmF0aW9uOiBwYWdpbmF0aW9uLFxuICBBMTF5OiBhMTF5XG59O1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnVpbGQvbW9kdWxlL21vZHVsZS5qc1xuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxyXG4gKiBFeHBvcnQgU3BsaWRlIGNsYXNzIGZvciBpbXBvcnQuXHJcbiAqXHJcbiAqIEBhdXRob3IgICAgTmFvdG9zaGkgRnVqaXRhXHJcbiAqIEBjb3B5cmlnaHQgTmFvdG9zaGkgRnVqaXRhLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG4gKi9cblxuXG4vKipcclxuICogRXhwb3J0IFNwbGlkZSBjbGFzcyBmb3IgaW1wb3J0IGZyb20gb3RoZXIgcHJvamVjdHMuXHJcbiAqL1xuXG52YXIgbW9kdWxlX1NwbGlkZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NvcmUpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3BsaWRlLCBfQ29yZSk7XG5cbiAgZnVuY3Rpb24gU3BsaWRlKHJvb3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX0NvcmUuY2FsbCh0aGlzLCByb290LCBvcHRpb25zLCBDT01QTEVURSkgfHwgdGhpcztcbiAgfVxuXG4gIHJldHVybiBTcGxpZGU7XG59KFNwbGlkZSk7XG5cblxuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0XHR9XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKVxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIG1vZHVsZSBleHBvcnRzIG11c3QgYmUgcmV0dXJuZWQgZnJvbSBydW50aW1lIHNvIGVudHJ5IGlubGluaW5nIGlzIGRpc2FibGVkXG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxMSk7XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@splidejs/splide/dist/js/splide.esm.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("const isOldIE=function isOldIE(){let memo;return function memorize(){if(typeof memo==='undefined'){// Test for IE <= 9 as proposed by Browserhacks\n// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n// Tests for existence of standard globals is to allow style-loader\n// to operate correctly into non-standard environments\n// @see https://github.com/webpack-contrib/style-loader/issues/177\nmemo=Boolean(window&&document&&document.all&&!window.atob);}return memo;};}();const getTarget=function getTarget(){const memo={};return function memorize(target){if(typeof memo[target]==='undefined'){let styleTarget=document.querySelector(target);// Special case to return head of iframe instead of iframe itself\nif(window.HTMLIFrameElement&&styleTarget instanceof window.HTMLIFrameElement){try{// This will throw an exception if access to iframe is blocked\n// due to cross-origin restrictions\nstyleTarget=styleTarget.contentDocument.head;}catch(e){// istanbul ignore next\nstyleTarget=null;}}memo[target]=styleTarget;}return memo[target];};}();const stylesInDom=[];function getIndexByIdentifier(identifier){let result=-1;for(let i=0;i<stylesInDom.length;i++){if(stylesInDom[i].identifier===identifier){result=i;break;}}return result;}function modulesToDom(list,options){const idCountMap={};const identifiers=[];for(let i=0;i<list.length;i++){const item=list[i];const id=options.base?item[0]+options.base:item[0];const count=idCountMap[id]||0;const identifier=id+' '+count.toString();idCountMap[id]=count+1;const index=getIndexByIdentifier(identifier);const obj={css:item[1],media:item[2],sourceMap:item[3]};if(index!==-1){stylesInDom[index].references++;stylesInDom[index].updater(obj);}else{stylesInDom.push({identifier:identifier,updater:addStyle(obj,options),references:1});}identifiers.push(identifier);}return identifiers;}function insertStyleElement(options){const style=document.createElement('style');const attributes=options.attributes||{};if(typeof attributes.nonce==='undefined'){const nonce=// eslint-disable-next-line no-undef\n true?__webpack_require__.nc:undefined;if(nonce){attributes.nonce=nonce;}}Object.keys(attributes).forEach(function(key){style.setAttribute(key,attributes[key]);});if(typeof options.insert==='function'){options.insert(style);}else{const target=getTarget(options.insert||'head');if(!target){throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");}target.appendChild(style);}return style;}function removeStyleElement(style){// istanbul ignore if\nif(style.parentNode===null){return false;}style.parentNode.removeChild(style);}/* istanbul ignore next  */const replaceText=function replaceText(){const textStore=[];return function replace(index,replacement){textStore[index]=replacement;return textStore.filter(Boolean).join('\\n');};}();function applyToSingletonTag(style,index,remove,obj){const css=remove?'':obj.media?'@media '+obj.media+' {'+obj.css+'}':obj.css;// For old IE\n/* istanbul ignore if  */if(style.styleSheet){style.styleSheet.cssText=replaceText(index,css);}else{const cssNode=document.createTextNode(css);const childNodes=style.childNodes;if(childNodes[index]){style.removeChild(childNodes[index]);}if(childNodes.length){style.insertBefore(cssNode,childNodes[index]);}else{style.appendChild(cssNode);}}}function applyToTag(style,options,obj){let css=obj.css;const media=obj.media;const sourceMap=obj.sourceMap;if(media){style.setAttribute('media',media);}else{style.removeAttribute('media');}if(sourceMap&&typeof btoa!=='undefined'){css+='\\n/*# sourceMappingURL=data:application/json;base64,'+btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))))+' */';}// For old IE\n/* istanbul ignore if  */if(style.styleSheet){style.styleSheet.cssText=css;}else{while(style.firstChild){style.removeChild(style.firstChild);}style.appendChild(document.createTextNode(css));}}let singleton=null;let singletonCounter=0;function addStyle(obj,options){let style;let update;let remove;if(options.singleton){const styleIndex=singletonCounter++;style=singleton||(singleton=insertStyleElement(options));update=applyToSingletonTag.bind(null,style,styleIndex,false);remove=applyToSingletonTag.bind(null,style,styleIndex,true);}else{style=insertStyleElement(options);update=applyToTag.bind(null,style,options);remove=function(){removeStyleElement(style);};}update(obj);return function updateStyle(newObj){if(newObj){if(newObj.css===obj.css&&newObj.media===obj.media&&newObj.sourceMap===obj.sourceMap){return;}update(obj=newObj);}else{remove();}};}module.exports=function(list,options){options=options||{};// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nif(!options.singleton&&typeof options.singleton!=='boolean'){options.singleton=isOldIE();}list=list||[];let lastIdentifiers=modulesToDom(list,options);return function update(newList){newList=newList||[];if(Object.prototype.toString.call(newList)!=='[object Array]'){return;}for(let i=0;i<lastIdentifiers.length;i++){const identifier=lastIdentifiers[i];const index=getIndexByIdentifier(identifier);stylesInDom[index].references--;}const newLastIdentifiers=modulesToDom(newList,options);for(let i=0;i<lastIdentifiers.length;i++){const identifier=lastIdentifiers[i];const index=getIndexByIdentifier(identifier);if(stylesInDom[index].references===0){stylesInDom[index].updater();stylesInDom.splice(index,1);}}lastIdentifiers=newLastIdentifiers;};};\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanM/Nzc2MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYSxpQ0FBaUMsU0FBUywyQkFBMkIsOEJBQThCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGVBQWUsR0FBRyxxQ0FBcUMsY0FBYyxpQ0FBaUMsc0NBQXNDLCtDQUErQztBQUN2UCw4RUFBOEUsSUFBSTtBQUNsRjtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZELG1CQUFtQiwwQkFBMEIsdUJBQXVCLEdBQUcscUJBQXFCLDBDQUEwQyxjQUFjLFlBQVkscUJBQXFCLEtBQUssMkNBQTJDLFNBQVMsUUFBUSxlQUFlLG9DQUFvQyxvQkFBb0IscUJBQXFCLFlBQVksY0FBYyxLQUFLLG1CQUFtQixtREFBbUQsOEJBQThCLHlDQUF5Qyx1QkFBdUIsNkNBQTZDLFdBQVcsNkNBQTZDLGVBQWUsZ0NBQWdDLGlDQUFpQyxLQUFLLGtCQUFrQixpRUFBaUUsR0FBRyw4QkFBOEIsb0JBQW9CLHFDQUFxQyw0Q0FBNEMsd0NBQXdDLDBDQUEwQztBQUMxL0IsS0FBc0MsQ0FBQyxzQkFBaUIsQ0FBQyxTQUFJLENBQUMsVUFBVSx5QkFBeUIsOENBQThDLHlDQUF5QyxFQUFFLHVDQUF1Qyx1QkFBdUIsS0FBSywrQ0FBK0MsWUFBWSw0SEFBNEgsMkJBQTJCLGNBQWMsbUNBQW1DO0FBQ2hnQiw0QkFBNEIsY0FBYyxxQ0FBcUMsb0VBQW9FLG1CQUFtQiwyQ0FBMkMsNkJBQTZCLCtDQUErQyxHQUFHLHFEQUFxRCxxREFBcUQsWUFBWSxVQUFVO0FBQ2hhLDhDQUE4QyxpREFBaUQsS0FBSywyQ0FBMkMsa0NBQWtDLHNCQUFzQixzQ0FBc0Msc0JBQXNCLCtDQUErQyxLQUFLLDhCQUE4Qix1Q0FBdUMsZ0JBQWdCLHNCQUFzQiw4QkFBOEIsVUFBVSxtQ0FBbUMsS0FBSyxnQ0FBZ0MseUNBQXlDLG1EQUFtRCw4RUFBOEU7QUFDNXJCLDhDQUE4Qyw4QkFBOEIsS0FBSyx3QkFBd0IscUNBQXFDLGtEQUFrRCxtQkFBbUIsdUJBQXVCLCtCQUErQixVQUFVLFdBQVcsV0FBVyxzQkFBc0Isb0NBQW9DLHlEQUF5RCw2REFBNkQsNkRBQTZELEtBQUssa0NBQWtDLDJDQUEyQyxrQkFBa0IsNkJBQTZCLFlBQVksb0NBQW9DLFdBQVcscUZBQXFGLFFBQVEsb0JBQW9CLEtBQUssYUFBYSxzQ0FBc0Msb0JBQW9CO0FBQy80QjtBQUNBLDZEQUE2RCw2QkFBNkIsY0FBYywrQ0FBK0MsZ0NBQWdDLG9CQUFvQiwrREFBK0QsUUFBUSxZQUFZLHlCQUF5QixLQUFLLG9DQUFvQyw2Q0FBNkMsaUNBQWlDLHVEQUF1RCxZQUFZLHlCQUF5QixLQUFLLG9DQUFvQyw2Q0FBNkMsc0NBQXNDLDZCQUE2Qiw4QkFBOEI7QUFDanNCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtjb25zdCBpc09sZElFPWZ1bmN0aW9uIGlzT2xkSUUoKXtsZXQgbWVtbztyZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKXtpZih0eXBlb2YgbWVtbz09PSd1bmRlZmluZWQnKXsvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4vLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbm1lbW89Qm9vbGVhbih3aW5kb3cmJmRvY3VtZW50JiZkb2N1bWVudC5hbGwmJiF3aW5kb3cuYXRvYik7fXJldHVybiBtZW1vO307fSgpO2NvbnN0IGdldFRhcmdldD1mdW5jdGlvbiBnZXRUYXJnZXQoKXtjb25zdCBtZW1vPXt9O3JldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpe2lmKHR5cGVvZiBtZW1vW3RhcmdldF09PT0ndW5kZWZpbmVkJyl7bGV0IHN0eWxlVGFyZ2V0PWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuaWYod2luZG93LkhUTUxJRnJhbWVFbGVtZW50JiZzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCl7dHJ5ey8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4vLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuc3R5bGVUYXJnZXQ9c3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7fWNhdGNoKGUpey8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG5zdHlsZVRhcmdldD1udWxsO319bWVtb1t0YXJnZXRdPXN0eWxlVGFyZ2V0O31yZXR1cm4gbWVtb1t0YXJnZXRdO307fSgpO2NvbnN0IHN0eWxlc0luRG9tPVtdO2Z1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpe2xldCByZXN1bHQ9LTE7Zm9yKGxldCBpPTA7aTxzdHlsZXNJbkRvbS5sZW5ndGg7aSsrKXtpZihzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyPT09aWRlbnRpZmllcil7cmVzdWx0PWk7YnJlYWs7fX1yZXR1cm4gcmVzdWx0O31mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCxvcHRpb25zKXtjb25zdCBpZENvdW50TWFwPXt9O2NvbnN0IGlkZW50aWZpZXJzPVtdO2ZvcihsZXQgaT0wO2k8bGlzdC5sZW5ndGg7aSsrKXtjb25zdCBpdGVtPWxpc3RbaV07Y29uc3QgaWQ9b3B0aW9ucy5iYXNlP2l0ZW1bMF0rb3B0aW9ucy5iYXNlOml0ZW1bMF07Y29uc3QgY291bnQ9aWRDb3VudE1hcFtpZF18fDA7Y29uc3QgaWRlbnRpZmllcj1pZCsnICcrY291bnQudG9TdHJpbmcoKTtpZENvdW50TWFwW2lkXT1jb3VudCsxO2NvbnN0IGluZGV4PWdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO2NvbnN0IG9iaj17Y3NzOml0ZW1bMV0sbWVkaWE6aXRlbVsyXSxzb3VyY2VNYXA6aXRlbVszXX07aWYoaW5kZXghPT0tMSl7c3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMrKztzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO31lbHNle3N0eWxlc0luRG9tLnB1c2goe2lkZW50aWZpZXI6aWRlbnRpZmllcix1cGRhdGVyOmFkZFN0eWxlKG9iaixvcHRpb25zKSxyZWZlcmVuY2VzOjF9KTt9aWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTt9cmV0dXJuIGlkZW50aWZpZXJzO31mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucyl7Y29uc3Qgc3R5bGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtjb25zdCBhdHRyaWJ1dGVzPW9wdGlvbnMuYXR0cmlidXRlc3x8e307aWYodHlwZW9mIGF0dHJpYnV0ZXMubm9uY2U9PT0ndW5kZWZpbmVkJyl7Y29uc3Qgbm9uY2U9Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG50eXBlb2YgX193ZWJwYWNrX25vbmNlX18hPT0ndW5kZWZpbmVkJz9fX3dlYnBhY2tfbm9uY2VfXzpudWxsO2lmKG5vbmNlKXthdHRyaWJ1dGVzLm5vbmNlPW5vbmNlO319T2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpe3N0eWxlLnNldEF0dHJpYnV0ZShrZXksYXR0cmlidXRlc1trZXldKTt9KTtpZih0eXBlb2Ygb3B0aW9ucy5pbnNlcnQ9PT0nZnVuY3Rpb24nKXtvcHRpb25zLmluc2VydChzdHlsZSk7fWVsc2V7Y29uc3QgdGFyZ2V0PWdldFRhcmdldChvcHRpb25zLmluc2VydHx8J2hlYWQnKTtpZighdGFyZ2V0KXt0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO310YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO31yZXR1cm4gc3R5bGU7fWZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSl7Ly8gaXN0YW5idWwgaWdub3JlIGlmXG5pZihzdHlsZS5wYXJlbnROb2RlPT09bnVsbCl7cmV0dXJuIGZhbHNlO31zdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTt9LyogaXN0YW5idWwgaWdub3JlIG5leHQgICovY29uc3QgcmVwbGFjZVRleHQ9ZnVuY3Rpb24gcmVwbGFjZVRleHQoKXtjb25zdCB0ZXh0U3RvcmU9W107cmV0dXJuIGZ1bmN0aW9uIHJlcGxhY2UoaW5kZXgscmVwbGFjZW1lbnQpe3RleHRTdG9yZVtpbmRleF09cmVwbGFjZW1lbnQ7cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7fTt9KCk7ZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSxpbmRleCxyZW1vdmUsb2JqKXtjb25zdCBjc3M9cmVtb3ZlPycnOm9iai5tZWRpYT8nQG1lZGlhICcrb2JqLm1lZGlhKycgeycrb2JqLmNzcysnfSc6b2JqLmNzczsvLyBGb3Igb2xkIElFXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovaWYoc3R5bGUuc3R5bGVTaGVldCl7c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0PXJlcGxhY2VUZXh0KGluZGV4LGNzcyk7fWVsc2V7Y29uc3QgY3NzTm9kZT1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO2NvbnN0IGNoaWxkTm9kZXM9c3R5bGUuY2hpbGROb2RlcztpZihjaGlsZE5vZGVzW2luZGV4XSl7c3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO31pZihjaGlsZE5vZGVzLmxlbmd0aCl7c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsY2hpbGROb2Rlc1tpbmRleF0pO31lbHNle3N0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO319fWZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsb3B0aW9ucyxvYmope2xldCBjc3M9b2JqLmNzcztjb25zdCBtZWRpYT1vYmoubWVkaWE7Y29uc3Qgc291cmNlTWFwPW9iai5zb3VyY2VNYXA7aWYobWVkaWEpe3N0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLG1lZGlhKTt9ZWxzZXtzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJyk7fWlmKHNvdXJjZU1hcCYmdHlwZW9mIGJ0b2EhPT0ndW5kZWZpbmVkJyl7Y3NzKz0nXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCwnK2J0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkrJyAqLyc7fS8vIEZvciBvbGQgSUVcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9pZihzdHlsZS5zdHlsZVNoZWV0KXtzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQ9Y3NzO31lbHNle3doaWxlKHN0eWxlLmZpcnN0Q2hpbGQpe3N0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO31zdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTt9fWxldCBzaW5nbGV0b249bnVsbDtsZXQgc2luZ2xldG9uQ291bnRlcj0wO2Z1bmN0aW9uIGFkZFN0eWxlKG9iaixvcHRpb25zKXtsZXQgc3R5bGU7bGV0IHVwZGF0ZTtsZXQgcmVtb3ZlO2lmKG9wdGlvbnMuc2luZ2xldG9uKXtjb25zdCBzdHlsZUluZGV4PXNpbmdsZXRvbkNvdW50ZXIrKztzdHlsZT1zaW5nbGV0b258fChzaW5nbGV0b249aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTt1cGRhdGU9YXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsc3R5bGUsc3R5bGVJbmRleCxmYWxzZSk7cmVtb3ZlPWFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLHN0eWxlLHN0eWxlSW5kZXgsdHJ1ZSk7fWVsc2V7c3R5bGU9aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO3VwZGF0ZT1hcHBseVRvVGFnLmJpbmQobnVsbCxzdHlsZSxvcHRpb25zKTtyZW1vdmU9ZnVuY3Rpb24oKXtyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO307fXVwZGF0ZShvYmopO3JldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmope2lmKG5ld09iail7aWYobmV3T2JqLmNzcz09PW9iai5jc3MmJm5ld09iai5tZWRpYT09PW9iai5tZWRpYSYmbmV3T2JqLnNvdXJjZU1hcD09PW9iai5zb3VyY2VNYXApe3JldHVybjt9dXBkYXRlKG9iaj1uZXdPYmopO31lbHNle3JlbW92ZSgpO319O31tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihsaXN0LG9wdGlvbnMpe29wdGlvbnM9b3B0aW9uc3x8e307Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4vLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5pZighb3B0aW9ucy5zaW5nbGV0b24mJnR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiE9PSdib29sZWFuJyl7b3B0aW9ucy5zaW5nbGV0b249aXNPbGRJRSgpO31saXN0PWxpc3R8fFtdO2xldCBsYXN0SWRlbnRpZmllcnM9bW9kdWxlc1RvRG9tKGxpc3Qsb3B0aW9ucyk7cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KXtuZXdMaXN0PW5ld0xpc3R8fFtdO2lmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdMaXN0KSE9PSdbb2JqZWN0IEFycmF5XScpe3JldHVybjt9Zm9yKGxldCBpPTA7aTxsYXN0SWRlbnRpZmllcnMubGVuZ3RoO2krKyl7Y29uc3QgaWRlbnRpZmllcj1sYXN0SWRlbnRpZmllcnNbaV07Y29uc3QgaW5kZXg9Z2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7c3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTt9Y29uc3QgbmV3TGFzdElkZW50aWZpZXJzPW1vZHVsZXNUb0RvbShuZXdMaXN0LG9wdGlvbnMpO2ZvcihsZXQgaT0wO2k8bGFzdElkZW50aWZpZXJzLmxlbmd0aDtpKyspe2NvbnN0IGlkZW50aWZpZXI9bGFzdElkZW50aWZpZXJzW2ldO2NvbnN0IGluZGV4PWdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO2lmKHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzPT09MCl7c3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIoKTtzdHlsZXNJbkRvbS5zcGxpY2UoaW5kZXgsMSk7fX1sYXN0SWRlbnRpZmllcnM9bmV3TGFzdElkZW50aWZpZXJzO307fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/api.js":
/*!***********************************!*\
  !*** (webpack)/css-loader/api.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {module.exports=function(){\"use strict\";var n={762:function(n){n.exports=function(n){var t=[];t.toString=function toString(){return this.map(function(t){var r=cssWithMappingToString(t,n);if(t[2]){return\"@media \".concat(t[2],\" {\").concat(r,\"}\")}return r}).join(\"\")};t.i=function(n,r,o){if(typeof n===\"string\"){n=[[null,n,\"\"]]}var e={};if(o){for(var a=0;a<this.length;a++){var c=this[a][0];if(c!=null){e[c]=true}}}for(var i=0;i<n.length;i++){var u=[].concat(n[i]);if(o&&e[u[0]]){continue}if(r){if(!u[2]){u[2]=r}else{u[2]=\"\".concat(r,\" and \").concat(u[2])}}t.push(u)}};return t};function cssWithMappingToString(n,t){var r=n[1]||\"\";var o=n[3];if(!o){return r}if(t&&typeof btoa===\"function\"){var e=toComment(o);var a=o.sources.map(function(n){return\"/*# sourceURL=\".concat(o.sourceRoot||\"\").concat(n,\" */\")});return[r].concat(a).concat([e]).join(\"\\n\")}return[r].join(\"\\n\")}function toComment(n){var t=btoa(unescape(encodeURIComponent(JSON.stringify(n))));var r=\"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(t);return\"/*# \".concat(r,\" */\")}}};var t={};function __nccwpck_require__(r){if(t[r]){return t[r].exports}var o=t[r]={exports:{}};var e=true;try{n[r](o,o.exports,__nccwpck_require__);e=false}finally{if(e)delete t[r]}return o.exports}__nccwpck_require__.ab=__dirname+\"/\";return __nccwpck_require__(762)}();\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLyh3ZWJwYWNrKS9jc3MtbG9hZGVyL2FwaS5qcz84ZmI5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJFQUEwQixhQUFhLE9BQU8sZ0JBQWdCLHNCQUFzQixTQUFTLCtCQUErQiw0QkFBNEIsa0NBQWtDLFNBQVMsK0JBQStCLGNBQWMsR0FBRyxTQUFTLFlBQVksb0JBQW9CLHdCQUF3QixnQkFBZ0IsU0FBUyxNQUFNLFlBQVksY0FBYyxLQUFLLGlCQUFpQixZQUFZLFlBQVksWUFBWSxXQUFXLEtBQUssc0JBQXNCLGVBQWUsU0FBUyxNQUFNLFVBQVUsT0FBTyxLQUFLLHdDQUF3QyxZQUFZLFVBQVUscUNBQXFDLGVBQWUsV0FBVyxPQUFPLFNBQVMsZ0NBQWdDLG1CQUFtQixnQ0FBZ0MsZ0VBQWdFLEVBQUUsMkNBQTJDLHFCQUFxQixzQkFBc0IsNERBQTRELDhDQUE4QyxjQUFjLG1CQUFtQixnQ0FBZ0MsU0FBUyxnQ0FBZ0MsU0FBUyxvQkFBb0IsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIscUNBQXFDLGdDQUFnQyxHIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2FwaS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49ezc2MjpmdW5jdGlvbihuKXtuLmV4cG9ydHM9ZnVuY3Rpb24obil7dmFyIHQ9W107dC50b1N0cmluZz1mdW5jdGlvbiB0b1N0cmluZygpe3JldHVybiB0aGlzLm1hcChmdW5jdGlvbih0KXt2YXIgcj1jc3NXaXRoTWFwcGluZ1RvU3RyaW5nKHQsbik7aWYodFsyXSl7cmV0dXJuXCJAbWVkaWEgXCIuY29uY2F0KHRbMl0sXCIge1wiKS5jb25jYXQocixcIn1cIil9cmV0dXJuIHJ9KS5qb2luKFwiXCIpfTt0Lmk9ZnVuY3Rpb24obixyLG8pe2lmKHR5cGVvZiBuPT09XCJzdHJpbmdcIil7bj1bW251bGwsbixcIlwiXV19dmFyIGU9e307aWYobyl7Zm9yKHZhciBhPTA7YTx0aGlzLmxlbmd0aDthKyspe3ZhciBjPXRoaXNbYV1bMF07aWYoYyE9bnVsbCl7ZVtjXT10cnVlfX19Zm9yKHZhciBpPTA7aTxuLmxlbmd0aDtpKyspe3ZhciB1PVtdLmNvbmNhdChuW2ldKTtpZihvJiZlW3VbMF1dKXtjb250aW51ZX1pZihyKXtpZighdVsyXSl7dVsyXT1yfWVsc2V7dVsyXT1cIlwiLmNvbmNhdChyLFwiIGFuZCBcIikuY29uY2F0KHVbMl0pfX10LnB1c2godSl9fTtyZXR1cm4gdH07ZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhuLHQpe3ZhciByPW5bMV18fFwiXCI7dmFyIG89blszXTtpZighbyl7cmV0dXJuIHJ9aWYodCYmdHlwZW9mIGJ0b2E9PT1cImZ1bmN0aW9uXCIpe3ZhciBlPXRvQ29tbWVudChvKTt2YXIgYT1vLnNvdXJjZXMubWFwKGZ1bmN0aW9uKG4pe3JldHVyblwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoby5zb3VyY2VSb290fHxcIlwiKS5jb25jYXQobixcIiAqL1wiKX0pO3JldHVybltyXS5jb25jYXQoYSkuY29uY2F0KFtlXSkuam9pbihcIlxcblwiKX1yZXR1cm5bcl0uam9pbihcIlxcblwiKX1mdW5jdGlvbiB0b0NvbW1lbnQobil7dmFyIHQ9YnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkobikpKSk7dmFyIHI9XCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQodCk7cmV0dXJuXCIvKiMgXCIuY29uY2F0KHIsXCIgKi9cIil9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXtpZih0W3JdKXtyZXR1cm4gdFtyXS5leHBvcnRzfXZhciBvPXRbcl09e2V4cG9ydHM6e319O3ZhciBlPXRydWU7dHJ5e25bcl0obyxvLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7ZT1mYWxzZX1maW5hbGx5e2lmKGUpZGVsZXRlIHRbcl19cmV0dXJuIG8uZXhwb3J0c31fX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjtyZXR1cm4gX19uY2N3cGNrX3JlcXVpcmVfXyg3NjIpfSgpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/css-loader/api.js\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/@splidejs/splide/dist/css/themes/splide-default.min.css":
/*!******************************************************************************************************************************************************************************!*\
  !*** (webpack)/css-loader/cjs.js??ref--5-oneOf-5-1!(webpack)/postcss-loader/cjs.js??ref--5-oneOf-5-2!./node_modules/@splidejs/splide/dist/css/themes/splide-default.min.css ***!
  \******************************************************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../next/dist/compiled/css-loader/api.js */ \"./node_modules/next/dist/compiled/css-loader/api.js\");\n/* harmony import */ var _next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _next_dist_compiled_css_loader_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.i, \"@-webkit-keyframes splide-loading{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes splide-loading{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}.splide__container{position:relative;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}.splide__list{margin:0!important;padding:0!important;width:-moz-max-content;width:max-content;will-change:transform}.splide.is-active .splide__list{display:-moz-box;display:flex}.splide__pagination{display:-moz-inline-box;display:inline-flex;-moz-box-align:center;align-items:center;width:95%;flex-wrap:wrap;-moz-box-pack:center;justify-content:center;margin:0}.splide__pagination li{list-style-type:none;display:inline-block;line-height:1;margin:0}.splide{visibility:hidden}.splide,.splide__slide{position:relative;outline:none}.splide__slide{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;list-style-type:none!important;margin:0;flex-shrink:0}.splide__slide img{vertical-align:bottom}.splide__slider{position:relative}.splide__spinner{position:absolute;top:0;left:0;right:0;bottom:0;margin:auto;display:inline-block;width:20px;height:20px;border-radius:50%;border:2px solid #999;border-left-color:transparent;-webkit-animation:splide-loading 1s linear infinite;animation:splide-loading 1s linear infinite}.splide__track{position:relative;z-index:0;overflow:hidden}.splide--draggable>.splide__track>.splide__list>.splide__slide{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.splide--fade>.splide__track>.splide__list{display:block}.splide--fade>.splide__track>.splide__list>.splide__slide{position:absolute;top:0;left:0;z-index:0;opacity:0}.splide--fade>.splide__track>.splide__list>.splide__slide.is-active{position:relative;z-index:1;opacity:1}.splide--rtl{direction:rtl}.splide--ttb>.splide__track>.splide__list{display:block}.splide--ttb>.splide__pagination{width:auto}.splide__arrow{position:absolute;z-index:1;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);width:2em;height:2em;border-radius:50%;display:-moz-box;display:flex;-moz-box-align:center;align-items:center;-moz-box-pack:center;justify-content:center;border:none;padding:0;opacity:.7;background:#ccc}.splide__arrow svg{width:1.2em;height:1.2em}.splide__arrow:hover{cursor:pointer;opacity:.9}.splide__arrow:focus{outline:none}.splide__arrow--prev{left:1em}.splide__arrow--prev svg{-webkit-transform:scaleX(-1);transform:scaleX(-1)}.splide__arrow--next{right:1em}.splide__pagination{position:absolute;z-index:1;bottom:.5em;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%);padding:0}.splide__pagination__page{display:inline-block;width:8px;height:8px;background:#ccc;border-radius:50%;margin:3px;padding:0;-webkit-transition:-webkit-transform .2s linear;transition:-webkit-transform .2s linear;transition:transform .2s linear;transition:transform .2s linear, -webkit-transform .2s linear;border:none;opacity:.7}.splide__pagination__page.is-active{-webkit-transform:scale(1.4);transform:scale(1.4);background:#fff}.splide__pagination__page:hover{cursor:pointer;opacity:.9}.splide__pagination__page:focus{outline:none}.splide__progress__bar{width:0;height:3px;background:#ccc}.splide--nav>.splide__track>.splide__list>.splide__slide{border:3px solid transparent}.splide--nav>.splide__track>.splide__list>.splide__slide.is-active{border-color:#000}.splide--nav>.splide__track>.splide__list>.splide__slide:focus{outline:none}.splide--rtl>.splide__arrows .splide__arrow--prev,.splide--rtl>.splide__track>.splide__arrows .splide__arrow--prev{right:1em;left:auto}.splide--rtl>.splide__arrows .splide__arrow--prev svg,.splide--rtl>.splide__track>.splide__arrows .splide__arrow--prev svg{-webkit-transform:scaleX(1);transform:scaleX(1)}.splide--rtl>.splide__arrows .splide__arrow--next,.splide--rtl>.splide__track>.splide__arrows .splide__arrow--next{left:1em;right:auto}.splide--rtl>.splide__arrows .splide__arrow--next svg,.splide--rtl>.splide__track>.splide__arrows .splide__arrow--next svg{-webkit-transform:scaleX(-1);transform:scaleX(-1)}.splide--ttb>.splide__arrows .splide__arrow,.splide--ttb>.splide__track>.splide__arrows .splide__arrow{left:50%;-webkit-transform:translate(-50%);transform:translate(-50%)}.splide--ttb>.splide__arrows .splide__arrow--prev,.splide--ttb>.splide__track>.splide__arrows .splide__arrow--prev{top:1em}.splide--ttb>.splide__arrows .splide__arrow--prev svg,.splide--ttb>.splide__track>.splide__arrows .splide__arrow--prev svg{-webkit-transform:rotate(-90deg);transform:rotate(-90deg)}.splide--ttb>.splide__arrows .splide__arrow--next,.splide--ttb>.splide__track>.splide__arrows .splide__arrow--next{top:auto;bottom:1em}.splide--ttb>.splide__arrows .splide__arrow--next svg,.splide--ttb>.splide__track>.splide__arrows .splide__arrow--next svg{-webkit-transform:rotate(90deg);transform:rotate(90deg)}.splide--ttb>.splide__pagination{display:-moz-box;display:flex;-moz-box-orient:vertical;-moz-box-direction:normal;flex-direction:column;bottom:50%;left:auto;right:.5em;-webkit-transform:translateY(50%);transform:translateY(50%)}\", \"\",{\"version\":3,\"sources\":[\"webpack://node_modules/@splidejs/splide/dist/css/themes/splide-default.min.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"@keyframes splide-loading{0%{transform:rotate(0)}to{transform:rotate(1turn)}}.splide__container{position:relative;box-sizing:border-box}.splide__list{margin:0!important;padding:0!important;width:-webkit-max-content;width:max-content;will-change:transform}.splide.is-active .splide__list{display:flex}.splide__pagination{display:inline-flex;align-items:center;width:95%;flex-wrap:wrap;justify-content:center;margin:0}.splide__pagination li{list-style-type:none;display:inline-block;line-height:1;margin:0}.splide{visibility:hidden}.splide,.splide__slide{position:relative;outline:none}.splide__slide{box-sizing:border-box;list-style-type:none!important;margin:0;flex-shrink:0}.splide__slide img{vertical-align:bottom}.splide__slider{position:relative}.splide__spinner{position:absolute;top:0;left:0;right:0;bottom:0;margin:auto;display:inline-block;width:20px;height:20px;border-radius:50%;border:2px solid #999;border-left-color:transparent;animation:splide-loading 1s linear infinite}.splide__track{position:relative;z-index:0;overflow:hidden}.splide--draggable>.splide__track>.splide__list>.splide__slide{-webkit-user-select:none;user-select:none}.splide--fade>.splide__track>.splide__list{display:block}.splide--fade>.splide__track>.splide__list>.splide__slide{position:absolute;top:0;left:0;z-index:0;opacity:0}.splide--fade>.splide__track>.splide__list>.splide__slide.is-active{position:relative;z-index:1;opacity:1}.splide--rtl{direction:rtl}.splide--ttb>.splide__track>.splide__list{display:block}.splide--ttb>.splide__pagination{width:auto}.splide__arrow{position:absolute;z-index:1;top:50%;transform:translateY(-50%);width:2em;height:2em;border-radius:50%;display:flex;align-items:center;justify-content:center;border:none;padding:0;opacity:.7;background:#ccc}.splide__arrow svg{width:1.2em;height:1.2em}.splide__arrow:hover{cursor:pointer;opacity:.9}.splide__arrow:focus{outline:none}.splide__arrow--prev{left:1em}.splide__arrow--prev svg{transform:scaleX(-1)}.splide__arrow--next{right:1em}.splide__pagination{position:absolute;z-index:1;bottom:.5em;left:50%;transform:translateX(-50%);padding:0}.splide__pagination__page{display:inline-block;width:8px;height:8px;background:#ccc;border-radius:50%;margin:3px;padding:0;transition:transform .2s linear;border:none;opacity:.7}.splide__pagination__page.is-active{transform:scale(1.4);background:#fff}.splide__pagination__page:hover{cursor:pointer;opacity:.9}.splide__pagination__page:focus{outline:none}.splide__progress__bar{width:0;height:3px;background:#ccc}.splide--nav>.splide__track>.splide__list>.splide__slide{border:3px solid transparent}.splide--nav>.splide__track>.splide__list>.splide__slide.is-active{border-color:#000}.splide--nav>.splide__track>.splide__list>.splide__slide:focus{outline:none}.splide--rtl>.splide__arrows .splide__arrow--prev,.splide--rtl>.splide__track>.splide__arrows .splide__arrow--prev{right:1em;left:auto}.splide--rtl>.splide__arrows .splide__arrow--prev svg,.splide--rtl>.splide__track>.splide__arrows .splide__arrow--prev svg{transform:scaleX(1)}.splide--rtl>.splide__arrows .splide__arrow--next,.splide--rtl>.splide__track>.splide__arrows .splide__arrow--next{left:1em;right:auto}.splide--rtl>.splide__arrows .splide__arrow--next svg,.splide--rtl>.splide__track>.splide__arrows .splide__arrow--next svg{transform:scaleX(-1)}.splide--ttb>.splide__arrows .splide__arrow,.splide--ttb>.splide__track>.splide__arrows .splide__arrow{left:50%;transform:translate(-50%)}.splide--ttb>.splide__arrows .splide__arrow--prev,.splide--ttb>.splide__track>.splide__arrows .splide__arrow--prev{top:1em}.splide--ttb>.splide__arrows .splide__arrow--prev svg,.splide--ttb>.splide__track>.splide__arrows .splide__arrow--prev svg{transform:rotate(-90deg)}.splide--ttb>.splide__arrows .splide__arrow--next,.splide--ttb>.splide__track>.splide__arrows .splide__arrow--next{top:auto;bottom:1em}.splide--ttb>.splide__arrows .splide__arrow--next svg,.splide--ttb>.splide__track>.splide__arrows .splide__arrow--next svg{transform:rotate(90deg)}.splide--ttb>.splide__pagination{display:flex;flex-direction:column;bottom:50%;left:auto;right:.5em;transform:translateY(50%)}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzcGxpZGVqcy9zcGxpZGUvZGlzdC9jc3MvdGhlbWVzL3NwbGlkZS1kZWZhdWx0Lm1pbi5jc3M/MTZjNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUM4RjtBQUM5Riw4QkFBOEIsNEVBQTJCO0FBQ3pEO0FBQ0EsOEJBQThCLFFBQVMscUNBQXFDLEdBQUcsNEJBQTRCLG9CQUFvQixHQUFHLGdDQUFnQyx5QkFBeUIsMEJBQTBCLEdBQUcsNEJBQTRCLG9CQUFvQixHQUFHLGdDQUFnQyx5QkFBeUIsbUJBQW1CLGtCQUFrQiw4QkFBOEIsMkJBQTJCLHNCQUFzQixjQUFjLG1CQUFtQixvQkFBb0IsdUJBQXVCLGtCQUFrQixzQkFBc0IsZ0NBQWdDLGlCQUFpQixhQUFhLG9CQUFvQix3QkFBd0Isb0JBQW9CLHNCQUFzQixtQkFBbUIsVUFBVSxlQUFlLHFCQUFxQix1QkFBdUIsU0FBUyx1QkFBdUIscUJBQXFCLHFCQUFxQixjQUFjLFNBQVMsUUFBUSxrQkFBa0IsdUJBQXVCLGtCQUFrQixhQUFhLGVBQWUsOEJBQThCLDJCQUEyQixzQkFBc0IsK0JBQStCLFNBQVMsY0FBYyxtQkFBbUIsc0JBQXNCLGdCQUFnQixrQkFBa0IsaUJBQWlCLGtCQUFrQixNQUFNLE9BQU8sUUFBUSxTQUFTLFlBQVkscUJBQXFCLFdBQVcsWUFBWSxrQkFBa0Isc0JBQXNCLDhCQUE4QixvREFBb0QsNENBQTRDLGVBQWUsa0JBQWtCLFVBQVUsZ0JBQWdCLCtEQUErRCx5QkFBeUIsc0JBQXNCLHFCQUFxQixpQkFBaUIsMkNBQTJDLGNBQWMsMERBQTBELGtCQUFrQixNQUFNLE9BQU8sVUFBVSxVQUFVLG9FQUFvRSxrQkFBa0IsVUFBVSxVQUFVLGFBQWEsY0FBYywwQ0FBMEMsY0FBYyxpQ0FBaUMsV0FBVyxlQUFlLGtCQUFrQixVQUFVLFFBQVEsbUNBQW1DLDJCQUEyQixVQUFVLFdBQVcsa0JBQWtCLGlCQUFpQixhQUFhLHNCQUFzQixtQkFBbUIscUJBQXFCLHVCQUF1QixZQUFZLFVBQVUsV0FBVyxnQkFBZ0IsbUJBQW1CLFlBQVksYUFBYSxxQkFBcUIsZUFBZSxXQUFXLHFCQUFxQixhQUFhLHFCQUFxQixTQUFTLHlCQUF5Qiw2QkFBNkIscUJBQXFCLHFCQUFxQixVQUFVLG9CQUFvQixrQkFBa0IsVUFBVSxZQUFZLFNBQVMsbUNBQW1DLDJCQUEyQixVQUFVLDBCQUEwQixxQkFBcUIsVUFBVSxXQUFXLGdCQUFnQixrQkFBa0IsV0FBVyxVQUFVLGdEQUFnRCx3Q0FBd0MsZ0NBQWdDLDhEQUE4RCxZQUFZLFdBQVcsb0NBQW9DLDZCQUE2QixxQkFBcUIsZ0JBQWdCLGdDQUFnQyxlQUFlLFdBQVcsZ0NBQWdDLGFBQWEsdUJBQXVCLFFBQVEsV0FBVyxnQkFBZ0IseURBQXlELDZCQUE2QixtRUFBbUUsa0JBQWtCLCtEQUErRCxhQUFhLG1IQUFtSCxVQUFVLFVBQVUsMkhBQTJILDRCQUE0QixvQkFBb0IsbUhBQW1ILFNBQVMsV0FBVywySEFBMkgsNkJBQTZCLHFCQUFxQix1R0FBdUcsU0FBUyxrQ0FBa0MsMEJBQTBCLG1IQUFtSCxRQUFRLDJIQUEySCxpQ0FBaUMseUJBQXlCLG1IQUFtSCxTQUFTLFdBQVcsMkhBQTJILGdDQUFnQyx3QkFBd0IsaUNBQWlDLGlCQUFpQixhQUFhLHlCQUF5QiwwQkFBMEIsc0JBQXNCLFdBQVcsVUFBVSxXQUFXLGtDQUFrQywwQkFBMEIsT0FBTyxrekVBQWt6RSxHQUFHLG9CQUFvQixHQUFHLHlCQUF5QixtQkFBbUIsa0JBQWtCLHNCQUFzQixjQUFjLG1CQUFtQixvQkFBb0IsMEJBQTBCLGtCQUFrQixzQkFBc0IsZ0NBQWdDLGFBQWEsb0JBQW9CLG9CQUFvQixtQkFBbUIsVUFBVSxlQUFlLHVCQUF1QixTQUFTLHVCQUF1QixxQkFBcUIscUJBQXFCLGNBQWMsU0FBUyxRQUFRLGtCQUFrQix1QkFBdUIsa0JBQWtCLGFBQWEsZUFBZSxzQkFBc0IsK0JBQStCLFNBQVMsY0FBYyxtQkFBbUIsc0JBQXNCLGdCQUFnQixrQkFBa0IsaUJBQWlCLGtCQUFrQixNQUFNLE9BQU8sUUFBUSxTQUFTLFlBQVkscUJBQXFCLFdBQVcsWUFBWSxrQkFBa0Isc0JBQXNCLDhCQUE4Qiw0Q0FBNEMsZUFBZSxrQkFBa0IsVUFBVSxnQkFBZ0IsK0RBQStELHlCQUF5QixpQkFBaUIsMkNBQTJDLGNBQWMsMERBQTBELGtCQUFrQixNQUFNLE9BQU8sVUFBVSxVQUFVLG9FQUFvRSxrQkFBa0IsVUFBVSxVQUFVLGFBQWEsY0FBYywwQ0FBMEMsY0FBYyxpQ0FBaUMsV0FBVyxlQUFlLGtCQUFrQixVQUFVLFFBQVEsMkJBQTJCLFVBQVUsV0FBVyxrQkFBa0IsYUFBYSxtQkFBbUIsdUJBQXVCLFlBQVksVUFBVSxXQUFXLGdCQUFnQixtQkFBbUIsWUFBWSxhQUFhLHFCQUFxQixlQUFlLFdBQVcscUJBQXFCLGFBQWEscUJBQXFCLFNBQVMseUJBQXlCLHFCQUFxQixxQkFBcUIsVUFBVSxvQkFBb0Isa0JBQWtCLFVBQVUsWUFBWSxTQUFTLDJCQUEyQixVQUFVLDBCQUEwQixxQkFBcUIsVUFBVSxXQUFXLGdCQUFnQixrQkFBa0IsV0FBVyxVQUFVLGdDQUFnQyxZQUFZLFdBQVcsb0NBQW9DLHFCQUFxQixnQkFBZ0IsZ0NBQWdDLGVBQWUsV0FBVyxnQ0FBZ0MsYUFBYSx1QkFBdUIsUUFBUSxXQUFXLGdCQUFnQix5REFBeUQsNkJBQTZCLG1FQUFtRSxrQkFBa0IsK0RBQStELGFBQWEsbUhBQW1ILFVBQVUsVUFBVSwySEFBMkgsb0JBQW9CLG1IQUFtSCxTQUFTLFdBQVcsMkhBQTJILHFCQUFxQix1R0FBdUcsU0FBUywwQkFBMEIsbUhBQW1ILFFBQVEsMkhBQTJILHlCQUF5QixtSEFBbUgsU0FBUyxXQUFXLDJIQUEySCx3QkFBd0IsaUNBQWlDLGFBQWEsc0JBQXNCLFdBQVcsVUFBVSxXQUFXLDBCQUEwQixtQkFBbUI7QUFDdi9XO0FBQ2Usc0ZBQXVCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPyEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPyEuL25vZGVfbW9kdWxlcy9Ac3BsaWRlanMvc3BsaWRlL2Rpc3QvY3NzL3RoZW1lcy9zcGxpZGUtZGVmYXVsdC5taW4uY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCJALXdlYmtpdC1rZXlmcmFtZXMgc3BsaWRlLWxvYWRpbmd7MCV7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDApO3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDF0dXJuKTt0cmFuc2Zvcm06cm90YXRlKDF0dXJuKX19QGtleWZyYW1lcyBzcGxpZGUtbG9hZGluZ3swJXstd2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMCk7dHJhbnNmb3JtOnJvdGF0ZSgwKX10b3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoMXR1cm4pO3RyYW5zZm9ybTpyb3RhdGUoMXR1cm4pfX0uc3BsaWRlX19jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmU7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94fS5zcGxpZGVfX2xpc3R7bWFyZ2luOjAhaW1wb3J0YW50O3BhZGRpbmc6MCFpbXBvcnRhbnQ7d2lkdGg6LW1vei1tYXgtY29udGVudDt3aWR0aDptYXgtY29udGVudDt3aWxsLWNoYW5nZTp0cmFuc2Zvcm19LnNwbGlkZS5pcy1hY3RpdmUgLnNwbGlkZV9fbGlzdHtkaXNwbGF5Oi1tb3otYm94O2Rpc3BsYXk6ZmxleH0uc3BsaWRlX19wYWdpbmF0aW9ue2Rpc3BsYXk6LW1vei1pbmxpbmUtYm94O2Rpc3BsYXk6aW5saW5lLWZsZXg7LW1vei1ib3gtYWxpZ246Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjt3aWR0aDo5NSU7ZmxleC13cmFwOndyYXA7LW1vei1ib3gtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjttYXJnaW46MH0uc3BsaWRlX19wYWdpbmF0aW9uIGxpe2xpc3Qtc3R5bGUtdHlwZTpub25lO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2xpbmUtaGVpZ2h0OjE7bWFyZ2luOjB9LnNwbGlkZXt2aXNpYmlsaXR5OmhpZGRlbn0uc3BsaWRlLC5zcGxpZGVfX3NsaWRle3Bvc2l0aW9uOnJlbGF0aXZlO291dGxpbmU6bm9uZX0uc3BsaWRlX19zbGlkZXstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7bGlzdC1zdHlsZS10eXBlOm5vbmUhaW1wb3J0YW50O21hcmdpbjowO2ZsZXgtc2hyaW5rOjB9LnNwbGlkZV9fc2xpZGUgaW1ne3ZlcnRpY2FsLWFsaWduOmJvdHRvbX0uc3BsaWRlX19zbGlkZXJ7cG9zaXRpb246cmVsYXRpdmV9LnNwbGlkZV9fc3Bpbm5lcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDtib3R0b206MDttYXJnaW46YXV0bztkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDoyMHB4O2hlaWdodDoyMHB4O2JvcmRlci1yYWRpdXM6NTAlO2JvcmRlcjoycHggc29saWQgIzk5OTtib3JkZXItbGVmdC1jb2xvcjp0cmFuc3BhcmVudDstd2Via2l0LWFuaW1hdGlvbjpzcGxpZGUtbG9hZGluZyAxcyBsaW5lYXIgaW5maW5pdGU7YW5pbWF0aW9uOnNwbGlkZS1sb2FkaW5nIDFzIGxpbmVhciBpbmZpbml0ZX0uc3BsaWRlX190cmFja3twb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjA7b3ZlcmZsb3c6aGlkZGVufS5zcGxpZGUtLWRyYWdnYWJsZT4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19saXN0Pi5zcGxpZGVfX3NsaWRley13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uc3BsaWRlLS1mYWRlPi5zcGxpZGVfX3RyYWNrPi5zcGxpZGVfX2xpc3R7ZGlzcGxheTpibG9ja30uc3BsaWRlLS1mYWRlPi5zcGxpZGVfX3RyYWNrPi5zcGxpZGVfX2xpc3Q+LnNwbGlkZV9fc2xpZGV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3otaW5kZXg6MDtvcGFjaXR5OjB9LnNwbGlkZS0tZmFkZT4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19saXN0Pi5zcGxpZGVfX3NsaWRlLmlzLWFjdGl2ZXtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjE7b3BhY2l0eToxfS5zcGxpZGUtLXJ0bHtkaXJlY3Rpb246cnRsfS5zcGxpZGUtLXR0Yj4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19saXN0e2Rpc3BsYXk6YmxvY2t9LnNwbGlkZS0tdHRiPi5zcGxpZGVfX3BhZ2luYXRpb257d2lkdGg6YXV0b30uc3BsaWRlX19hcnJvd3twb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjE7dG9wOjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3dpZHRoOjJlbTtoZWlnaHQ6MmVtO2JvcmRlci1yYWRpdXM6NTAlO2Rpc3BsYXk6LW1vei1ib3g7ZGlzcGxheTpmbGV4Oy1tb3otYm94LWFsaWduOmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7LW1vei1ib3gtcGFjazpjZW50ZXI7anVzdGlmeS1jb250ZW50OmNlbnRlcjtib3JkZXI6bm9uZTtwYWRkaW5nOjA7b3BhY2l0eTouNztiYWNrZ3JvdW5kOiNjY2N9LnNwbGlkZV9fYXJyb3cgc3Zne3dpZHRoOjEuMmVtO2hlaWdodDoxLjJlbX0uc3BsaWRlX19hcnJvdzpob3ZlcntjdXJzb3I6cG9pbnRlcjtvcGFjaXR5Oi45fS5zcGxpZGVfX2Fycm93OmZvY3Vze291dGxpbmU6bm9uZX0uc3BsaWRlX19hcnJvdy0tcHJldntsZWZ0OjFlbX0uc3BsaWRlX19hcnJvdy0tcHJldiBzdmd7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGVYKC0xKTt0cmFuc2Zvcm06c2NhbGVYKC0xKX0uc3BsaWRlX19hcnJvdy0tbmV4dHtyaWdodDoxZW19LnNwbGlkZV9fcGFnaW5hdGlvbntwb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjE7Ym90dG9tOi41ZW07bGVmdDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKTtwYWRkaW5nOjB9LnNwbGlkZV9fcGFnaW5hdGlvbl9fcGFnZXtkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDo4cHg7aGVpZ2h0OjhweDtiYWNrZ3JvdW5kOiNjY2M7Ym9yZGVyLXJhZGl1czo1MCU7bWFyZ2luOjNweDtwYWRkaW5nOjA7LXdlYmtpdC10cmFuc2l0aW9uOi13ZWJraXQtdHJhbnNmb3JtIC4ycyBsaW5lYXI7dHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSAuMnMgbGluZWFyO3RyYW5zaXRpb246dHJhbnNmb3JtIC4ycyBsaW5lYXI7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjJzIGxpbmVhciwgLXdlYmtpdC10cmFuc2Zvcm0gLjJzIGxpbmVhcjtib3JkZXI6bm9uZTtvcGFjaXR5Oi43fS5zcGxpZGVfX3BhZ2luYXRpb25fX3BhZ2UuaXMtYWN0aXZley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKDEuNCk7dHJhbnNmb3JtOnNjYWxlKDEuNCk7YmFja2dyb3VuZDojZmZmfS5zcGxpZGVfX3BhZ2luYXRpb25fX3BhZ2U6aG92ZXJ7Y3Vyc29yOnBvaW50ZXI7b3BhY2l0eTouOX0uc3BsaWRlX19wYWdpbmF0aW9uX19wYWdlOmZvY3Vze291dGxpbmU6bm9uZX0uc3BsaWRlX19wcm9ncmVzc19fYmFye3dpZHRoOjA7aGVpZ2h0OjNweDtiYWNrZ3JvdW5kOiNjY2N9LnNwbGlkZS0tbmF2Pi5zcGxpZGVfX3RyYWNrPi5zcGxpZGVfX2xpc3Q+LnNwbGlkZV9fc2xpZGV7Ym9yZGVyOjNweCBzb2xpZCB0cmFuc3BhcmVudH0uc3BsaWRlLS1uYXY+LnNwbGlkZV9fdHJhY2s+LnNwbGlkZV9fbGlzdD4uc3BsaWRlX19zbGlkZS5pcy1hY3RpdmV7Ym9yZGVyLWNvbG9yOiMwMDB9LnNwbGlkZS0tbmF2Pi5zcGxpZGVfX3RyYWNrPi5zcGxpZGVfX2xpc3Q+LnNwbGlkZV9fc2xpZGU6Zm9jdXN7b3V0bGluZTpub25lfS5zcGxpZGUtLXJ0bD4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLXByZXYsLnNwbGlkZS0tcnRsPi5zcGxpZGVfX3RyYWNrPi5zcGxpZGVfX2Fycm93cyAuc3BsaWRlX19hcnJvdy0tcHJldntyaWdodDoxZW07bGVmdDphdXRvfS5zcGxpZGUtLXJ0bD4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLXByZXYgc3ZnLC5zcGxpZGUtLXJ0bD4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLXByZXYgc3Zney13ZWJraXQtdHJhbnNmb3JtOnNjYWxlWCgxKTt0cmFuc2Zvcm06c2NhbGVYKDEpfS5zcGxpZGUtLXJ0bD4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLW5leHQsLnNwbGlkZS0tcnRsPi5zcGxpZGVfX3RyYWNrPi5zcGxpZGVfX2Fycm93cyAuc3BsaWRlX19hcnJvdy0tbmV4dHtsZWZ0OjFlbTtyaWdodDphdXRvfS5zcGxpZGUtLXJ0bD4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLW5leHQgc3ZnLC5zcGxpZGUtLXJ0bD4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLW5leHQgc3Zney13ZWJraXQtdHJhbnNmb3JtOnNjYWxlWCgtMSk7dHJhbnNmb3JtOnNjYWxlWCgtMSl9LnNwbGlkZS0tdHRiPi5zcGxpZGVfX2Fycm93cyAuc3BsaWRlX19hcnJvdywuc3BsaWRlLS10dGI+LnNwbGlkZV9fdHJhY2s+LnNwbGlkZV9fYXJyb3dzIC5zcGxpZGVfX2Fycm93e2xlZnQ6NTAlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUpfS5zcGxpZGUtLXR0Yj4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLXByZXYsLnNwbGlkZS0tdHRiPi5zcGxpZGVfX3RyYWNrPi5zcGxpZGVfX2Fycm93cyAuc3BsaWRlX19hcnJvdy0tcHJldnt0b3A6MWVtfS5zcGxpZGUtLXR0Yj4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLXByZXYgc3ZnLC5zcGxpZGUtLXR0Yj4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLXByZXYgc3Zney13ZWJraXQtdHJhbnNmb3JtOnJvdGF0ZSgtOTBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoLTkwZGVnKX0uc3BsaWRlLS10dGI+LnNwbGlkZV9fYXJyb3dzIC5zcGxpZGVfX2Fycm93LS1uZXh0LC5zcGxpZGUtLXR0Yj4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLW5leHR7dG9wOmF1dG87Ym90dG9tOjFlbX0uc3BsaWRlLS10dGI+LnNwbGlkZV9fYXJyb3dzIC5zcGxpZGVfX2Fycm93LS1uZXh0IHN2Zywuc3BsaWRlLS10dGI+LnNwbGlkZV9fdHJhY2s+LnNwbGlkZV9fYXJyb3dzIC5zcGxpZGVfX2Fycm93LS1uZXh0IHN2Z3std2Via2l0LXRyYW5zZm9ybTpyb3RhdGUoOTBkZWcpO3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpfS5zcGxpZGUtLXR0Yj4uc3BsaWRlX19wYWdpbmF0aW9ue2Rpc3BsYXk6LW1vei1ib3g7ZGlzcGxheTpmbGV4Oy1tb3otYm94LW9yaWVudDp2ZXJ0aWNhbDstbW96LWJveC1kaXJlY3Rpb246bm9ybWFsO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtib3R0b206NTAlO2xlZnQ6YXV0bztyaWdodDouNWVtOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSg1MCUpfVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9ub2RlX21vZHVsZXMvQHNwbGlkZWpzL3NwbGlkZS9kaXN0L2Nzcy90aGVtZXMvc3BsaWRlLWRlZmF1bHQubWluLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxrQ0FBMEIsR0FBRywyQkFBa0IsQ0FBbEIsbUJBQW1CLENBQUMsR0FBRywrQkFBc0IsQ0FBdEIsdUJBQXVCLENBQUMsQ0FBNUUsMEJBQTBCLEdBQUcsMkJBQWtCLENBQWxCLG1CQUFtQixDQUFDLEdBQUcsK0JBQXNCLENBQXRCLHVCQUF1QixDQUFDLENBQUMsbUJBQW1CLGlCQUFpQixDQUFDLDZCQUFvQixDQUFwQiwwQkFBb0IsQ0FBcEIscUJBQXFCLENBQUMsY0FBYyxrQkFBa0IsQ0FBQyxtQkFBbUIsQ0FBMkIsc0JBQWlCLENBQWpCLGlCQUFpQixDQUFDLHFCQUFxQixDQUFDLGdDQUFnQyxnQkFBVyxDQUFYLFlBQVksQ0FBQyxvQkFBb0IsdUJBQW1CLENBQW5CLG1CQUFtQixDQUFDLHFCQUFrQixDQUFsQixrQkFBa0IsQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLG9CQUFzQixDQUF0QixzQkFBc0IsQ0FBQyxRQUFRLENBQUMsdUJBQXVCLG9CQUFvQixDQUFDLG9CQUFvQixDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsUUFBUSxpQkFBaUIsQ0FBQyx1QkFBdUIsaUJBQWlCLENBQUMsWUFBWSxDQUFDLGVBQWUsNkJBQXFCLENBQXJCLDBCQUFxQixDQUFyQixxQkFBcUIsQ0FBQyw4QkFBOEIsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLG1CQUFtQixxQkFBcUIsQ0FBQyxnQkFBZ0IsaUJBQWlCLENBQUMsaUJBQWlCLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsb0JBQW9CLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxxQkFBcUIsQ0FBQyw2QkFBNkIsQ0FBQyxtREFBMEMsQ0FBMUMsMkNBQTJDLENBQUMsZUFBZSxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLCtEQUErRCx3QkFBd0IsQ0FBQyxxQkFBZSxDQUFmLG9CQUFlLENBQWYsZ0JBQWdCLENBQUMsMkNBQTJDLGFBQWEsQ0FBQywwREFBMEQsaUJBQWlCLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLG9FQUFvRSxpQkFBaUIsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLGFBQWEsYUFBYSxDQUFDLDBDQUEwQyxhQUFhLENBQUMsaUNBQWlDLFVBQVUsQ0FBQyxlQUFlLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsa0NBQTBCLENBQTFCLDBCQUEwQixDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUMsZ0JBQVksQ0FBWixZQUFZLENBQUMscUJBQWtCLENBQWxCLGtCQUFrQixDQUFDLG9CQUFzQixDQUF0QixzQkFBc0IsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsbUJBQW1CLFdBQVcsQ0FBQyxZQUFZLENBQUMscUJBQXFCLGNBQWMsQ0FBQyxVQUFVLENBQUMscUJBQXFCLFlBQVksQ0FBQyxxQkFBcUIsUUFBUSxDQUFDLHlCQUF5Qiw0QkFBbUIsQ0FBbkIsb0JBQW9CLENBQUMscUJBQXFCLFNBQVMsQ0FBQyxvQkFBb0IsaUJBQWlCLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsa0NBQTBCLENBQTFCLDBCQUEwQixDQUFDLFNBQVMsQ0FBQywwQkFBMEIsb0JBQW9CLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQywrQ0FBK0IsQ0FBL0IsdUNBQStCLENBQS9CLCtCQUErQixDQUEvQiw2REFBK0IsQ0FBQyxXQUFXLENBQUMsVUFBVSxDQUFDLG9DQUFvQyw0QkFBb0IsQ0FBcEIsb0JBQW9CLENBQUMsZUFBZSxDQUFDLGdDQUFnQyxjQUFjLENBQUMsVUFBVSxDQUFDLGdDQUFnQyxZQUFZLENBQUMsdUJBQXVCLE9BQU8sQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLHlEQUF5RCw0QkFBNEIsQ0FBQyxtRUFBbUUsaUJBQWlCLENBQUMsK0RBQStELFlBQVksQ0FBQyxtSEFBbUgsU0FBUyxDQUFDLFNBQVMsQ0FBQywySEFBMkgsMkJBQWtCLENBQWxCLG1CQUFtQixDQUFDLG1IQUFtSCxRQUFRLENBQUMsVUFBVSxDQUFDLDJIQUEySCw0QkFBbUIsQ0FBbkIsb0JBQW9CLENBQUMsdUdBQXVHLFFBQVEsQ0FBQyxpQ0FBd0IsQ0FBeEIseUJBQXlCLENBQUMsbUhBQW1ILE9BQU8sQ0FBQywySEFBMkgsZ0NBQXVCLENBQXZCLHdCQUF3QixDQUFDLG1IQUFtSCxRQUFRLENBQUMsVUFBVSxDQUFDLDJIQUEySCwrQkFBc0IsQ0FBdEIsdUJBQXVCLENBQUMsaUNBQWlDLGdCQUFZLENBQVosWUFBWSxDQUFDLHdCQUFxQixDQUFyQix5QkFBcUIsQ0FBckIscUJBQXFCLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsaUNBQXdCLENBQXhCLHlCQUF5QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAa2V5ZnJhbWVzIHNwbGlkZS1sb2FkaW5nezAle3RyYW5zZm9ybTpyb3RhdGUoMCl9dG97dHJhbnNmb3JtOnJvdGF0ZSgxdHVybil9fS5zcGxpZGVfX2NvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZTtib3gtc2l6aW5nOmJvcmRlci1ib3h9LnNwbGlkZV9fbGlzdHttYXJnaW46MCFpbXBvcnRhbnQ7cGFkZGluZzowIWltcG9ydGFudDt3aWR0aDotd2Via2l0LW1heC1jb250ZW50O3dpZHRoOm1heC1jb250ZW50O3dpbGwtY2hhbmdlOnRyYW5zZm9ybX0uc3BsaWRlLmlzLWFjdGl2ZSAuc3BsaWRlX19saXN0e2Rpc3BsYXk6ZmxleH0uc3BsaWRlX19wYWdpbmF0aW9ue2Rpc3BsYXk6aW5saW5lLWZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO3dpZHRoOjk1JTtmbGV4LXdyYXA6d3JhcDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbjowfS5zcGxpZGVfX3BhZ2luYXRpb24gbGl7bGlzdC1zdHlsZS10eXBlOm5vbmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7bGluZS1oZWlnaHQ6MTttYXJnaW46MH0uc3BsaWRle3Zpc2liaWxpdHk6aGlkZGVufS5zcGxpZGUsLnNwbGlkZV9fc2xpZGV7cG9zaXRpb246cmVsYXRpdmU7b3V0bGluZTpub25lfS5zcGxpZGVfX3NsaWRle2JveC1zaXppbmc6Ym9yZGVyLWJveDtsaXN0LXN0eWxlLXR5cGU6bm9uZSFpbXBvcnRhbnQ7bWFyZ2luOjA7ZmxleC1zaHJpbms6MH0uc3BsaWRlX19zbGlkZSBpbWd7dmVydGljYWwtYWxpZ246Ym90dG9tfS5zcGxpZGVfX3NsaWRlcntwb3NpdGlvbjpyZWxhdGl2ZX0uc3BsaWRlX19zcGlubmVye3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtyaWdodDowO2JvdHRvbTowO21hcmdpbjphdXRvO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjIwcHg7aGVpZ2h0OjIwcHg7Ym9yZGVyLXJhZGl1czo1MCU7Ym9yZGVyOjJweCBzb2xpZCAjOTk5O2JvcmRlci1sZWZ0LWNvbG9yOnRyYW5zcGFyZW50O2FuaW1hdGlvbjpzcGxpZGUtbG9hZGluZyAxcyBsaW5lYXIgaW5maW5pdGV9LnNwbGlkZV9fdHJhY2t7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDowO292ZXJmbG93OmhpZGRlbn0uc3BsaWRlLS1kcmFnZ2FibGU+LnNwbGlkZV9fdHJhY2s+LnNwbGlkZV9fbGlzdD4uc3BsaWRlX19zbGlkZXstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0uc3BsaWRlLS1mYWRlPi5zcGxpZGVfX3RyYWNrPi5zcGxpZGVfX2xpc3R7ZGlzcGxheTpibG9ja30uc3BsaWRlLS1mYWRlPi5zcGxpZGVfX3RyYWNrPi5zcGxpZGVfX2xpc3Q+LnNwbGlkZV9fc2xpZGV7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3otaW5kZXg6MDtvcGFjaXR5OjB9LnNwbGlkZS0tZmFkZT4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19saXN0Pi5zcGxpZGVfX3NsaWRlLmlzLWFjdGl2ZXtwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjE7b3BhY2l0eToxfS5zcGxpZGUtLXJ0bHtkaXJlY3Rpb246cnRsfS5zcGxpZGUtLXR0Yj4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19saXN0e2Rpc3BsYXk6YmxvY2t9LnNwbGlkZS0tdHRiPi5zcGxpZGVfX3BhZ2luYXRpb257d2lkdGg6YXV0b30uc3BsaWRlX19hcnJvd3twb3NpdGlvbjphYnNvbHV0ZTt6LWluZGV4OjE7dG9wOjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt3aWR0aDoyZW07aGVpZ2h0OjJlbTtib3JkZXItcmFkaXVzOjUwJTtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXI7Ym9yZGVyOm5vbmU7cGFkZGluZzowO29wYWNpdHk6Ljc7YmFja2dyb3VuZDojY2NjfS5zcGxpZGVfX2Fycm93IHN2Z3t3aWR0aDoxLjJlbTtoZWlnaHQ6MS4yZW19LnNwbGlkZV9fYXJyb3c6aG92ZXJ7Y3Vyc29yOnBvaW50ZXI7b3BhY2l0eTouOX0uc3BsaWRlX19hcnJvdzpmb2N1c3tvdXRsaW5lOm5vbmV9LnNwbGlkZV9fYXJyb3ctLXByZXZ7bGVmdDoxZW19LnNwbGlkZV9fYXJyb3ctLXByZXYgc3Zne3RyYW5zZm9ybTpzY2FsZVgoLTEpfS5zcGxpZGVfX2Fycm93LS1uZXh0e3JpZ2h0OjFlbX0uc3BsaWRlX19wYWdpbmF0aW9ue3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MTtib3R0b206LjVlbTtsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtNTAlKTtwYWRkaW5nOjB9LnNwbGlkZV9fcGFnaW5hdGlvbl9fcGFnZXtkaXNwbGF5OmlubGluZS1ibG9jazt3aWR0aDo4cHg7aGVpZ2h0OjhweDtiYWNrZ3JvdW5kOiNjY2M7Ym9yZGVyLXJhZGl1czo1MCU7bWFyZ2luOjNweDtwYWRkaW5nOjA7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjJzIGxpbmVhcjtib3JkZXI6bm9uZTtvcGFjaXR5Oi43fS5zcGxpZGVfX3BhZ2luYXRpb25fX3BhZ2UuaXMtYWN0aXZle3RyYW5zZm9ybTpzY2FsZSgxLjQpO2JhY2tncm91bmQ6I2ZmZn0uc3BsaWRlX19wYWdpbmF0aW9uX19wYWdlOmhvdmVye2N1cnNvcjpwb2ludGVyO29wYWNpdHk6Ljl9LnNwbGlkZV9fcGFnaW5hdGlvbl9fcGFnZTpmb2N1c3tvdXRsaW5lOm5vbmV9LnNwbGlkZV9fcHJvZ3Jlc3NfX2Jhcnt3aWR0aDowO2hlaWdodDozcHg7YmFja2dyb3VuZDojY2NjfS5zcGxpZGUtLW5hdj4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19saXN0Pi5zcGxpZGVfX3NsaWRle2JvcmRlcjozcHggc29saWQgdHJhbnNwYXJlbnR9LnNwbGlkZS0tbmF2Pi5zcGxpZGVfX3RyYWNrPi5zcGxpZGVfX2xpc3Q+LnNwbGlkZV9fc2xpZGUuaXMtYWN0aXZle2JvcmRlci1jb2xvcjojMDAwfS5zcGxpZGUtLW5hdj4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19saXN0Pi5zcGxpZGVfX3NsaWRlOmZvY3Vze291dGxpbmU6bm9uZX0uc3BsaWRlLS1ydGw+LnNwbGlkZV9fYXJyb3dzIC5zcGxpZGVfX2Fycm93LS1wcmV2LC5zcGxpZGUtLXJ0bD4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLXByZXZ7cmlnaHQ6MWVtO2xlZnQ6YXV0b30uc3BsaWRlLS1ydGw+LnNwbGlkZV9fYXJyb3dzIC5zcGxpZGVfX2Fycm93LS1wcmV2IHN2Zywuc3BsaWRlLS1ydGw+LnNwbGlkZV9fdHJhY2s+LnNwbGlkZV9fYXJyb3dzIC5zcGxpZGVfX2Fycm93LS1wcmV2IHN2Z3t0cmFuc2Zvcm06c2NhbGVYKDEpfS5zcGxpZGUtLXJ0bD4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLW5leHQsLnNwbGlkZS0tcnRsPi5zcGxpZGVfX3RyYWNrPi5zcGxpZGVfX2Fycm93cyAuc3BsaWRlX19hcnJvdy0tbmV4dHtsZWZ0OjFlbTtyaWdodDphdXRvfS5zcGxpZGUtLXJ0bD4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLW5leHQgc3ZnLC5zcGxpZGUtLXJ0bD4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLW5leHQgc3Zne3RyYW5zZm9ybTpzY2FsZVgoLTEpfS5zcGxpZGUtLXR0Yj4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3csLnNwbGlkZS0tdHRiPi5zcGxpZGVfX3RyYWNrPi5zcGxpZGVfX2Fycm93cyAuc3BsaWRlX19hcnJvd3tsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUpfS5zcGxpZGUtLXR0Yj4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLXByZXYsLnNwbGlkZS0tdHRiPi5zcGxpZGVfX3RyYWNrPi5zcGxpZGVfX2Fycm93cyAuc3BsaWRlX19hcnJvdy0tcHJldnt0b3A6MWVtfS5zcGxpZGUtLXR0Yj4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLXByZXYgc3ZnLC5zcGxpZGUtLXR0Yj4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLXByZXYgc3Zne3RyYW5zZm9ybTpyb3RhdGUoLTkwZGVnKX0uc3BsaWRlLS10dGI+LnNwbGlkZV9fYXJyb3dzIC5zcGxpZGVfX2Fycm93LS1uZXh0LC5zcGxpZGUtLXR0Yj4uc3BsaWRlX190cmFjaz4uc3BsaWRlX19hcnJvd3MgLnNwbGlkZV9fYXJyb3ctLW5leHR7dG9wOmF1dG87Ym90dG9tOjFlbX0uc3BsaWRlLS10dGI+LnNwbGlkZV9fYXJyb3dzIC5zcGxpZGVfX2Fycm93LS1uZXh0IHN2Zywuc3BsaWRlLS10dGI+LnNwbGlkZV9fdHJhY2s+LnNwbGlkZV9fYXJyb3dzIC5zcGxpZGVfX2Fycm93LS1uZXh0IHN2Z3t0cmFuc2Zvcm06cm90YXRlKDkwZGVnKX0uc3BsaWRlLS10dGI+LnNwbGlkZV9fcGFnaW5hdGlvbntkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2JvdHRvbTo1MCU7bGVmdDphdXRvO3JpZ2h0Oi41ZW07dHJhbnNmb3JtOnRyYW5zbGF0ZVkoNTAlKX1cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/css-loader/cjs.js?!./node_modules/next/dist/compiled/postcss-loader/cjs.js?!./node_modules/@splidejs/splide/dist/css/themes/splide-default.min.css\n");

/***/ })

}]);